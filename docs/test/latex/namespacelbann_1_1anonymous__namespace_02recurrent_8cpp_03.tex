\hypertarget{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03}{}\section{lbann\+:\+:anonymous\+\_\+namespace\{recurrent.\+cpp\} Namespace Reference}
\label{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03}\index{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}@{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a8c76387c2dd531058700ad9a41cd093a}{unroll\+\_\+input\+\_\+layer} (int unroll\+\_\+depth, std\+::vector$<$ \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&layers, std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&prev\+\_\+step\+\_\+layer, std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&next\+\_\+step\+\_\+layer)
\item 
void \hyperlink{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_af04adecd9a62fdcd16ae78b3e95d4bb5}{unroll\+\_\+target\+\_\+layer} (int unroll\+\_\+depth, std\+::vector$<$ \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&layers, std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&prev\+\_\+step\+\_\+layer, std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&next\+\_\+step\+\_\+layer)
\item 
void \hyperlink{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a16733e1fb301c3099a5fe07d703c3782}{add\+\_\+unrolled\+\_\+layers} (int unroll\+\_\+depth, std\+::vector$<$ \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&layers, std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&prev\+\_\+step\+\_\+layer, std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&next\+\_\+step\+\_\+layer)
\item 
void \hyperlink{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a50bca1c07c6f3146947b2a0fb5cc815a}{add\+\_\+placeholder\+\_\+layers} (std\+::vector$<$ \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&layers, std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&prev\+\_\+step\+\_\+layer, std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&next\+\_\+step\+\_\+layer)
\item 
void \hyperlink{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a12a6f96a1c15c91218169bf7157cd800}{setup\+\_\+unrolled\+\_\+layer\+\_\+pointers} (std\+::vector$<$ \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&layers, const std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&prev\+\_\+step\+\_\+layer, const std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&next\+\_\+step\+\_\+layer)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a50bca1c07c6f3146947b2a0fb5cc815a}\label{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a50bca1c07c6f3146947b2a0fb5cc815a}} 
\index{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}@{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}}!add\+\_\+placeholder\+\_\+layers@{add\+\_\+placeholder\+\_\+layers}}
\index{add\+\_\+placeholder\+\_\+layers@{add\+\_\+placeholder\+\_\+layers}!lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}@{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}}}
\subsubsection{\texorpdfstring{add\+\_\+placeholder\+\_\+layers()}{add\_placeholder\_layers()}}
{\footnotesize\ttfamily void lbann\+::anonymous\+\_\+namespace\{recurrent.\+cpp\}\+::add\+\_\+placeholder\+\_\+layers (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{layers,  }\item[{std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{prev\+\_\+step\+\_\+layer,  }\item[{std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{next\+\_\+step\+\_\+layer }\end{DoxyParamCaption})}

Add placeholder layers for first and last recurrence step. If a layer in the first recurrence step expects input from an earlier recurrence step, we insert a zero-\/valued constant layer. If a layer in the last recurrence step expects to output to a later recurrence step, we insert a dummy layer. 

Definition at line 227 of file recurrent.\+cpp.


\begin{DoxyCode}
229                                                                                     \{
230 
231   std::unordered\_map<const Layer*,bool> is\_visited;
232   std::vector<Layer*> input\_placeholders, output\_placeholders;
233   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& l : layers) \{
234 
235     \textcolor{comment}{// Create constant layers as input placeholders}
236     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}&& parent : l->get\_parent\_layers()) \{
237       \textcolor{keywordflow}{if} (!is\_visited[parent] && prev\_step\_layer[parent] == \textcolor{keyword}{nullptr}) \{
238         \textcolor{keywordflow}{if} (parent->get\_num\_neurons() <= 0) \{
239           std::stringstream err;
240           err << \_\_FILE\_\_ << \textcolor{stringliteral}{" "} << \_\_LINE\_\_ << \textcolor{stringliteral}{" :: "}
241               << l->get\_name() << \textcolor{stringliteral}{" has ambiguous neuron "}
242               << \textcolor{stringliteral}{"dimensions since it depends on "}
243               << parent->get\_name() << \textcolor{stringliteral}{", which does not have "}
244               << \textcolor{stringliteral}{"specified neuron dimensions. Consider inserting a "}
245               << \textcolor{stringliteral}{"reshape layer after "} << parent->get\_name() << \textcolor{stringliteral}{" "}
246               << \textcolor{stringliteral}{"to explicitly specify neuron dimensions."};
247           \textcolor{keywordflow}{throw} lbann\_exception(err.str());
248         \}
249         Layer* placeholder = \textcolor{keyword}{nullptr};
250         \textcolor{keyword}{auto}&& \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm} = parent->get\_comm();
251         \textcolor{keywordflow}{switch} (parent->get\_data\_layout()) \{
252         \textcolor{keywordflow}{case} \hyperlink{base_8hpp_a786677cbfb3f5677b4d84f3056eb08dba37d2a3465f7cbf4ab60f4e79944d0638}{data\_layout::DATA\_PARALLEL}:
253           placeholder = \textcolor{keyword}{new} constant\_layer<data\_layout::DATA\_PARALLEL>(
254                               \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm},
255                               DataType(0),
256                               parent->get\_neuron\_dims()
257                             );
258           \textcolor{keywordflow}{break};
259         \textcolor{keywordflow}{case} \hyperlink{base_8hpp_a786677cbfb3f5677b4d84f3056eb08dbac94d7b0e44ab8bdcdad694a673cdeae0}{data\_layout::MODEL\_PARALLEL}:
260           placeholder = \textcolor{keyword}{new} constant\_layer<data\_layout::MODEL\_PARALLEL>(
261                               \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm},
262                               DataType(0),
263                               parent->get\_neuron\_dims()
264                             );
265           \textcolor{keywordflow}{break};
266         \textcolor{keywordflow}{default}:
267           std::stringstream err;
268           err << \_\_FILE\_\_ << \textcolor{stringliteral}{" "} << \_\_LINE\_\_ << \textcolor{stringliteral}{" :: "} << \textcolor{stringliteral}{"invalid data layout"};
269           \textcolor{keywordflow}{throw} lbann\_exception(err.str());
270         \}
271         placeholder->set\_name(parent->get\_name() + \textcolor{stringliteral}{"\_input\_placeholder"});
272         placeholder->add\_child\_layer(l);
273         input\_placeholders.push\_back(placeholder);
274         prev\_step\_layer[parent] = placeholder;
275         next\_step\_layer[placeholder] = \textcolor{keyword}{const\_cast<}Layer*\textcolor{keyword}{>}(parent);
276       \}
277     \}
278 
279     \textcolor{comment}{// Visit layer}
280     is\_visited[l] = \textcolor{keyword}{true};
281     
282     \textcolor{comment}{// Create dummy layers as output placeholders}
283     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}&& child : l->get\_child\_layers()) \{
284       \textcolor{keywordflow}{if} (is\_visited[child] && next\_step\_layer[child] == \textcolor{keyword}{nullptr}) \{
285         Layer* placeholder = \textcolor{keyword}{nullptr};
286         \textcolor{keyword}{auto}&& comm = child->get\_comm();
287         \textcolor{keywordflow}{switch} (child->get\_data\_layout()) \{
288         \textcolor{keywordflow}{case} \hyperlink{base_8hpp_a786677cbfb3f5677b4d84f3056eb08dba37d2a3465f7cbf4ab60f4e79944d0638}{data\_layout::DATA\_PARALLEL}:
289           placeholder = \textcolor{keyword}{new} dummy\_layer<data\_layout::DATA\_PARALLEL>(\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm});
290           \textcolor{keywordflow}{break};
291         \textcolor{keywordflow}{case} \hyperlink{base_8hpp_a786677cbfb3f5677b4d84f3056eb08dbac94d7b0e44ab8bdcdad694a673cdeae0}{data\_layout::MODEL\_PARALLEL}:
292           placeholder = \textcolor{keyword}{new} dummy\_layer<data\_layout::MODEL\_PARALLEL>(\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm});
293           \textcolor{keywordflow}{break};
294         \textcolor{keywordflow}{default}:
295           std::stringstream err;
296           err << \_\_FILE\_\_ << \textcolor{stringliteral}{" "} << \_\_LINE\_\_ << \textcolor{stringliteral}{" :: "} << \textcolor{stringliteral}{"invalid data layout"};
297           \textcolor{keywordflow}{throw} lbann\_exception(err.str());
298         \}
299         placeholder->set\_name(child->get\_name() + \textcolor{stringliteral}{"\_output\_placeholder"});
300         placeholder->add\_parent\_layer(l);
301         output\_placeholders.push\_back(placeholder);
302         next\_step\_layer[child] = placeholder;
303         prev\_step\_layer[placeholder] = \textcolor{keyword}{const\_cast<}Layer*\textcolor{keyword}{>}(child);
304       \}
305     \}
306     
307   \}
308 
309   \textcolor{comment}{// Add placeholder layers to model}
310   layers.insert(layers.begin() + 2,
311                 input\_placeholders.begin(),
312                 input\_placeholders.end());
313   layers.insert(layers.end() - 2,
314                 output\_placeholders.begin(),
315                 output\_placeholders.end());
316 
317 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a50bca1c07c6f3146947b2a0fb5cc815a_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a50bca1c07c6f3146947b2a0fb5cc815a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a16733e1fb301c3099a5fe07d703c3782}\label{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a16733e1fb301c3099a5fe07d703c3782}} 
\index{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}@{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}}!add\+\_\+unrolled\+\_\+layers@{add\+\_\+unrolled\+\_\+layers}}
\index{add\+\_\+unrolled\+\_\+layers@{add\+\_\+unrolled\+\_\+layers}!lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}@{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}}}
\subsubsection{\texorpdfstring{add\+\_\+unrolled\+\_\+layers()}{add\_unrolled\_layers()}}
{\footnotesize\ttfamily void lbann\+::anonymous\+\_\+namespace\{recurrent.\+cpp\}\+::add\+\_\+unrolled\+\_\+layers (\begin{DoxyParamCaption}\item[{int}]{unroll\+\_\+depth,  }\item[{std\+::vector$<$ \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{layers,  }\item[{std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{prev\+\_\+step\+\_\+layer,  }\item[{std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{next\+\_\+step\+\_\+layer }\end{DoxyParamCaption})}

Duplicate layer network to achieve desired recurrence depth. The layers within each recurrence step have the same topology as the original network. 

Definition at line 175 of file recurrent.\+cpp.


\begin{DoxyCode}
178                                                                                  \{
179 
180   \textcolor{comment}{// Unroll network to desired depth}
181   std::vector<Layer*> previous\_step(layers.begin() + 2, layers.end() - 2);
182   \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_step\_layers = previous\_step.size();
183   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} step = 1; step < unroll\_depth; ++step) \{
184     
185     \textcolor{comment}{// Construct current step by copying layers from previous step}
186     std::vector<Layer*> current\_step;
187     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& previous\_layer : previous\_step) \{
188       \textcolor{keyword}{auto}&& current\_layer = previous\_layer->copy();
189       current\_step.push\_back(current\_layer);
190       prev\_step\_layer[current\_layer] = previous\_layer;
191       next\_step\_layer[previous\_layer] = current\_layer;
192     \}
193 
194     \textcolor{comment}{// Fix pointers within current step}
195     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& current\_layer : current\_step) \{
196       \textcolor{keyword}{auto} layer\_pointers = current\_layer->get\_layer\_pointers();
197       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& layer\_pointer : layer\_pointers) \{
198         layer\_pointer = next\_step\_layer[layer\_pointer];
199       \}
200       current\_layer->set\_layer\_pointers(layer\_pointers);
201     \}
202 
203     \textcolor{comment}{// Add current step layers to model}
204     layers.insert(layers.end() - 2, current\_step.begin(), current\_step.end());
205     previous\_step = current\_step;
206 
207   \}
208 
209   \textcolor{comment}{// Rename layers}
210   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} step = 0; step < unroll\_depth; ++step) \{
211     \textcolor{keyword}{const} std::string name\_suffix = \textcolor{stringliteral}{"\_step"} + std::to\_string(step);
212     \textcolor{keyword}{const} \textcolor{keywordtype}{int} step\_start = 2 + step * num\_step\_layers;
213     \textcolor{keyword}{const} \textcolor{keywordtype}{int} step\_end = 2 + (step + 1) * num\_step\_layers;
214     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = step\_start; i < step\_end; ++i) \{
215       layers[i]->set\_name(layers[i]->get\_name() + name\_suffix);
216     \}
217   \}
218   
219 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a16733e1fb301c3099a5fe07d703c3782_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a12a6f96a1c15c91218169bf7157cd800}\label{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a12a6f96a1c15c91218169bf7157cd800}} 
\index{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}@{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}}!setup\+\_\+unrolled\+\_\+layer\+\_\+pointers@{setup\+\_\+unrolled\+\_\+layer\+\_\+pointers}}
\index{setup\+\_\+unrolled\+\_\+layer\+\_\+pointers@{setup\+\_\+unrolled\+\_\+layer\+\_\+pointers}!lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}@{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}}}
\subsubsection{\texorpdfstring{setup\+\_\+unrolled\+\_\+layer\+\_\+pointers()}{setup\_unrolled\_layer\_pointers()}}
{\footnotesize\ttfamily void lbann\+::anonymous\+\_\+namespace\{recurrent.\+cpp\}\+::setup\+\_\+unrolled\+\_\+layer\+\_\+pointers (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{layers,  }\item[{const std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{prev\+\_\+step\+\_\+layer,  }\item[{const std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{next\+\_\+step\+\_\+layer }\end{DoxyParamCaption})}

Setup pointers between recurrence steps. If a layer\textquotesingle{}s parent appears after the layer itself, change the parent to the corresponding layer in the previous recurrence step. Similarly, if a layer\textquotesingle{}s child appears before the layer itself, change the child to the corresponding layer in the next recurrence step. 

Definition at line 326 of file recurrent.\+cpp.


\begin{DoxyCode}
328                                                                                                  \{
329 
330   std::unordered\_map<const Layer*,bool> is\_visited;
331   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}&& l : layers) \{
332     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& parent : l->get\_parent\_layers()) \{
333       \textcolor{keywordflow}{if} (!is\_visited[parent]) \{
334         parent = prev\_step\_layer.at(parent);
335       \}
336     \}
337     is\_visited[l] = \textcolor{keyword}{true};
338     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& child : l->get\_child\_layers()) \{
339       \textcolor{keywordflow}{if} (is\_visited[child]) \{
340         child = next\_step\_layer.at(child);
341       \}
342     \}
343   \}
344   
345 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a12a6f96a1c15c91218169bf7157cd800_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a8c76387c2dd531058700ad9a41cd093a}\label{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a8c76387c2dd531058700ad9a41cd093a}} 
\index{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}@{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}}!unroll\+\_\+input\+\_\+layer@{unroll\+\_\+input\+\_\+layer}}
\index{unroll\+\_\+input\+\_\+layer@{unroll\+\_\+input\+\_\+layer}!lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}@{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}}}
\subsubsection{\texorpdfstring{unroll\+\_\+input\+\_\+layer()}{unroll\_input\_layer()}}
{\footnotesize\ttfamily void lbann\+::anonymous\+\_\+namespace\{recurrent.\+cpp\}\+::unroll\+\_\+input\+\_\+layer (\begin{DoxyParamCaption}\item[{int}]{unroll\+\_\+depth,  }\item[{std\+::vector$<$ \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{layers,  }\item[{std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{prev\+\_\+step\+\_\+layer,  }\item[{std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{next\+\_\+step\+\_\+layer }\end{DoxyParamCaption})}

Setup input layer to match unrolled network. The first layer is assumed to be an input layer. A slice layer and a split layer are inserted after the input layer. 

Definition at line 47 of file recurrent.\+cpp.


\begin{DoxyCode}
50                                                                                 \{
51     std::stringstream err;
52 
53   \textcolor{comment}{// We expect first layer to be an input layer}
54   \textcolor{keyword}{auto}&& input = \textcolor{keyword}{dynamic\_cast<}generic\_input\_layer*\textcolor{keyword}{>}(layers.front());
55   \textcolor{keywordflow}{if} (input == \textcolor{keyword}{nullptr}) \{
56     err << \_\_FILE\_\_ << \textcolor{stringliteral}{" "} << \_\_LINE\_\_ << \textcolor{stringliteral}{" :: "}
57         << \textcolor{stringliteral}{"expected the first layer to be an input layer"};
58     \textcolor{keywordflow}{throw} lbann\_exception(err.str());
59   \}
60   
61   \textcolor{comment}{// Determine slice points}
62   \textcolor{keyword}{const} \textcolor{keyword}{auto}& input\_dims = input->get\_neuron\_dims();
63   \textcolor{keyword}{const} \textcolor{keyword}{auto}& slice\_size = input\_dims.front() / unroll\_depth;
64   std::vector<int> slice\_points;
65   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} step = 0; step <= unroll\_depth; ++step) \{
66     slice\_points.push\_back(slice\_size * step);
67   \}
68 
69   \textcolor{comment}{// Construct slice and split layer}
70   Layer* slice = \textcolor{keyword}{nullptr};
71   Layer* split = \textcolor{keyword}{nullptr};
72   \textcolor{keyword}{auto}&& \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm} = input->get\_comm();
73   cudnn::cudnn\_manager* cudnn = \textcolor{keyword}{nullptr};
74   \textcolor{keywordflow}{switch} (input->get\_data\_layout()) \{
75   \textcolor{keywordflow}{case} \hyperlink{base_8hpp_a786677cbfb3f5677b4d84f3056eb08dba37d2a3465f7cbf4ab60f4e79944d0638}{data\_layout::DATA\_PARALLEL}:
76     slice = \textcolor{keyword}{new} slice\_layer<data\_layout::DATA\_PARALLEL>(\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}, 0, slice\_points, cudnn);
77     split = \textcolor{keyword}{new} split\_layer<data\_layout::DATA\_PARALLEL>(\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}, cudnn);
78     \textcolor{keywordflow}{break};
79   \textcolor{keywordflow}{case} \hyperlink{base_8hpp_a786677cbfb3f5677b4d84f3056eb08dbac94d7b0e44ab8bdcdad694a673cdeae0}{data\_layout::MODEL\_PARALLEL}:
80     slice = \textcolor{keyword}{new} slice\_layer<data\_layout::MODEL\_PARALLEL>(\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}, 0, slice\_points, cudnn);
81     split = \textcolor{keyword}{new} split\_layer<data\_layout::MODEL\_PARALLEL>(\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}, cudnn);
82     \textcolor{keywordflow}{break};
83   \textcolor{keywordflow}{default}:
84     err << \_\_FILE\_\_ << \textcolor{stringliteral}{" "} << \_\_LINE\_\_ << \textcolor{stringliteral}{" :: "} << \textcolor{stringliteral}{"invalid data layout"};
85     \textcolor{keywordflow}{throw} lbann\_exception(err.str());
86   \}
87   slice->set\_name(input->get\_name() + \textcolor{stringliteral}{"\_slice"});
88   split->set\_name(input->get\_name() + \textcolor{stringliteral}{"\_split"});
89   layers.insert(layers.begin() + 1, slice);
90   layers.insert(layers.begin() + 2, split);
91 
92   \textcolor{comment}{// Setup relationships between split layer and child layers}
93   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}&& child : input->get\_child\_layers()) \{
94     split->add\_child\_layer(child);
95     \textcolor{keyword}{auto}& child\_parents = \textcolor{keyword}{const\_cast<}Layer*\textcolor{keyword}{>}(child)->get\_parent\_layers();
96     std::replace(child\_parents.begin(), child\_parents.end(),
97                  \textcolor{keyword}{static\_cast<}Layer*\textcolor{keyword}{>}(input), split);
98   \}
99   input->clear\_child\_layers();
100 
101   \textcolor{comment}{// Setup relationship between input layer, slice layer, and split layer}
102   input->add\_child\_layer(slice);
103   slice->add\_parent\_layer(input);
104   slice->add\_child\_layer(split);
105   split->add\_parent\_layer(slice);
106 
107   \textcolor{comment}{// Input layer and slice layer are not unrolled any further}
108   prev\_step\_layer[input] = input;
109   prev\_step\_layer[slice] = slice;
110   next\_step\_layer[input] = input;
111   next\_step\_layer[slice] = slice;
112 
113 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a8c76387c2dd531058700ad9a41cd093a_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_a8c76387c2dd531058700ad9a41cd093a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_af04adecd9a62fdcd16ae78b3e95d4bb5}\label{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_af04adecd9a62fdcd16ae78b3e95d4bb5}} 
\index{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}@{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}}!unroll\+\_\+target\+\_\+layer@{unroll\+\_\+target\+\_\+layer}}
\index{unroll\+\_\+target\+\_\+layer@{unroll\+\_\+target\+\_\+layer}!lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}@{lbann\+::anonymous\+\_\+namespace\lcurly{}recurrent.\+cpp\rcurly{}}}
\subsubsection{\texorpdfstring{unroll\+\_\+target\+\_\+layer()}{unroll\_target\_layer()}}
{\footnotesize\ttfamily void lbann\+::anonymous\+\_\+namespace\{recurrent.\+cpp\}\+::unroll\+\_\+target\+\_\+layer (\begin{DoxyParamCaption}\item[{int}]{unroll\+\_\+depth,  }\item[{std\+::vector$<$ \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{layers,  }\item[{std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{prev\+\_\+step\+\_\+layer,  }\item[{std\+::unordered\+\_\+map$<$ const \hyperlink{classlbann_1_1Layer}{Layer} $\ast$, \hyperlink{classlbann_1_1Layer}{Layer} $\ast$$>$ \&}]{next\+\_\+step\+\_\+layer }\end{DoxyParamCaption})}

Setup target layer to match unrolled network. The last layer is assumed to be a target layer. A concatenation layer is inserted before the target layer. 

Definition at line 119 of file recurrent.\+cpp.


\begin{DoxyCode}
122                                                                                  \{
123   std::stringstream err;
124 
125   \textcolor{comment}{// We expect last layer to be a target layer}
126   \textcolor{keyword}{auto}&& target = \textcolor{keyword}{dynamic\_cast<}generic\_target\_layer*\textcolor{keyword}{>}(layers.back());
127   \textcolor{keywordflow}{if} (target == \textcolor{keyword}{nullptr}) \{
128     err << \_\_FILE\_\_ << \textcolor{stringliteral}{" "} << \_\_LINE\_\_ << \textcolor{stringliteral}{" :: "}
129         << \textcolor{stringliteral}{"expected the last layer to be a target layer"};
130     \textcolor{keywordflow}{throw} lbann\_exception(err.str());
131   \}
132 
133   \textcolor{comment}{// Construct concatenation layer}
134   Layer* concat = \textcolor{keyword}{nullptr};
135   \textcolor{keyword}{auto}&& \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm} = target->get\_comm();
136   \textcolor{keywordflow}{switch} (target->get\_data\_layout()) \{
137   \textcolor{keywordflow}{case} \hyperlink{base_8hpp_a786677cbfb3f5677b4d84f3056eb08dba37d2a3465f7cbf4ab60f4e79944d0638}{data\_layout::DATA\_PARALLEL}:
138     concat = \textcolor{keyword}{new} concatenation\_layer<data\_layout::DATA\_PARALLEL>(\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}, 0, \textcolor{keyword}{nullptr});
139     \textcolor{keywordflow}{break};
140   \textcolor{keywordflow}{case} \hyperlink{base_8hpp_a786677cbfb3f5677b4d84f3056eb08dbac94d7b0e44ab8bdcdad694a673cdeae0}{data\_layout::MODEL\_PARALLEL}:
141     concat = \textcolor{keyword}{new} concatenation\_layer<data\_layout::MODEL\_PARALLEL>(\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}, 0, \textcolor{keyword}{nullptr});
142     \textcolor{keywordflow}{break};
143   \textcolor{keywordflow}{default}:
144     err << \_\_FILE\_\_ << \textcolor{stringliteral}{" "} << \_\_LINE\_\_ << \textcolor{stringliteral}{" :: "} << \textcolor{stringliteral}{"invalid data layout"};
145     \textcolor{keywordflow}{throw} lbann\_exception(err.str());
146   \}
147   concat->set\_name(target->get\_name() + \textcolor{stringliteral}{"\_concat"});
148   layers.insert(layers.end() - 1, concat);
149 
150   \textcolor{comment}{// Setup relationships between concatenation layer and parent layers}
151   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}&& parent : target->get\_parent\_layers()) \{
152     concat->add\_parent\_layer(parent);
153     \textcolor{keyword}{auto}& parent\_children = \textcolor{keyword}{const\_cast<}Layer*\textcolor{keyword}{>}(parent)->get\_child\_layers();
154     std::replace(parent\_children.begin(), parent\_children.end(),
155                  \textcolor{keyword}{static\_cast<}Layer*\textcolor{keyword}{>}(target), concat);
156   \}
157   target->clear\_parent\_layers();
158 
159   \textcolor{comment}{// Setup relationship between target layer and concatenation layer}
160   concat->add\_child\_layer(target);
161   target->add\_parent\_layer(concat);
162 
163   \textcolor{comment}{// Target layer and concatenation layer are not unrolled any further}
164   prev\_step\_layer[target] = target;
165   prev\_step\_layer[concat] = concat;
166   next\_step\_layer[target] = target;
167   next\_step\_layer[concat] = concat;
168 
169 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03_af04adecd9a62fdcd16ae78b3e95d4bb5_icgraph}
\end{center}
\end{figure}
