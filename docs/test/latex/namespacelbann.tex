\hypertarget{namespacelbann}{}\section{lbann Namespace Reference}
\label{namespacelbann}\index{lbann@{lbann}}


Open\+MP Diagnostic code from Edgar Leon at L\+L\+NL.  


\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespacelbann_1_1Al}{Al}
\item 
 \hyperlink{namespacelbann_1_1anonymous__namespace_02callback__ltfb_8cpp_03}{anonymous\+\_\+namespace\{callback\+\_\+ltfb.\+cpp\}}
\item 
 \hyperlink{namespacelbann_1_1anonymous__namespace_02recurrent_8cpp_03}{anonymous\+\_\+namespace\{recurrent.\+cpp\}}
\item 
 \hyperlink{namespacelbann_1_1cnpy__utils}{cnpy\+\_\+utils}
\item 
 \hyperlink{namespacelbann_1_1cudnn}{cudnn}
\item 
 \hyperlink{namespacelbann_1_1graph}{graph}
\item 
 \hyperlink{namespacelbann_1_1proto}{proto}
\item 
 \hyperlink{namespacelbann_1_1stack__trace}{stack\+\_\+trace}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classlbann_1_1activation__layer}{activation\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1adagrad}{adagrad}
\item 
class \hyperlink{classlbann_1_1adam}{adam}
\item 
class \hyperlink{classlbann_1_1ascii__reader}{ascii\+\_\+reader}
\item 
class \hyperlink{classlbann_1_1atan__layer}{atan\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1base__convolution__layer}{base\+\_\+convolution\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1batch__normalization}{batch\+\_\+normalization}
\item 
class \hyperlink{classlbann_1_1bent__identity__layer}{bent\+\_\+identity\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1bernoulli__layer}{bernoulli\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1binary__cross__entropy}{binary\+\_\+cross\+\_\+entropy}
\item 
class \hyperlink{classlbann_1_1boolean__accuracy__metric}{boolean\+\_\+accuracy\+\_\+metric}
\item 
class \hyperlink{classlbann_1_1boolean__false__negatives__metric}{boolean\+\_\+false\+\_\+negatives\+\_\+metric}
\item 
class \hyperlink{classlbann_1_1boolean__false__positives__metric}{boolean\+\_\+false\+\_\+positives\+\_\+metric}
\item 
class \hyperlink{classlbann_1_1categorical__accuracy__metric}{categorical\+\_\+accuracy\+\_\+metric}
\item 
class \hyperlink{classlbann_1_1cifar10__reader}{cifar10\+\_\+reader}
\item 
class \hyperlink{classlbann_1_1concatenation__layer}{concatenation\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1constant__initializer}{constant\+\_\+initializer}
\item 
class \hyperlink{classlbann_1_1constant__layer}{constant\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1convolution__layer}{convolution\+\_\+layer}
\begin{DoxyCompactList}\small\item\em Convolution layer. \end{DoxyCompactList}\item 
class \hyperlink{classlbann_1_1cross__entropy}{cross\+\_\+entropy}
\item 
class \hyperlink{classlbann_1_1cross__entropy__with__uncertainty}{cross\+\_\+entropy\+\_\+with\+\_\+uncertainty}
\item 
class \hyperlink{classlbann_1_1csv__reader}{csv\+\_\+reader}
\item 
class \hyperlink{classlbann_1_1CUtility}{C\+Utility}
\item 
class \hyperlink{classlbann_1_1data__buffer}{data\+\_\+buffer}
\item 
class \hyperlink{classlbann_1_1data__reader__jag}{data\+\_\+reader\+\_\+jag}
\item 
class \hyperlink{classlbann_1_1data__reader__merge__features}{data\+\_\+reader\+\_\+merge\+\_\+features}
\item 
class \hyperlink{classlbann_1_1data__reader__merge__samples}{data\+\_\+reader\+\_\+merge\+\_\+samples}
\item 
class \hyperlink{classlbann_1_1data__reader__mnist__siamese}{data\+\_\+reader\+\_\+mnist\+\_\+siamese}
\item 
class \hyperlink{classlbann_1_1data__reader__multi__images}{data\+\_\+reader\+\_\+multi\+\_\+images}
\item 
class \hyperlink{classlbann_1_1data__reader__nci}{data\+\_\+reader\+\_\+nci}
\item 
class \hyperlink{classlbann_1_1data__reader__synthetic}{data\+\_\+reader\+\_\+synthetic}
\item 
class \hyperlink{classlbann_1_1data__reader__triplet}{data\+\_\+reader\+\_\+triplet}
\item 
class \hyperlink{classlbann_1_1data__store__csv}{data\+\_\+store\+\_\+csv}
\item 
class \hyperlink{classlbann_1_1data__store__image}{data\+\_\+store\+\_\+image}
\item 
class \hyperlink{classlbann_1_1data__store__imagenet}{data\+\_\+store\+\_\+imagenet}
\item 
class \hyperlink{classlbann_1_1data__store__imagenet__patches}{data\+\_\+store\+\_\+imagenet\+\_\+patches}
\item 
class \hyperlink{classlbann_1_1data__store__merge__features}{data\+\_\+store\+\_\+merge\+\_\+features}
\item 
class \hyperlink{classlbann_1_1data__store__merge__samples}{data\+\_\+store\+\_\+merge\+\_\+samples}
\item 
class \hyperlink{classlbann_1_1data__store__multi__images}{data\+\_\+store\+\_\+multi\+\_\+images}
\item 
class \hyperlink{classlbann_1_1data__store__pilot2__molecular}{data\+\_\+store\+\_\+pilot2\+\_\+molecular}
\item 
class \hyperlink{classlbann_1_1data__store__triplet}{data\+\_\+store\+\_\+triplet}
\item 
class \hyperlink{classlbann_1_1DataGenerator}{Data\+Generator}
\item 
class \hyperlink{classlbann_1_1dataset}{dataset}
\item 
class \hyperlink{classlbann_1_1deconvolution__layer}{deconvolution\+\_\+layer}
\begin{DoxyCompactList}\small\item\em Deconvolution layer. \end{DoxyCompactList}\item 
class \hyperlink{classlbann_1_1directed__acyclic__graph__model}{directed\+\_\+acyclic\+\_\+graph\+\_\+model}
\item 
class \hyperlink{classlbann_1_1distributed__io__buffer}{distributed\+\_\+io\+\_\+buffer}
\item 
class \hyperlink{classlbann_1_1dropout}{dropout}
\item 
class \hyperlink{classlbann_1_1dummy__layer}{dummy\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1elu__layer}{elu\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1entrywise__activation__layer}{entrywise\+\_\+activation\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1evaluation__layer}{evaluation\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1exponential__layer}{exponential\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1fan__in__fan__out__initializer}{fan\+\_\+in\+\_\+fan\+\_\+out\+\_\+initializer}
\item 
class \hyperlink{classlbann_1_1fetch__data__functor}{fetch\+\_\+data\+\_\+functor}
\item 
class \hyperlink{classlbann_1_1fully__connected__layer}{fully\+\_\+connected\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1gaussian__layer}{gaussian\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1generic__compound__data__reader}{generic\+\_\+compound\+\_\+data\+\_\+reader}
\item 
class \hyperlink{classlbann_1_1generic__data__reader}{generic\+\_\+data\+\_\+reader}
\item 
class \hyperlink{classlbann_1_1generic__data__store}{generic\+\_\+data\+\_\+store}
\item 
class \hyperlink{classlbann_1_1generic__input__layer}{generic\+\_\+input\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1generic__io__buffer}{generic\+\_\+io\+\_\+buffer}
\item 
class \hyperlink{classlbann_1_1generic__target__layer}{generic\+\_\+target\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1geom__negloglike}{geom\+\_\+negloglike}
\item 
class \hyperlink{classlbann_1_1glorot__normal__initializer}{glorot\+\_\+normal\+\_\+initializer}
\item 
class \hyperlink{classlbann_1_1glorot__uniform__initializer}{glorot\+\_\+uniform\+\_\+initializer}
\item 
class \hyperlink{classlbann_1_1greedy__layerwise__autoencoder}{greedy\+\_\+layerwise\+\_\+autoencoder}
\item 
class \hyperlink{classlbann_1_1group__lasso__weight__regularization}{group\+\_\+lasso\+\_\+weight\+\_\+regularization}
\item 
class \hyperlink{classlbann_1_1hadamard__layer}{hadamard\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1he__normal__initializer}{he\+\_\+normal\+\_\+initializer}
\item 
class \hyperlink{classlbann_1_1he__uniform__initializer}{he\+\_\+uniform\+\_\+initializer}
\item 
class \hyperlink{classlbann_1_1hypergradient__adam}{hypergradient\+\_\+adam}
\item 
class \hyperlink{classlbann_1_1identity__layer}{identity\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1image__data__reader}{image\+\_\+data\+\_\+reader}
\item 
class \hyperlink{classlbann_1_1image__utils}{image\+\_\+utils}
\item 
class \hyperlink{classlbann_1_1imagenet__reader}{imagenet\+\_\+reader}
\item 
class \hyperlink{classlbann_1_1imagenet__reader__org}{imagenet\+\_\+reader\+\_\+org}
\item 
class \hyperlink{classlbann_1_1imagenet__reader__patches}{imagenet\+\_\+reader\+\_\+patches}
\item 
class \hyperlink{classlbann_1_1imagenet__reader__single}{imagenet\+\_\+reader\+\_\+single}
\item 
class \hyperlink{classlbann_1_1input__layer}{input\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1io__layer}{io\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1kl__divergence}{kl\+\_\+divergence}
\item 
class \hyperlink{classlbann_1_1l1__weight__regularization}{l1\+\_\+weight\+\_\+regularization}
\item 
class \hyperlink{classlbann_1_1l2__weight__regularization}{l2\+\_\+weight\+\_\+regularization}
\item 
class \hyperlink{classlbann_1_1Layer}{Layer}
\item 
class \hyperlink{classlbann_1_1layer__term}{layer\+\_\+term}
\item 
class \hyperlink{classlbann_1_1lbann__callback}{lbann\+\_\+callback}
\item 
class \hyperlink{classlbann_1_1lbann__callback__adaptive__learning__rate}{lbann\+\_\+callback\+\_\+adaptive\+\_\+learning\+\_\+rate}
\item 
class \hyperlink{classlbann_1_1lbann__callback__check__dataset}{lbann\+\_\+callback\+\_\+check\+\_\+dataset}
\item 
class \hyperlink{classlbann_1_1lbann__callback__check__init}{lbann\+\_\+callback\+\_\+check\+\_\+init}
\item 
class \hyperlink{classlbann_1_1lbann__callback__check__reconstruction__error}{lbann\+\_\+callback\+\_\+check\+\_\+reconstruction\+\_\+error}
\item 
class \hyperlink{classlbann_1_1lbann__callback__checknan}{lbann\+\_\+callback\+\_\+checknan}
\item 
class \hyperlink{classlbann_1_1lbann__callback__checkpoint}{lbann\+\_\+callback\+\_\+checkpoint}
\item 
class \hyperlink{classlbann_1_1lbann__callback__checksmall}{lbann\+\_\+callback\+\_\+checksmall}
\item 
class \hyperlink{classlbann_1_1lbann__callback__debug}{lbann\+\_\+callback\+\_\+debug}
\item 
class \hyperlink{classlbann_1_1lbann__callback__debug__io}{lbann\+\_\+callback\+\_\+debug\+\_\+io}
\item 
class \hyperlink{classlbann_1_1lbann__callback__drop__fixed__learning__rate}{lbann\+\_\+callback\+\_\+drop\+\_\+fixed\+\_\+learning\+\_\+rate}
\item 
class \hyperlink{classlbann_1_1lbann__callback__dump__activations}{lbann\+\_\+callback\+\_\+dump\+\_\+activations}
\item 
class \hyperlink{classlbann_1_1lbann__callback__dump__gradients}{lbann\+\_\+callback\+\_\+dump\+\_\+gradients}
\item 
class \hyperlink{classlbann_1_1lbann__callback__dump__minibatch__sample__indices}{lbann\+\_\+callback\+\_\+dump\+\_\+minibatch\+\_\+sample\+\_\+indices}
\item 
class \hyperlink{classlbann_1_1lbann__callback__dump__weights}{lbann\+\_\+callback\+\_\+dump\+\_\+weights}
\item 
class \hyperlink{classlbann_1_1lbann__callback__early__stopping}{lbann\+\_\+callback\+\_\+early\+\_\+stopping}
\item 
class \hyperlink{classlbann_1_1lbann__callback__gradient__check}{lbann\+\_\+callback\+\_\+gradient\+\_\+check}
\item 
class \hyperlink{classlbann_1_1lbann__callback__hang}{lbann\+\_\+callback\+\_\+hang}
\item 
class \hyperlink{classlbann_1_1lbann__callback__imcomm}{lbann\+\_\+callback\+\_\+imcomm}
\item 
class \hyperlink{classlbann_1_1lbann__callback__io}{lbann\+\_\+callback\+\_\+io}
\item 
class \hyperlink{classlbann_1_1lbann__callback__learning__rate}{lbann\+\_\+callback\+\_\+learning\+\_\+rate}
\item 
class \hyperlink{classlbann_1_1lbann__callback__linear__growth__learning__rate}{lbann\+\_\+callback\+\_\+linear\+\_\+growth\+\_\+learning\+\_\+rate}
\item 
class \hyperlink{classlbann_1_1lbann__callback__ltfb}{lbann\+\_\+callback\+\_\+ltfb}
\item 
class \hyperlink{classlbann_1_1lbann__callback__minibatch__schedule}{lbann\+\_\+callback\+\_\+minibatch\+\_\+schedule}
\item 
class \hyperlink{classlbann_1_1lbann__callback__optimizerwise__adaptive__learning__rate}{lbann\+\_\+callback\+\_\+optimizerwise\+\_\+adaptive\+\_\+learning\+\_\+rate}
\item 
class \hyperlink{classlbann_1_1lbann__callback__poly__learning__rate}{lbann\+\_\+callback\+\_\+poly\+\_\+learning\+\_\+rate}
\item 
class \hyperlink{classlbann_1_1lbann__callback__print}{lbann\+\_\+callback\+\_\+print}
\item 
class \hyperlink{classlbann_1_1lbann__callback__profiler}{lbann\+\_\+callback\+\_\+profiler}
\item 
class \hyperlink{classlbann_1_1lbann__callback__save__images}{lbann\+\_\+callback\+\_\+save\+\_\+images}
\item 
class \hyperlink{classlbann_1_1lbann__callback__save__model}{lbann\+\_\+callback\+\_\+save\+\_\+model}
\item 
class \hyperlink{classlbann_1_1lbann__callback__step__learning__rate}{lbann\+\_\+callback\+\_\+step\+\_\+learning\+\_\+rate}
\item 
class \hyperlink{classlbann_1_1lbann__callback__step__minibatch}{lbann\+\_\+callback\+\_\+step\+\_\+minibatch}
\item 
class \hyperlink{classlbann_1_1lbann__callback__summary}{lbann\+\_\+callback\+\_\+summary}
\item 
class \hyperlink{classlbann_1_1lbann__callback__timeline}{lbann\+\_\+callback\+\_\+timeline}
\item 
class \hyperlink{classlbann_1_1lbann__callback__timer}{lbann\+\_\+callback\+\_\+timer}
\item 
class \hyperlink{classlbann_1_1lbann__callback__variable__minibatch}{lbann\+\_\+callback\+\_\+variable\+\_\+minibatch}
\item 
class \hyperlink{classlbann_1_1lbann__comm}{lbann\+\_\+comm}
\item 
class \hyperlink{classlbann_1_1lbann__exception}{lbann\+\_\+exception}
\item 
class \hyperlink{classlbann_1_1lbann__image__preprocessor}{lbann\+\_\+image\+\_\+preprocessor}
\item 
struct \hyperlink{structlbann_1_1lbann__model__header}{lbann\+\_\+model\+\_\+header}
\item 
struct \hyperlink{structlbann_1_1lbann__model__sequential__header}{lbann\+\_\+model\+\_\+sequential\+\_\+header}
\item 
class \hyperlink{classlbann_1_1lbann__quantizer}{lbann\+\_\+quantizer}
\item 
class \hyperlink{classlbann_1_1lbann__summary}{lbann\+\_\+summary}
\item 
class \hyperlink{classlbann_1_1leaky__relu__layer}{leaky\+\_\+relu\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1learning__layer}{learning\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1local__response__normalization__layer}{local\+\_\+response\+\_\+normalization\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1loss__function}{loss\+\_\+function}
\item 
class \hyperlink{classlbann_1_1mean__absolute__deviation__loss}{mean\+\_\+absolute\+\_\+deviation\+\_\+loss}
\item 
class \hyperlink{classlbann_1_1mean__absolute__deviation__metric}{mean\+\_\+absolute\+\_\+deviation\+\_\+metric}
\item 
class \hyperlink{classlbann_1_1mean__absolute__error__loss}{mean\+\_\+absolute\+\_\+error\+\_\+loss}
\item 
class \hyperlink{classlbann_1_1mean__squared__error__loss}{mean\+\_\+squared\+\_\+error\+\_\+loss}
\item 
class \hyperlink{classlbann_1_1mean__squared__error__metric}{mean\+\_\+squared\+\_\+error\+\_\+metric}
\item 
class \hyperlink{classlbann_1_1mesh__reader}{mesh\+\_\+reader}
\item 
class \hyperlink{classlbann_1_1metric}{metric}
\item 
struct \hyperlink{structlbann_1_1metric__statistics}{metric\+\_\+statistics}
\item 
class \hyperlink{classlbann_1_1mnist__reader}{mnist\+\_\+reader}
\item 
class \hyperlink{classlbann_1_1model}{model}
\item 
class \hyperlink{classlbann_1_1NetworkParams}{Network\+Params}
\begin{DoxyCompactList}\small\item\em Network parameters. \end{DoxyCompactList}\item 
class \hyperlink{classlbann_1_1normal__initializer}{normal\+\_\+initializer}
\item 
class \hyperlink{classlbann_1_1numpy__reader}{numpy\+\_\+reader}
\item 
class \hyperlink{classlbann_1_1objective__function}{objective\+\_\+function}
\item 
class \hyperlink{classlbann_1_1objective__function__term}{objective\+\_\+function\+\_\+term}
\item 
class \hyperlink{classlbann_1_1offline__patches__npz}{offline\+\_\+patches\+\_\+npz}
\item 
class \hyperlink{classlbann_1_1optimizer}{optimizer}
\item 
class \hyperlink{classlbann_1_1partitioned__io__buffer}{partitioned\+\_\+io\+\_\+buffer}
\item 
struct \hyperlink{structlbann_1_1path__delimiter}{path\+\_\+delimiter}
\item 
class \hyperlink{classlbann_1_1pearson__correlation__metric}{pearson\+\_\+correlation\+\_\+metric}
\item 
class \hyperlink{classlbann_1_1PerformanceParams}{Performance\+Params}
\begin{DoxyCompactList}\small\item\em Performance parameters. \end{DoxyCompactList}\item 
class \hyperlink{classlbann_1_1persist}{persist}
\item 
class \hyperlink{classlbann_1_1pilot2__molecular__reader}{pilot2\+\_\+molecular\+\_\+reader}
\item 
class \hyperlink{classlbann_1_1poisson__negloglike}{poisson\+\_\+negloglike}
\item 
class \hyperlink{classlbann_1_1polya__negloglike}{polya\+\_\+negloglike}
\item 
class \hyperlink{classlbann_1_1pooling__layer}{pooling\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1power__layer}{power\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1protobuf__utils}{protobuf\+\_\+utils}
\item 
struct \hyperlink{structlbann_1_1prototext__fn__triple}{prototext\+\_\+fn\+\_\+triple}
\item 
class \hyperlink{classlbann_1_1r2__metric}{r2\+\_\+metric}
\item 
class \hyperlink{classlbann_1_1reconstruction__layer}{reconstruction\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1recurrent__model}{recurrent\+\_\+model}
\item 
class \hyperlink{classlbann_1_1reduction__layer}{reduction\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1regularizer__layer}{regularizer\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1relu__layer}{relu\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1reshape__layer}{reshape\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1rmsprop}{rmsprop}
\item 
class \hyperlink{classlbann_1_1rng}{rng}
\item 
class \hyperlink{classlbann_1_1safe__inv__layer}{safe\+\_\+inv\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1selu__dropout}{selu\+\_\+dropout}
\item 
class \hyperlink{classlbann_1_1selu__layer}{selu\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1sequential__model}{sequential\+\_\+model}
\item 
class \hyperlink{classlbann_1_1sgd}{sgd}
\item 
class \hyperlink{classlbann_1_1siamese__model}{siamese\+\_\+model}
\item 
class \hyperlink{classlbann_1_1sigmoid__layer}{sigmoid\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1slice__layer}{slice\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1smooth__relu__layer}{smooth\+\_\+relu\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1softmax__layer}{softmax\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1softplus__layer}{softplus\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1split__layer}{split\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1stack__profiler}{stack\+\_\+profiler}
\item 
class \hyperlink{classlbann_1_1sum__layer}{sum\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1swish__layer}{swish\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1SystemParams}{System\+Params}
\begin{DoxyCompactList}\small\item\em System parameters. \end{DoxyCompactList}\item 
class \hyperlink{classlbann_1_1tanh__layer}{tanh\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1target__layer}{target\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1top__k__categorical__accuracy__metric}{top\+\_\+k\+\_\+categorical\+\_\+accuracy\+\_\+metric}
\item 
class \hyperlink{classlbann_1_1TrainingParams}{Training\+Params}
\item 
class \hyperlink{classlbann_1_1transform__layer}{transform\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1uniform__initializer}{uniform\+\_\+initializer}
\item 
class \hyperlink{classlbann_1_1uniform__layer}{uniform\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1unpooling__layer}{unpooling\+\_\+layer}
\item 
class \hyperlink{classlbann_1_1update__data__reader__functor}{update\+\_\+data\+\_\+reader\+\_\+functor}
\item 
class \hyperlink{classlbann_1_1weights}{weights}
\item 
class \hyperlink{classlbann_1_1weights__initializer}{weights\+\_\+initializer}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{namespacelbann_aab7fa584bac85b9085aa8b8c5a888356}{rng\+\_\+gen} = std\+::mt19937
\item 
using \hyperlink{namespacelbann_af16616ffa6a3616836eabadd6ce837ec}{fast\+\_\+rng\+\_\+gen} = std\+::minstd\+\_\+rand
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56}{persist\+\_\+type} \{ \hyperlink{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56a61b3a8faa9c1091806675c230a9abe64}{persist\+\_\+type\+::train}, 
\hyperlink{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56a20f35e630daf44dbfa4c3f68f5399d8c}{persist\+\_\+type\+::model}, 
\hyperlink{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56af9ab05454998236921a6b0e281fae632}{persist\+\_\+type\+::validate}
 \}
\item 
enum \hyperlink{namespacelbann_a3ce21fcce81d74fe54c2f4b5b5b48d9a}{device} \{ \hyperlink{namespacelbann_a3ce21fcce81d74fe54c2f4b5b5b48d9aa2b55387dd066c5bac646ac61543d152d}{device\+::\+C\+PU}, 
\hyperlink{namespacelbann_a3ce21fcce81d74fe54c2f4b5b5b48d9aaa33b7755e5f9b504d2d038eaca4ff28d}{device\+::\+C\+U\+DA}
 \}
\item 
enum \hyperlink{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9b}{reduction\+\_\+mode} \{ \hyperlink{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9baccc0377a8afbf50e7094f5c23a8af223}{reduction\+\_\+mode\+::\+I\+N\+V\+A\+L\+ID}, 
\hyperlink{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9ba6970bdc2201030b9c03fbdcf3973858a}{reduction\+\_\+mode\+::\+S\+UM}, 
\hyperlink{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9ba16de38737a9f8366e9b2042b4e9b6290}{reduction\+\_\+mode\+::\+A\+V\+E\+R\+A\+GE}
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classlbann_1_1lbann__comm}{lbann\+\_\+comm} $\ast$ \hyperlink{namespacelbann_a3d91b615e42bf5744deeed770879bc8c}{initialize} (int \&argc, char $\ast$$\ast$\&argv, int seed)
\item 
void \hyperlink{namespacelbann_a99724ee5a6647a1d8bff6764b9aa5fac}{finalize} (\hyperlink{classlbann_1_1lbann__comm}{lbann\+\_\+comm} $\ast$\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm})
\item 
static bool \hyperlink{namespacelbann_a35a39e949cfd1d7f8c15f94e4d44ecff}{write\+\_\+latest} (const char $\ast$dir, const char $\ast$name, int epoch, int train)
\item 
static bool \hyperlink{namespacelbann_abebab8298e56db6a455a9ed08ab42bb4}{read\+\_\+latest} (const char $\ast$dir, const char $\ast$name, int $\ast$epoch\+Last, int $\ast$train\+Last)
\begin{DoxyCompactList}\small\item\em Reads the \char`\"{}latest\char`\"{} file and returns the epoch number and sample offset for most recent checkpoint. \end{DoxyCompactList}\item 
std\+::string \hyperlink{namespacelbann_ab5665dc52c53faca0caa55b509e2e654}{get\+\_\+comm\+\_\+type\+\_\+name} (\hyperlink{classlbann_1_1lbann__callback__imcomm_acf7e894b3381e7f9b71020dc73594d6a}{lbann\+\_\+callback\+\_\+imcomm\+::comm\+\_\+type} m)
\item 
void \hyperlink{namespacelbann_a59f65281406da5bc57f49d8ec682be2d}{load\+\_\+mnist\+\_\+data} (const std\+::string imagepath, const std\+::string labelpath, const int m\+\_\+first\+\_\+n, std\+::vector$<$ std\+::vector$<$ unsigned char $>$ $>$ \&m\+\_\+image\+\_\+data)
\item 
{\footnotesize template$<$$>$ }\\void \hyperlink{namespacelbann_a32006e2c89920b1ff6e8a2318650dd7f}{Layer\+::instantiate\+\_\+matrices$<$ data\+\_\+layout\+::\+M\+O\+D\+E\+L\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L $>$} (const \hyperlink{base_8hpp_a9951bb1719d534e0401b1f06cad19eab}{El\+::\+Grid} \&grid)
\item 
{\footnotesize template$<$$>$ }\\void \hyperlink{namespacelbann_af3507a38f8992e27898d63551a987341}{Layer\+::instantiate\+\_\+matrices$<$ data\+\_\+layout\+::\+D\+A\+T\+A\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L $>$} (const \hyperlink{base_8hpp_a9951bb1719d534e0401b1f06cad19eab}{El\+::\+Grid} \&grid)
\item 
std\+::vector$<$ int $>$ \hyperlink{namespacelbann_af3f2c9055423e1fe3380b1ad4c4ab5ef}{get\+\_\+tokens} (std\+::string str, const std\+::vector$<$ char $>$ delims)
\begin{DoxyCompactList}\small\item\em Tokenize a string into integers by an ordered sequence of delimiter characters. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::string $>$ \hyperlink{namespacelbann_ac02a174553cf05f779743be1c92f1912}{get\+\_\+tokens} (const std\+::string str, const std\+::string delims=\char`\"{} \+:;\textbackslash{}\textbackslash{}\textbackslash{}\char`\"{})
\begin{DoxyCompactList}\small\item\em Tokenize a string into substrings by set of delimiter characters. \end{DoxyCompactList}\item 
bool \hyperlink{namespacelbann_a1ce6832a54235a5fb333f50fffbe1b63}{parse\+\_\+path} (const std\+::string \&path, std\+::string \&dir, std\+::string \&basename)
\begin{DoxyCompactList}\small\item\em Divide a given path into dir and basename. \end{DoxyCompactList}\item 
std\+::string \hyperlink{namespacelbann_ad9a28639b0953886bbcb7fc366783a17}{get\+\_\+ext\+\_\+name} (const std\+::string file\+\_\+name)
\begin{DoxyCompactList}\small\item\em Return file extention name. \end{DoxyCompactList}\item 
std\+::string \hyperlink{namespacelbann_aea9a4378326fd51236a8343c43cc4a7c}{get\+\_\+basename\+\_\+without\+\_\+ext} (const std\+::string file\+\_\+name)
\begin{DoxyCompactList}\small\item\em Return basename without extention. \end{DoxyCompactList}\item 
std\+::string \hyperlink{namespacelbann_a1b8b05bbf2e59808a51ead80c47a9359}{add\+\_\+delimiter} (const std\+::string dir)
\item 
std\+::string \hyperlink{namespacelbann_a351610c8df00514e8942756c2099fedc}{modify\+\_\+file\+\_\+name} (const std\+::string file\+\_\+name, const std\+::string tag, const std\+::string new\+\_\+ext)
\item 
bool \hyperlink{namespacelbann_a4fac6c6483965395fa79d31061485f9f}{check\+\_\+if\+\_\+file\+\_\+exists} (const std\+::string \&filename)
\begin{DoxyCompactList}\small\item\em Return true if a file with the given name exists. \end{DoxyCompactList}\item 
bool \hyperlink{namespacelbann_a3ee4a1fa7a82c30999de9eb626c68311}{check\+\_\+if\+\_\+dir\+\_\+exists} (const std\+::string \&dirname)
\item 
bool \hyperlink{namespacelbann_a1208673c880ccf0e1a9c5db6a8ed81f8}{create\+\_\+dir} (const std\+::string dirname)
\item 
void \hyperlink{namespacelbann_aa3636a1979e40da2af91f30a12b90db9}{im2col} (const \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&im, \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&col, int num\+\_\+channels, int im\+\_\+num\+\_\+dims, const int $\ast$im\+\_\+dims, const int $\ast$im\+\_\+pads, const int $\ast$window\+\_\+dims, const int $\ast$window\+\_\+strides)
\begin{DoxyCompactList}\small\item\em Rearrange image blocks into matrix columns. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_a0e1225f72580ffb5166181392b68b651}{col2im} (const \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&col, \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&im, int num\+\_\+channels, int im\+\_\+num\+\_\+dims, const int $\ast$im\+\_\+dims, const int $\ast$im\+\_\+pads, const int $\ast$window\+\_\+dims, const int $\ast$window\+\_\+strides)
\begin{DoxyCompactList}\small\item\em Rearrange matrix columns into image blocks. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_ab36806d08e7c852ad9cf3a0564f29b64}{col2im} (const \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&col, \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&im, int num\+\_\+channels, int im\+\_\+num\+\_\+dims, const int $\ast$im\+\_\+dims, const int $\ast$im\+\_\+pads, const int $\ast$window\+\_\+dims, const int $\ast$window\+\_\+strides, std\+::function$<$ Data\+Type(const Data\+Type \&, const Data\+Type \&)$>$ reduction\+\_\+op)
\begin{DoxyCompactList}\small\item\em Rearrange matrix columns into image blocks. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_a3d099edd7d1b09889e0d2133bb83d5bf}{im2col\+\_\+1x1} (const Data\+Type $\ast$input\+\_\+buffer, Data\+Type $\ast$output\+\_\+buffer, int num\+\_\+channels, int num\+\_\+input\+\_\+dims, const int $\ast$input\+\_\+dims)
\begin{DoxyCompactList}\small\item\em Rearrange 1x1 image blocks into matrix columns. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_adc05d10657be77ccd9a74b1621c416c3}{im2col\+\_\+2d} (const Data\+Type $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ input\+\_\+buffer, Data\+Type $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ output\+\_\+buffer, int input\+\_\+dim\+\_\+x, int input\+\_\+dim\+\_\+y, int input\+\_\+pad\+\_\+x, int input\+\_\+pad\+\_\+y, int num\+\_\+channels, int window\+\_\+dim\+\_\+x, int window\+\_\+dim\+\_\+y, int offset\+\_\+stride\+\_\+x, int offset\+\_\+stride\+\_\+y)
\begin{DoxyCompactList}\small\item\em Rearrange 2D image blocks into matrix columns. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_ab4fccda3dc4c2c293d643815dfefe22a}{col2im\+\_\+1x1} (const Data\+Type $\ast$input\+\_\+buffer, Data\+Type $\ast$output\+\_\+buffer, const int num\+\_\+channels, const int num\+\_\+output\+\_\+dims, const int $\ast$output\+\_\+dims)
\begin{DoxyCompactList}\small\item\em Rearrange matrix columns into 1x1 image blocks. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_a1953674a43b284f0abb5c5e4db94b2b9}{col2im\+\_\+2d} (const Data\+Type $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ input\+\_\+buffer, Data\+Type $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ output\+\_\+buffer, int output\+\_\+dim\+\_\+x, int output\+\_\+dim\+\_\+y, int output\+\_\+pad\+\_\+x, int output\+\_\+pad\+\_\+y, int num\+\_\+channels, int window\+\_\+dim\+\_\+x, int window\+\_\+dim\+\_\+y, int offset\+\_\+stride\+\_\+x, int offset\+\_\+stride\+\_\+y)
\begin{DoxyCompactList}\small\item\em Rearrange matrix columns into 2D image blocks. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_a26debfaa06e8490c7f258ed7923870c7}{display\+\_\+omp\+\_\+setup} ()
\item 
\hyperlink{namespacelbann_aab7fa584bac85b9085aa8b8c5a888356}{rng\+\_\+gen} \& \hyperlink{namespacelbann_a4fea7ba21017b49d1e34394b4c20c764}{get\+\_\+generator} ()
\item 
\hyperlink{namespacelbann_af16616ffa6a3616836eabadd6ce837ec}{fast\+\_\+rng\+\_\+gen} \& \hyperlink{namespacelbann_ae6ce9c2fdec6f81803f6b1a6555c31c5}{get\+\_\+fast\+\_\+generator} ()
\item 
\hyperlink{namespacelbann_aab7fa584bac85b9085aa8b8c5a888356}{rng\+\_\+gen} \& \hyperlink{namespacelbann_aba9d11cb3a739cd84e7234ceeb32d098}{get\+\_\+data\+\_\+seq\+\_\+generator} ()
\item 
bool \hyperlink{namespacelbann_af68acf5b249e5360289d4c6a7bfa8985}{save\+\_\+rng\+\_\+to\+\_\+checkpoint\+\_\+shared} (\hyperlink{classlbann_1_1persist}{persist} \&p)
\item 
bool \hyperlink{namespacelbann_ab76114a0e8cc90c28bcb9e7d01eec89a}{load\+\_\+rng\+\_\+from\+\_\+checkpoint\+\_\+shared} (\hyperlink{classlbann_1_1persist}{persist} \&p)
\item 
void \hyperlink{namespacelbann_acef152f20e422b3aea1a3c1691a533ac}{init\+\_\+random} (int seed, \hyperlink{classlbann_1_1lbann__comm}{lbann\+\_\+comm} $\ast$\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm})
\item 
void \hyperlink{namespacelbann_a8987701a637ff0e678114aa77e9c4d40}{init\+\_\+data\+\_\+seq\+\_\+random} (int seed)
\item 
void \hyperlink{namespacelbann_abd116f95f55d0e29d9a0cc386139c4b4}{gaussian\+\_\+fill} (\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&mat, El\+::\+Int m, El\+::\+Int n, Data\+Type mean, Data\+Type stddev)
\item 
void \hyperlink{namespacelbann_ae8bc674a3d676391666524b44cbc4068}{bernoulli\+\_\+fill} (\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&mat, El\+::\+Int m, El\+::\+Int n, double p)
\item 
void \hyperlink{namespacelbann_a7336c565aa23c1dab784530c581db3d1}{uniform\+\_\+fill} (\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&mat, El\+::\+Int m, El\+::\+Int n, Data\+Type center, Data\+Type radius)
\item 
void \hyperlink{namespacelbann_a2f40602f0503f9737325bb267e5c4dcc}{gaussian\+\_\+fill\+\_\+procdet} (\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&mat, El\+::\+Int m, El\+::\+Int n, Data\+Type mean, Data\+Type stddev)
\item 
void \hyperlink{namespacelbann_ad1e3fe84cfa5257be476de3be805064d}{bernoulli\+\_\+fill\+\_\+procdet} (\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&mat, El\+::\+Int m, El\+::\+Int n, double p)
\item 
void \hyperlink{namespacelbann_a93fc1b42be6ab461e803cb48d58c4d81}{uniform\+\_\+fill\+\_\+procdet} (\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&mat, El\+::\+Int m, El\+::\+Int n, Data\+Type center, Data\+Type radius)
\item 
bool \hyperlink{namespacelbann_aedcfce41af2eae595ce58b1180f66bd1}{count\+\_\+sorter} (const std\+::pair$<$ std\+::string, long $>$ \&a, const std\+::pair$<$ std\+::string, long $>$ \&b)
\item 
void \hyperlink{namespacelbann_a604ae9da0173b8be2bfb6877997d6d5c}{entrywise\+\_\+mean\+\_\+and\+\_\+stdev} (const \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&data, Data\+Type \&mean, Data\+Type \&stdev)
\begin{DoxyCompactList}\small\item\em Compute mean and standard deviation over matrix entries. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_a99fdd84cb5f060ac1c78ec66769669ba}{entrywise\+\_\+mean\+\_\+and\+\_\+stdev} (const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&data, Data\+Type \&mean, Data\+Type \&stdev)
\begin{DoxyCompactList}\small\item\em Compute mean and standard deviation over matrix entries. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_a213d429a27c3e8676a3ebec40c24005c}{columnwise\+\_\+mean\+\_\+and\+\_\+stdev} (const \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&data, \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&means, \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&stdevs)
\begin{DoxyCompactList}\small\item\em Compute column-\/wise means and standard deviations. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_ab043d2f2f9dea0ee861aff3a38216b24}{columnwise\+\_\+sums\+\_\+and\+\_\+sqsums} (const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&data, \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&sums, \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&sqsums)
\begin{DoxyCompactList}\small\item\em Compute column-\/wise sum and sqsum. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_a085b697db535c10a6fd6689cc4445bd4}{columnwise\+\_\+mean\+\_\+and\+\_\+stdev} (const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&data, \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&means, \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&stdevs)
\begin{DoxyCompactList}\small\item\em Compute column-\/wise means and standard deviations. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_a0c713b77f8e191addc1e0210037f9e5f}{rowwise\+\_\+mean\+\_\+and\+\_\+stdev} (const \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&data, \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&means, \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&stdevs)
\begin{DoxyCompactList}\small\item\em Compute row-\/wise means and standard deviations. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_a6b342b3e5b3fbb08b97b6d90aa68d121}{rowwise\+\_\+sums\+\_\+and\+\_\+sqsums} (const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&data, \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&sums, \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&sqsums)
\begin{DoxyCompactList}\small\item\em Compute row-\/wise sum and sum of squares. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_a9b1fd2f864f421aa0bd9f8582ad87c14}{rowwise\+\_\+mean\+\_\+and\+\_\+stdev} (const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&data, \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&means, \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&stdevs)
\begin{DoxyCompactList}\small\item\em Compute row-\/wise means and standard deviations. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_a47ac6e95c1670424f9867770fd5b9f60}{columnwise\+\_\+covariance} (const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&data1, const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&data2, const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&means1, const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&means2, \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&cov)
\begin{DoxyCompactList}\small\item\em Compute column-\/wise covariances. \end{DoxyCompactList}\item 
static bool \hyperlink{namespacelbann_a02f197bc772ef04f1ac51eb191a02cab}{ends\+With} (const std\+::string main\+Str, const std\+::string \&to\+Match)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{namespacelbann_a93facff1f3ce4e10e5d25cf80077fb93}{set\+\_\+minibatch\+\_\+item} (\hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&M, const int mb\+\_\+idx, const T $\ast$const ptr, const size\+\_\+t count)
\item 
int \hyperlink{namespacelbann_a8830dea8eef0ab5b93d68e2358ceeb1a}{makedir} (const char $\ast$dirname)
\item 
int \hyperlink{namespacelbann_aefae2a9fc9d742ece0fa8ca7ed9ee137}{exists} (const char $\ast$filename)
\item 
int \hyperlink{namespacelbann_a6084b9319eea1997f8446fa3e6879532}{openread} (const char $\ast$filename)
\item 
int \hyperlink{namespacelbann_a38dd30b2ae8214f6595708264369ddb8}{closeread} (int fd, const char $\ast$filename)
\item 
int \hyperlink{namespacelbann_af596e6d2be603e9cf808c98f5412490a}{openwrite} (const char $\ast$filename)
\item 
int \hyperlink{namespacelbann_aceeccedbbafccfa071b21ee99be794a5}{closewrite} (int fd, const char $\ast$filename)
\item 
bool \hyperlink{namespacelbann_af640a9302803636e0b5deb110c1aee57}{write\+Dist} (int fd, const char $\ast$filename, const \hyperlink{base_8hpp_a0fab5387556805cfeac3e7e567bf66c5}{Dist\+Mat} \&M, uint64\+\_\+t $\ast$bytes)
\begin{DoxyCompactList}\small\item\em Given an open file descriptor, file name, and a matrix, write the matrix to the file descriptor, return the number of bytes written. \end{DoxyCompactList}\item 
bool \hyperlink{namespacelbann_ab2c2ad3c98b9991a6307b123617dbfb2}{read\+Dist} (int fd, const char $\ast$filename, \hyperlink{base_8hpp_a0fab5387556805cfeac3e7e567bf66c5}{Dist\+Mat} \&M, uint64\+\_\+t $\ast$bytes)
\begin{DoxyCompactList}\small\item\em Given an open file descriptor, file name, and a matrix, read the matrix from the file descriptor, return the number of bytes read. \end{DoxyCompactList}\item 
bool \hyperlink{namespacelbann_aa7b4e710f444588dfcf4188b84b33420}{write\+\_\+distmat} (int fd, const char $\ast$name, \hyperlink{base_8hpp_a0fab5387556805cfeac3e7e567bf66c5}{Dist\+Mat} $\ast$M, uint64\+\_\+t $\ast$bytes)
\item 
bool \hyperlink{namespacelbann_a0306ed35d6d90cf4fbdce7a72ad62ca7}{read\+\_\+distmat} (int fd, const char $\ast$name, \hyperlink{base_8hpp_a0fab5387556805cfeac3e7e567bf66c5}{Dist\+Mat} $\ast$M, uint64\+\_\+t $\ast$bytes)
\item 
bool \hyperlink{namespacelbann_aed95061796f19fa1648dcc99dc335abd}{write\+\_\+bytes} (int fd, const char $\ast$name, const void $\ast$buf, size\+\_\+t size)
\item 
bool \hyperlink{namespacelbann_a85385e2a9e058b6720300b4cbdd2b1d0}{read\+\_\+bytes} (int fd, const char $\ast$name, void $\ast$buf, size\+\_\+t size)
\item 
bool \hyperlink{namespacelbann_a3a801c9f48655f81b886af4bff083f27}{write\+\_\+uint32} (int fd, const char $\ast$name, uint32\+\_\+t val)
\item 
bool \hyperlink{namespacelbann_aedcde4d93c4feb5090c927de1c45b90d}{read\+\_\+uint32} (int fd, const char $\ast$name, uint32\+\_\+t $\ast$val)
\item 
bool \hyperlink{namespacelbann_a234f8c7b9bbc2d9310d3e40314eb497c}{write\+\_\+uint64} (int fd, const char $\ast$name, uint64\+\_\+t val)
\item 
bool \hyperlink{namespacelbann_a7ca20ac4f0ec9feaa2f6d5b6ef3c8865}{read\+\_\+uint64} (int fd, const char $\ast$name, uint64\+\_\+t $\ast$val)
\item 
bool \hyperlink{namespacelbann_a917727ad7e4f0dfd6d5a609cdc6dd9e2}{write\+\_\+int32\+\_\+contig} (int fd, const char $\ast$name, const int32\+\_\+t $\ast$buf, uint64\+\_\+t count)
\item 
bool \hyperlink{namespacelbann_acb5b0f1b30c9ab2fba700bb953515810}{read\+\_\+int32\+\_\+contig} (int fd, const char $\ast$name, int32\+\_\+t $\ast$buf, uint64\+\_\+t count)
\item 
bool \hyperlink{namespacelbann_a73339e4587f8ce7f653be03a3a6cbcd0}{write\+\_\+float} (int fd, const char $\ast$name, float val)
\item 
bool \hyperlink{namespacelbann_acd0595f8c31773a3a46f477a83e4c0f3}{read\+\_\+float} (int fd, const char $\ast$name, float $\ast$val)
\item 
bool \hyperlink{namespacelbann_a827b050911630a21f248b128e3859044}{write\+\_\+double} (int fd, const char $\ast$name, double val)
\item 
bool \hyperlink{namespacelbann_a66f98f36cf54dca622f1186309961dd4}{read\+\_\+double} (int fd, const char $\ast$name, double $\ast$val)
\item 
bool \hyperlink{namespacelbann_add2807d7303bd96d2804f0b14e894c68}{write\+\_\+string} (int fd, const char $\ast$name, const char $\ast$buf, size\+\_\+t size)
\item 
bool \hyperlink{namespacelbann_a784843ebce0e596dba31c1d981a7f087}{read\+\_\+string} (int fd, const char $\ast$name, char $\ast$buf, size\+\_\+t size)
\item 
void \hyperlink{namespacelbann_aedccb3bf2d674ccb5573ab9960720731}{lbann\+\_\+report\+\_\+exception} (\hyperlink{classlbann_1_1lbann__exception}{lbann\+\_\+exception} \&e, \hyperlink{classlbann_1_1lbann__comm}{lbann\+\_\+comm} $\ast$\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}=nullptr, std\+::ostream \&os=std\+::cerr)
\item 
{\footnotesize template$<$typename T  = std\+::vector$<$unsigned char$>$$>$ }\\bool \hyperlink{namespacelbann_a9c2447a7dfde8f6fb73c5f12f20046f9}{load\+\_\+file} (const std\+::string filename, T \&buf)
\begin{DoxyCompactList}\small\item\em Load a file into a buffer. \end{DoxyCompactList}\item 
void \hyperlink{namespacelbann_a0fd8bc0ad31da913a124683f5ec4fdf1}{\+\_\+\+\_\+swap\+Endian\+Int} (unsigned int \&ui)
\item 
std\+::vector$<$ std\+::string $>$ \hyperlink{namespacelbann_a840c9f1d5f27bc30d081fb90529889e6}{glob} (const std\+::string \&pattern)
\item 
int \hyperlink{namespacelbann_abee17f56525b3894b0d3621a307faebd}{get\+\_\+num\+\_\+pus} ()
\item 
int \hyperlink{namespacelbann_a4b08fd1410911d1303176bafa031fcb4}{get\+\_\+affinity} (uint8\+\_\+t $\ast$cpus, uint8\+\_\+t $\ast$count)
\item 
void \hyperlink{namespacelbann_a31acedf53bb67180043939832c0220d3}{th\+\_\+print\+\_\+affinity} (int rank, int np, char $\ast$host)
\item 
void \hyperlink{namespacelbann_a4fd83a86cf27ca7bc1e01576a5ee36e0}{print\+\_\+affinity} (int rank, int np, char $\ast$host)
\item 
int \hyperlink{namespacelbann_aa4ee6571e54db5cee7f263029147e5f2}{get\+\_\+env\+\_\+var} (const char $\ast$id)
\item 
int \hyperlink{namespacelbann_a17d55032bad5bb02903f9b1d933836a4}{get\+\_\+sleep\+\_\+sec} ()
\item 
void \hyperlink{namespacelbann_acbd15ead7411cf84db559cc39a82f445}{print\+\_\+affinity\+\_\+subset} (int rank, int np, char $\ast$host)
\item 
{\footnotesize template$<$typename Generator , typename T $>$ }\\T \hyperlink{namespacelbann_a557aaed6267e7aaf583a75149e9c670c}{fast\+\_\+rand\+\_\+int} (Generator \&g, T max)
\item 
{\footnotesize template$<$typename Generator , typename T $>$ }\\T \hyperlink{namespacelbann_a2fe8cea17a147566b73260f557b51006}{fast\+\_\+rand\+\_\+int\+\_\+pow2} (Generator \&g, T max)
\item 
{\footnotesize template$<$typename D\+Type  = Data\+Type$>$ }\\void \hyperlink{namespacelbann_a481f0c268c74d3ec8b81861472559870}{rng\+\_\+bernoulli} (const float p, \hyperlink{base_8hpp_a0fab5387556805cfeac3e7e567bf66c5}{Dist\+Mat} $\ast$m)
\item 
double \hyperlink{namespacelbann_a478d36031ff0659893c4322cd856157f}{get\+\_\+time} ()
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static std\+::vector$<$ std\+::string $>$ \hyperlink{namespacelbann_add9e1dd52afa73f994d5d3a44c25a818}{comm\+\_\+type\+\_\+names}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Open\+MP Diagnostic code from Edgar Leon at L\+L\+NL. 

all methods in \hyperlink{classlbann_1_1protobuf__utils}{protobuf\+\_\+utils} are static 

\subsection{Typedef Documentation}
\mbox{\Hypertarget{namespacelbann_af16616ffa6a3616836eabadd6ce837ec}\label{namespacelbann_af16616ffa6a3616836eabadd6ce837ec}} 
\index{lbann@{lbann}!fast\+\_\+rng\+\_\+gen@{fast\+\_\+rng\+\_\+gen}}
\index{fast\+\_\+rng\+\_\+gen@{fast\+\_\+rng\+\_\+gen}!lbann@{lbann}}
\subsubsection{\texorpdfstring{fast\+\_\+rng\+\_\+gen}{fast\_rng\_gen}}
{\footnotesize\ttfamily using \hyperlink{namespacelbann_af16616ffa6a3616836eabadd6ce837ec}{lbann\+::fast\+\_\+rng\+\_\+gen} = typedef std\+::minstd\+\_\+rand}



Definition at line 38 of file random.\+hpp.

\mbox{\Hypertarget{namespacelbann_aab7fa584bac85b9085aa8b8c5a888356}\label{namespacelbann_aab7fa584bac85b9085aa8b8c5a888356}} 
\index{lbann@{lbann}!rng\+\_\+gen@{rng\+\_\+gen}}
\index{rng\+\_\+gen@{rng\+\_\+gen}!lbann@{lbann}}
\subsubsection{\texorpdfstring{rng\+\_\+gen}{rng\_gen}}
{\footnotesize\ttfamily using \hyperlink{namespacelbann_aab7fa584bac85b9085aa8b8c5a888356}{lbann\+::rng\+\_\+gen} = typedef std\+::mt19937}



Definition at line 37 of file random.\+hpp.



\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{namespacelbann_a3ce21fcce81d74fe54c2f4b5b5b48d9a}\label{namespacelbann_a3ce21fcce81d74fe54c2f4b5b5b48d9a}} 
\index{lbann@{lbann}!device@{device}}
\index{device@{device}!lbann@{lbann}}
\subsubsection{\texorpdfstring{device}{device}}
{\footnotesize\ttfamily enum \hyperlink{namespacelbann_a3ce21fcce81d74fe54c2f4b5b5b48d9a}{lbann\+::device}\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{C\+PU@{C\+PU}!lbann@{lbann}}\index{lbann@{lbann}!C\+PU@{C\+PU}}}\mbox{\Hypertarget{namespacelbann_a3ce21fcce81d74fe54c2f4b5b5b48d9aa2b55387dd066c5bac646ac61543d152d}\label{namespacelbann_a3ce21fcce81d74fe54c2f4b5b5b48d9aa2b55387dd066c5bac646ac61543d152d}} 
C\+PU&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{C\+U\+DA@{C\+U\+DA}!lbann@{lbann}}\index{lbann@{lbann}!C\+U\+DA@{C\+U\+DA}}}\mbox{\Hypertarget{namespacelbann_a3ce21fcce81d74fe54c2f4b5b5b48d9aaa33b7755e5f9b504d2d038eaca4ff28d}\label{namespacelbann_a3ce21fcce81d74fe54c2f4b5b5b48d9aaa33b7755e5f9b504d2d038eaca4ff28d}} 
C\+U\+DA&\\
\hline

\end{DoxyEnumFields}


Definition at line 43 of file fully\+\_\+connected.\+hpp.


\begin{DoxyCode}
43 \{\hyperlink{namespacelbann_a3ce21fcce81d74fe54c2f4b5b5b48d9aa2b55387dd066c5bac646ac61543d152d}{CPU}, \hyperlink{namespacelbann_a3ce21fcce81d74fe54c2f4b5b5b48d9aaa33b7755e5f9b504d2d038eaca4ff28d}{CUDA}\};
\end{DoxyCode}
\mbox{\Hypertarget{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56}\label{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56}} 
\index{lbann@{lbann}!persist\+\_\+type@{persist\+\_\+type}}
\index{persist\+\_\+type@{persist\+\_\+type}!lbann@{lbann}}
\subsubsection{\texorpdfstring{persist\+\_\+type}{persist\_type}}
{\footnotesize\ttfamily enum \hyperlink{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56}{lbann\+::persist\+\_\+type}\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{train@{train}!lbann@{lbann}}\index{lbann@{lbann}!train@{train}}}\mbox{\Hypertarget{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56a61b3a8faa9c1091806675c230a9abe64}\label{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56a61b3a8faa9c1091806675c230a9abe64}} 
train&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{model@{model}!lbann@{lbann}}\index{lbann@{lbann}!model@{model}}}\mbox{\Hypertarget{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56a20f35e630daf44dbfa4c3f68f5399d8c}\label{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56a20f35e630daf44dbfa4c3f68f5399d8c}} 
model&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{validate@{validate}!lbann@{lbann}}\index{lbann@{lbann}!validate@{validate}}}\mbox{\Hypertarget{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56af9ab05454998236921a6b0e281fae632}\label{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56af9ab05454998236921a6b0e281fae632}} 
validate&\\
\hline

\end{DoxyEnumFields}


Definition at line 37 of file persist.\+hpp.


\begin{DoxyCode}
37                         \{
38   \hyperlink{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56a61b3a8faa9c1091806675c230a9abe64}{train}, \textcolor{comment}{// data should be saved in file with train data}
39   \hyperlink{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56a20f35e630daf44dbfa4c3f68f5399d8c}{model}, \textcolor{comment}{// data should be saved in file with model data}
40   \hyperlink{namespacelbann_adee41f31f15f3906cbdcce4a1417eb56af9ab05454998236921a6b0e281fae632}{validate}, 
41 \};
\end{DoxyCode}
\mbox{\Hypertarget{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9b}\label{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9b}} 
\index{lbann@{lbann}!reduction\+\_\+mode@{reduction\+\_\+mode}}
\index{reduction\+\_\+mode@{reduction\+\_\+mode}!lbann@{lbann}}
\subsubsection{\texorpdfstring{reduction\+\_\+mode}{reduction\_mode}}
{\footnotesize\ttfamily enum \hyperlink{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9b}{lbann\+::reduction\+\_\+mode}\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{I\+N\+V\+A\+L\+ID@{I\+N\+V\+A\+L\+ID}!lbann@{lbann}}\index{lbann@{lbann}!I\+N\+V\+A\+L\+ID@{I\+N\+V\+A\+L\+ID}}}\mbox{\Hypertarget{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9baccc0377a8afbf50e7094f5c23a8af223}\label{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9baccc0377a8afbf50e7094f5c23a8af223}} 
I\+N\+V\+A\+L\+ID&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{S\+UM@{S\+UM}!lbann@{lbann}}\index{lbann@{lbann}!S\+UM@{S\+UM}}}\mbox{\Hypertarget{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9ba6970bdc2201030b9c03fbdcf3973858a}\label{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9ba6970bdc2201030b9c03fbdcf3973858a}} 
S\+UM&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{A\+V\+E\+R\+A\+GE@{A\+V\+E\+R\+A\+GE}!lbann@{lbann}}\index{lbann@{lbann}!A\+V\+E\+R\+A\+GE@{A\+V\+E\+R\+A\+GE}}}\mbox{\Hypertarget{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9ba16de38737a9f8366e9b2042b4e9b6290}\label{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9ba16de38737a9f8366e9b2042b4e9b6290}} 
A\+V\+E\+R\+A\+GE&\\
\hline

\end{DoxyEnumFields}


Definition at line 35 of file reduction.\+hpp.


\begin{DoxyCode}
35 \{\hyperlink{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9baccc0377a8afbf50e7094f5c23a8af223}{INVALID}, \hyperlink{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9ba6970bdc2201030b9c03fbdcf3973858a}{SUM}, \hyperlink{namespacelbann_a5975e1fb530a267728bfb01dc5c1be9ba16de38737a9f8366e9b2042b4e9b6290}{AVERAGE}\};
\end{DoxyCode}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespacelbann_a0fd8bc0ad31da913a124683f5ec4fdf1}\label{namespacelbann_a0fd8bc0ad31da913a124683f5ec4fdf1}} 
\index{lbann@{lbann}!\+\_\+\+\_\+swap\+Endian\+Int@{\+\_\+\+\_\+swap\+Endian\+Int}}
\index{\+\_\+\+\_\+swap\+Endian\+Int@{\+\_\+\+\_\+swap\+Endian\+Int}!lbann@{lbann}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+swap\+Endian\+Int()}{\_\_swapEndianInt()}}
{\footnotesize\ttfamily void lbann\+::\+\_\+\+\_\+swap\+Endian\+Int (\begin{DoxyParamCaption}\item[{unsigned int \&}]{ui }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 90 of file file\+\_\+utils.\+hpp.


\begin{DoxyCode}
90                                               \{
91   ui = ((ui >> 24) | ((ui<<8) & 0x00FF0000) | ((ui>>8) & 0x0000FF00) | (ui << 24));
92 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a0fd8bc0ad31da913a124683f5ec4fdf1_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a1b8b05bbf2e59808a51ead80c47a9359}\label{namespacelbann_a1b8b05bbf2e59808a51ead80c47a9359}} 
\index{lbann@{lbann}!add\+\_\+delimiter@{add\+\_\+delimiter}}
\index{add\+\_\+delimiter@{add\+\_\+delimiter}!lbann@{lbann}}
\subsubsection{\texorpdfstring{add\+\_\+delimiter()}{add\_delimiter()}}
{\footnotesize\ttfamily std\+::string lbann\+::add\+\_\+delimiter (\begin{DoxyParamCaption}\item[{const std\+::string}]{dir }\end{DoxyParamCaption})}

This automatically attaches the directory deliminator at the end of the given directory as necessary. If \char`\"{}\char`\"{} is given, it will do nothing 

Definition at line 117 of file file\+\_\+utils.\+cpp.


\begin{DoxyCode}
117                                              \{
118   \textcolor{keywordflow}{if} (dir.empty()) \{
119     \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
120   \}
121   std::string new\_dir(dir);
122 
123   \textcolor{keywordflow}{if} (!path\_delimiter::check(new\_dir.back())) \{
124     new\_dir.append(path\_delimiter::preferred());
125   \}
126 
127   \textcolor{keywordflow}{return} new\_dir;
128 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=331pt]{namespacelbann_a1b8b05bbf2e59808a51ead80c47a9359_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a1b8b05bbf2e59808a51ead80c47a9359_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_ae8bc674a3d676391666524b44cbc4068}\label{namespacelbann_ae8bc674a3d676391666524b44cbc4068}} 
\index{lbann@{lbann}!bernoulli\+\_\+fill@{bernoulli\+\_\+fill}}
\index{bernoulli\+\_\+fill@{bernoulli\+\_\+fill}!lbann@{lbann}}
\subsubsection{\texorpdfstring{bernoulli\+\_\+fill()}{bernoulli\_fill()}}
{\footnotesize\ttfamily void lbann\+::bernoulli\+\_\+fill (\begin{DoxyParamCaption}\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{mat,  }\item[{El\+::\+Int}]{m,  }\item[{El\+::\+Int}]{n,  }\item[{double}]{p = {\ttfamily 0.5} }\end{DoxyParamCaption})}

Make mat into an m x n matrix where each entry is an indepenent Bernoulli random variable with parameter p. This makes the same guarantees as gaussian\+\_\+fill. 

Definition at line 175 of file random.\+cpp.


\begin{DoxyCode}
175                                                                  \{
176 \textcolor{preprocessor}{#ifdef LBANN\_PARALLEL\_RANDOM\_MATRICES}
177   El::Bernoulli(mat, m, n, p);
178 \textcolor{preprocessor}{#else}
179   \hyperlink{namespacelbann_ad1e3fe84cfa5257be476de3be805064d}{bernoulli\_fill\_procdet}(mat, m, n, p);
180 \textcolor{preprocessor}{#endif  // LBANN\_PARALLEL\_RANDOM\_MATRICES  }
181 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_ae8bc674a3d676391666524b44cbc4068_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_ae8bc674a3d676391666524b44cbc4068_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_ad1e3fe84cfa5257be476de3be805064d}\label{namespacelbann_ad1e3fe84cfa5257be476de3be805064d}} 
\index{lbann@{lbann}!bernoulli\+\_\+fill\+\_\+procdet@{bernoulli\+\_\+fill\+\_\+procdet}}
\index{bernoulli\+\_\+fill\+\_\+procdet@{bernoulli\+\_\+fill\+\_\+procdet}!lbann@{lbann}}
\subsubsection{\texorpdfstring{bernoulli\+\_\+fill\+\_\+procdet()}{bernoulli\_fill\_procdet()}}
{\footnotesize\ttfamily void lbann\+::bernoulli\+\_\+fill\+\_\+procdet (\begin{DoxyParamCaption}\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{mat,  }\item[{El\+::\+Int}]{m,  }\item[{El\+::\+Int}]{n,  }\item[{double}]{p = {\ttfamily 0.5} }\end{DoxyParamCaption})}

Make mat into an m x n matrix where each entry is an independent Bernoulli random variable with parameter p. This makes the same guarantees as gaussian\+\_\+fill\+\_\+procdet. 

Definition at line 208 of file random.\+cpp.


\begin{DoxyCode}
208                                                                          \{
209   El::Zeros(mat, m, n);
210   \textcolor{keywordflow}{if} (mat.Grid().Rank() == 0) \{
211     mat.Reserve(m * n);
212     \textcolor{keyword}{auto}& gen = \hyperlink{namespacelbann_a4fea7ba21017b49d1e34394b4c20c764}{get\_generator}();
213     std::bernoulli\_distribution dist(p);
214     \textcolor{keywordflow}{for} (El::Int col = 0; col < n; ++col) \{
215       \textcolor{keywordflow}{for} (El::Int row = 0; row < m; ++row) \{
216         mat.QueueUpdate(row, col, dist(gen) ? 1.0f : 0.0f);
217       \}
218     \}
219   \}
220   mat.ProcessQueues();
221 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=323pt]{namespacelbann_ad1e3fe84cfa5257be476de3be805064d_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_ad1e3fe84cfa5257be476de3be805064d_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a3ee4a1fa7a82c30999de9eb626c68311}\label{namespacelbann_a3ee4a1fa7a82c30999de9eb626c68311}} 
\index{lbann@{lbann}!check\+\_\+if\+\_\+dir\+\_\+exists@{check\+\_\+if\+\_\+dir\+\_\+exists}}
\index{check\+\_\+if\+\_\+dir\+\_\+exists@{check\+\_\+if\+\_\+dir\+\_\+exists}!lbann@{lbann}}
\subsubsection{\texorpdfstring{check\+\_\+if\+\_\+dir\+\_\+exists()}{check\_if\_dir\_exists()}}
{\footnotesize\ttfamily bool lbann\+::check\+\_\+if\+\_\+dir\+\_\+exists (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{dirname }\end{DoxyParamCaption})}



Definition at line 171 of file file\+\_\+utils.\+cpp.


\begin{DoxyCode}
171                                                    \{
172   \textcolor{keywordflow}{return} \hyperlink{namespacelbann_a4fac6c6483965395fa79d31061485f9f}{check\_if\_file\_exists}(dirname);
173 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=316pt]{namespacelbann_a3ee4a1fa7a82c30999de9eb626c68311_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a3ee4a1fa7a82c30999de9eb626c68311_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a4fac6c6483965395fa79d31061485f9f}\label{namespacelbann_a4fac6c6483965395fa79d31061485f9f}} 
\index{lbann@{lbann}!check\+\_\+if\+\_\+file\+\_\+exists@{check\+\_\+if\+\_\+file\+\_\+exists}}
\index{check\+\_\+if\+\_\+file\+\_\+exists@{check\+\_\+if\+\_\+file\+\_\+exists}!lbann@{lbann}}
\subsubsection{\texorpdfstring{check\+\_\+if\+\_\+file\+\_\+exists()}{check\_if\_file\_exists()}}
{\footnotesize\ttfamily bool lbann\+::check\+\_\+if\+\_\+file\+\_\+exists (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename }\end{DoxyParamCaption})}



Return true if a file with the given name exists. 



Definition at line 155 of file file\+\_\+utils.\+cpp.


\begin{DoxyCode}
155                                                      \{
156   std::ifstream ifile(filename);
157   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(ifile);
158 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=316pt]{namespacelbann_a4fac6c6483965395fa79d31061485f9f_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a4fac6c6483965395fa79d31061485f9f_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a38dd30b2ae8214f6595708264369ddb8}\label{namespacelbann_a38dd30b2ae8214f6595708264369ddb8}} 
\index{lbann@{lbann}!closeread@{closeread}}
\index{closeread@{closeread}!lbann@{lbann}}
\subsubsection{\texorpdfstring{closeread()}{closeread()}}
{\footnotesize\ttfamily int lbann\+::closeread (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Definition at line 106 of file file\+\_\+io.\+cpp.


\begin{DoxyCode}
106                                              \{
107   \textcolor{comment}{// close file}
108   \textcolor{keywordtype}{int} close\_rc = close(fd);
109   \textcolor{keywordflow}{if} (close\_rc == -1) \{
110     fprintf(stderr, \textcolor{stringliteral}{"ERROR: Failed to close file `%s' (%d: %s) @ %s:%d\(\backslash\)n"},
111             file, errno, strerror(errno), \_\_FILE\_\_, \_\_LINE\_\_
112            );
113     fflush(stderr);
114   \}
115 
116   \textcolor{keywordflow}{return} close\_rc;
117 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a38dd30b2ae8214f6595708264369ddb8_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_aceeccedbbafccfa071b21ee99be794a5}\label{namespacelbann_aceeccedbbafccfa071b21ee99be794a5}} 
\index{lbann@{lbann}!closewrite@{closewrite}}
\index{closewrite@{closewrite}!lbann@{lbann}}
\subsubsection{\texorpdfstring{closewrite()}{closewrite()}}
{\footnotesize\ttfamily int lbann\+::closewrite (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Definition at line 133 of file file\+\_\+io.\+cpp.


\begin{DoxyCode}
133                                               \{
134   \textcolor{comment}{// fsync file}
135   \textcolor{keywordtype}{int} fsync\_rc = fsync(fd);
136   \textcolor{keywordflow}{if} (fsync\_rc == -1) \{
137     fprintf(stderr, \textcolor{stringliteral}{"ERROR: Failed to fsync file `%s' (%d: %s) @ %s:%d\(\backslash\)n"},
138             file, errno, strerror(errno), \_\_FILE\_\_, \_\_LINE\_\_
139            );
140     fflush(stderr);
141   \}
142 
143   \textcolor{comment}{// close file}
144   \textcolor{keywordtype}{int} close\_rc = close(fd);
145   \textcolor{keywordflow}{if} (close\_rc == -1) \{
146     fprintf(stderr, \textcolor{stringliteral}{"ERROR: Failed to close file `%s' (%d: %s) @ %s:%d\(\backslash\)n"},
147             file, errno, strerror(errno), \_\_FILE\_\_, \_\_LINE\_\_
148            );
149     fflush(stderr);
150   \}
151 
152   \textcolor{keywordflow}{return} close\_rc;
153 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_aceeccedbbafccfa071b21ee99be794a5_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a0e1225f72580ffb5166181392b68b651}\label{namespacelbann_a0e1225f72580ffb5166181392b68b651}} 
\index{lbann@{lbann}!col2im@{col2im}}
\index{col2im@{col2im}!lbann@{lbann}}
\subsubsection{\texorpdfstring{col2im()}{col2im()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void lbann\+::col2im (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{col,  }\item[{\hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{im,  }\item[{int}]{num\+\_\+channels,  }\item[{int}]{im\+\_\+num\+\_\+dims,  }\item[{const int $\ast$}]{im\+\_\+dims,  }\item[{const int $\ast$}]{im\+\_\+pads,  }\item[{const int $\ast$}]{window\+\_\+dims,  }\item[{const int $\ast$}]{window\+\_\+strides }\end{DoxyParamCaption})}



Rearrange matrix columns into image blocks. 

This is approximately the inverse of im2col. The output tensor im is produced from the input matrix col by shifting a window across im. Each column of col is matched with the corresponding window position and corresponding entries are added to im. 
\begin{DoxyParams}{Parameters}
{\em col} & col matrix. Height should be equal to window size and width equal to number of window shifts. Data should be contiguous. \\
\hline
{\em im} & im tensor, represented as a column vector. \\
\hline
{\em num\+\_\+channels} & Number of channels in im tensor. \\
\hline
{\em im\+\_\+num\+\_\+dims} & Number of dimensions in im tensor. \\
\hline
{\em im\+\_\+dims} & im tensor dimensions. \\
\hline
{\em im\+\_\+pads} & Zero pads for im tensor. \\
\hline
{\em window\+\_\+dims} & Dimensions of window. \\
\hline
{\em window\+\_\+strides} & Window shift strides. \\
\hline
\end{DoxyParams}


Definition at line 155 of file im2col.\+cpp.


\begin{DoxyCode}
162                                         \{
163 
164   \textcolor{comment}{// Input and output parameters}
165   \textcolor{keyword}{const} DataType *\_\_restrict\_\_ col\_buffer = col.LockedBuffer();
166   DataType *\_\_restrict\_\_ im\_buffer = im.Buffer();
167 
168   \textcolor{comment}{// col2im parameters}
169   std::vector<int> offset\_start(im\_num\_dims);
170   std::vector<int> offset\_end(im\_num\_dims);
171   std::vector<int> offset\_stride(im\_num\_dims);
172   std::vector<int> offset\_num(im\_num\_dims);
173   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} d = 0; d < im\_num\_dims; ++d) \{
174     offset\_start[d] = -im\_pads[d];
175     offset\_end[d] = im\_dims[d] + im\_pads[d] - window\_dims[d] + 1;
176     offset\_stride[d] = window\_strides[d];
177     offset\_num[d] = (offset\_end[d] - offset\_start[d] + offset\_stride[d] - 1) / offset\_stride[d];
178   \}
179 
180 \textcolor{preprocessor}{  #ifdef LBANN\_DEBUG}
181   \textcolor{keyword}{const} \textcolor{keywordtype}{int} im\_size = im.Height();
182   \textcolor{keyword}{const} \textcolor{keywordtype}{int} col\_height = col.Height();
183   \textcolor{keyword}{const} \textcolor{keywordtype}{int} col\_width = col.Width();
184   \textcolor{comment}{// Check matrix dimensions}
185   \textcolor{keyword}{const} \textcolor{keywordtype}{int} expected\_im\_size = std::accumulate(im\_dims,
186                                                im\_dims + im\_num\_dims,
187                                                num\_channels,
188                                                std::multiplies<int>());
189   \textcolor{keyword}{const} \textcolor{keywordtype}{int} expected\_col\_height = std::accumulate(window\_dims,
190                                                   window\_dims + im\_num\_dims,
191                                                   num\_channels,
192                                                   std::multiplies<int>());
193   \textcolor{keyword}{const} \textcolor{keywordtype}{int} expected\_col\_width = std::accumulate(offset\_num.begin(),
194                                                  offset\_num.end(),
195                                                  1,
196                                                  std::multiplies<int>());
197   \textcolor{keywordflow}{if}(im\_size != expected\_im\_size || im.Width() != 1) \{
198     std::stringstream ss;
199     ss << \textcolor{stringliteral}{"im2col: im matrix has invalid dimensions "}
200        << \textcolor{stringliteral}{"(expected "} << expected\_im\_size << \textcolor{stringliteral}{" x "} << 1 << \textcolor{stringliteral}{", "}
201        << \textcolor{stringliteral}{"found "} << im\_size << \textcolor{stringliteral}{" x "} << im.Width() << \textcolor{stringliteral}{")"};
202     \textcolor{keywordflow}{throw} lbann\_exception(ss.str());
203   \}
204   \textcolor{keywordflow}{if}(col\_height != expected\_col\_height
205      || col\_width != expected\_col\_width) \{
206     std::stringstream ss;
207     ss << \textcolor{stringliteral}{"im2col: col matrix has invalid dimensions "}
208        << \textcolor{stringliteral}{"(expected "} << expected\_col\_height << \textcolor{stringliteral}{" x "} << expected\_col\_width << \textcolor{stringliteral}{", "}
209        << \textcolor{stringliteral}{"found "} << col\_height << \textcolor{stringliteral}{" x "} << col\_width << \textcolor{stringliteral}{")"};
210     \textcolor{keywordflow}{throw} lbann\_exception(ss.str());
211   \}
212 \textcolor{preprocessor}{  #endif // LBANN\_DEBUG  }
213 
214   \textcolor{comment}{// Call optimized routine for 1x1 col2im}
215   std::vector<int> zeros(im\_num\_dims, 0), ones(im\_num\_dims, 1);
216   \textcolor{keywordflow}{if}(std::equal(im\_pads, im\_pads + im\_num\_dims, zeros.begin())
217      && std::equal(window\_dims, window\_dims + im\_num\_dims, ones.begin())
218      && std::equal(window\_strides, window\_strides + im\_num\_dims, ones.begin())) \{
219     \hyperlink{namespacelbann_ab4fccda3dc4c2c293d643815dfefe22a}{col2im\_1x1}(col\_buffer, im\_buffer, num\_channels, im\_num\_dims, im\_dims);
220     \textcolor{keywordflow}{return};
221   \}
222 
223   \textcolor{comment}{// Call optimized routine for 2D data}
224   \textcolor{keywordflow}{if}(im\_num\_dims == 2) \{
225     \hyperlink{namespacelbann_a1953674a43b284f0abb5c5e4db94b2b9}{col2im\_2d}(col\_buffer, im\_buffer,
226               im\_dims[1], im\_dims[0], im\_pads[1], im\_pads[0], num\_channels,
227               window\_dims[1], window\_dims[0],
228               window\_strides[1], window\_strides[0]);
229     \textcolor{keywordflow}{return};
230   \}
231 
232   \textcolor{comment}{// Default algorithm}
233   \hyperlink{namespacelbann_ab36806d08e7c852ad9cf3a0564f29b64}{col2im}(col, im, num\_channels, im\_num\_dims,
234          im\_dims, im\_pads, window\_dims, window\_strides,
235          std::plus<DataType>());
236 
237 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=288pt]{namespacelbann_a0e1225f72580ffb5166181392b68b651_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a0e1225f72580ffb5166181392b68b651_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_ab36806d08e7c852ad9cf3a0564f29b64}\label{namespacelbann_ab36806d08e7c852ad9cf3a0564f29b64}} 
\index{lbann@{lbann}!col2im@{col2im}}
\index{col2im@{col2im}!lbann@{lbann}}
\subsubsection{\texorpdfstring{col2im()}{col2im()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void lbann\+::col2im (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{col,  }\item[{\hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{im,  }\item[{int}]{num\+\_\+channels,  }\item[{int}]{im\+\_\+num\+\_\+dims,  }\item[{const int $\ast$}]{im\+\_\+dims,  }\item[{const int $\ast$}]{im\+\_\+pads,  }\item[{const int $\ast$}]{window\+\_\+dims,  }\item[{const int $\ast$}]{window\+\_\+strides,  }\item[{std\+::function$<$ Data\+Type(const Data\+Type \&, const Data\+Type \&)$>$}]{reduction\+\_\+op }\end{DoxyParamCaption})}



Rearrange matrix columns into image blocks. 

This is approximately the inverse of im2col. The output tensor im is produced from the input matrix col by shifting a window across im. Each column of col is matched with the corresponding window position and corresponding entries are reduced to im. 
\begin{DoxyParams}{Parameters}
{\em col} & col matrix. Height should be equal to window size and width equal to number of window shifts. Data should be contiguous. \\
\hline
{\em im} & im tensor, represented as a column vector. \\
\hline
{\em num\+\_\+channels} & Number of channels in im tensor. \\
\hline
{\em im\+\_\+num\+\_\+dims} & Number of dimensions in im tensor. \\
\hline
{\em im\+\_\+dims} & im tensor dimensions. \\
\hline
{\em im\+\_\+pads} & Zero pads for im tensor. \\
\hline
{\em window\+\_\+dims} & Dimensions of window. \\
\hline
{\em window\+\_\+strides} & Window shift strides. \\
\hline
{\em reduction\+\_\+op} & Reduction operation. \\
\hline
\end{DoxyParams}


Definition at line 239 of file im2col.\+cpp.


\begin{DoxyCode}
247                                                                                  \{
248 
249   \textcolor{comment}{// Input and output parameters}
250   \textcolor{keyword}{const} \textcolor{keywordtype}{int} col\_height = col.Height();
251   \textcolor{keyword}{const} \textcolor{keywordtype}{int} im\_size = im.Height();
252   \textcolor{keyword}{const} DataType *\_\_restrict\_\_ col\_buffer = col.LockedBuffer();
253   DataType *\_\_restrict\_\_ im\_buffer = im.Buffer();
254 
255   \textcolor{comment}{// im2col parameters}
256   std::vector<int> offset\_start(im\_num\_dims);
257   std::vector<int> offset\_end(im\_num\_dims);
258   std::vector<int> offset\_stride(im\_num\_dims);
259   std::vector<int> offset\_num(im\_num\_dims);
260   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} d = 0; d < im\_num\_dims; ++d) \{
261     offset\_start[d] = -im\_pads[d];
262     offset\_end[d] = im\_dims[d] + im\_pads[d] - window\_dims[d] + 1;
263     offset\_stride[d] = window\_strides[d];
264     offset\_num[d] = (offset\_end[d] - offset\_start[d] + offset\_stride[d] - 1) / offset\_stride[d];
265   \}
266 
267   \textcolor{comment}{// Call optimized routine for 1x1 col2im}
268   std::vector<int> zeros(im\_num\_dims, 0), ones(im\_num\_dims, 1);
269   \textcolor{keywordflow}{if}(std::equal(im\_pads, im\_pads + im\_num\_dims, zeros.begin())
270      && std::equal(window\_dims, window\_dims + im\_num\_dims, ones.begin())
271      && std::equal(window\_strides, window\_strides + im\_num\_dims, ones.begin())) \{
272     \hyperlink{namespacelbann_ab4fccda3dc4c2c293d643815dfefe22a}{col2im\_1x1}(col\_buffer, im\_buffer, num\_channels, im\_num\_dims, im\_dims);
273     \textcolor{keywordflow}{return};
274   \}
275 
276   \textcolor{comment}{// Iterate through im matrix entries}
277 \textcolor{preprocessor}{  #pragma omp parallel for}
278   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} im\_index = 0; im\_index < im\_size; ++im\_index) \{
279 
280     \textcolor{comment}{// Initialize arrays}
281     std::vector<int> im\_pos(im\_num\_dims);
282     std::vector<int> first\_offset(im\_num\_dims);
283     std::vector<int> last\_offset(im\_num\_dims);
284     std::vector<int> offset(im\_num\_dims);
285 
286     \textcolor{comment}{// Get position of im matrix entry}
287     \textcolor{keywordtype}{int} im\_index\_remainder = im\_index;
288     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} d = im\_num\_dims-1; d >= 0; --d) \{
289       im\_pos[d] = im\_index\_remainder % im\_dims[d];
290       im\_index\_remainder /= im\_dims[d];
291     \}
292     \textcolor{keyword}{const} \textcolor{keywordtype}{int} channel = im\_index\_remainder;
293 
294     \textcolor{comment}{// Initialize im matrix entry}
295     DataType im\_entry = 0;
296     \textcolor{keywordtype}{bool} im\_entry\_initialized = \textcolor{keyword}{false};
297     \textcolor{keywordtype}{bool} offsets\_finished = \textcolor{keyword}{false};
298 
299     \textcolor{comment}{// Get window offsets containing im matrix entry}
300     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} d = 0; d < im\_num\_dims; ++d) \{
301       first\_offset[d] = (im\_pos[d] - offset\_start[d] - window\_dims[d] + offset\_stride[d]) / offset\_stride[d
      ];
302       first\_offset[d] = std::max(first\_offset[d], 0);
303       last\_offset[d] = (im\_pos[d] - offset\_start[d]) / offset\_stride[d];
304       last\_offset[d] = std::min(last\_offset[d], offset\_num[d] - 1);
305       offset[d] = first\_offset[d];
306       \textcolor{keywordflow}{if}(first\_offset[d] > last\_offset[d]) \{
307         offsets\_finished = \textcolor{keyword}{true};
308       \}
309     \}
310 
311     \textcolor{comment}{// Iterate through window offsets containing im matrix entry}
312     \textcolor{keywordflow}{while}(!offsets\_finished) \{
313 
314       \textcolor{comment}{// Get col matrix entry corresponding to im matrix entry}
315       \textcolor{keywordtype}{int} col\_row = channel;
316       \textcolor{keywordtype}{int} col\_col = 0;
317       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} d = 0; d < im\_num\_dims; ++d) \{
318         \textcolor{keyword}{const} \textcolor{keywordtype}{int} window\_pos = im\_pos[d] - (offset\_start[d] + offset[d] * offset\_stride[d]);
319         col\_row = window\_pos + col\_row * window\_dims[d];
320         col\_col = offset[d] + col\_col * offset\_num[d];
321       \}
322       \textcolor{keyword}{const} \textcolor{keywordtype}{int} col\_index = col\_row + col\_col * col\_height;
323 
324       \textcolor{comment}{// Add col matrix entry to im matrix entry}
325       \textcolor{keyword}{const} DataType col\_entry = col\_buffer[col\_index];
326       im\_entry = (im\_entry\_initialized ?
327                   reduction\_op(im\_entry, col\_entry) :
328                   col\_entry);
329       im\_entry\_initialized = \textcolor{keyword}{true};
330 
331       \textcolor{comment}{// Move to next window offset}
332       ++offset[im\_num\_dims-1];
333       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} d = im\_num\_dims-1; d >= 1; --d) \{
334         \textcolor{keywordflow}{if}(offset[d] > last\_offset[d]) \{
335           offset[d] = first\_offset[d];
336           ++offset[d-1];
337         \}
338       \}
339       offsets\_finished = offset[0] > last\_offset[0];
340       
341     \}
342 
343     \textcolor{comment}{// Update output entry}
344     im\_buffer[im\_index] = im\_entry;
345 
346   \}
347 
348 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=288pt]{namespacelbann_ab36806d08e7c852ad9cf3a0564f29b64_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_ab4fccda3dc4c2c293d643815dfefe22a}\label{namespacelbann_ab4fccda3dc4c2c293d643815dfefe22a}} 
\index{lbann@{lbann}!col2im\+\_\+1x1@{col2im\+\_\+1x1}}
\index{col2im\+\_\+1x1@{col2im\+\_\+1x1}!lbann@{lbann}}
\subsubsection{\texorpdfstring{col2im\+\_\+1x1()}{col2im\_1x1()}}
{\footnotesize\ttfamily void lbann\+::col2im\+\_\+1x1 (\begin{DoxyParamCaption}\item[{const Data\+Type $\ast$}]{input\+\_\+buffer,  }\item[{Data\+Type $\ast$}]{output\+\_\+buffer,  }\item[{const int}]{num\+\_\+channels,  }\item[{const int}]{num\+\_\+output\+\_\+dims,  }\item[{const int $\ast$}]{output\+\_\+dims }\end{DoxyParamCaption})}



Rearrange matrix columns into 1x1 image blocks. 

This is an optimized implementation of col2im when the window has a size of one, there is no padding, and the window stride is one. col2im will automatically call this routine if it detects a 1x1 col2im. 

Definition at line 429 of file im2col.\+cpp.


\begin{DoxyCode}
433                                          \{
434   \textcolor{keyword}{const} \textcolor{keywordtype}{int} spatial\_size = std::accumulate(output\_dims,
435                                            output\_dims + num\_output\_dims,
436                                            1,
437                                            std::multiplies<int>());
438   \textcolor{keyword}{const} \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} input\_matrix(num\_channels, spatial\_size, input\_buffer, num\_channels);
439   \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} output\_matrix(spatial\_size, num\_channels, output\_buffer, spatial\_size);
440   El::Transpose(input\_matrix, output\_matrix);
441 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_ab4fccda3dc4c2c293d643815dfefe22a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a1953674a43b284f0abb5c5e4db94b2b9}\label{namespacelbann_a1953674a43b284f0abb5c5e4db94b2b9}} 
\index{lbann@{lbann}!col2im\+\_\+2d@{col2im\+\_\+2d}}
\index{col2im\+\_\+2d@{col2im\+\_\+2d}!lbann@{lbann}}
\subsubsection{\texorpdfstring{col2im\+\_\+2d()}{col2im\_2d()}}
{\footnotesize\ttfamily void lbann\+::col2im\+\_\+2d (\begin{DoxyParamCaption}\item[{const Data\+Type $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{input\+\_\+buffer,  }\item[{Data\+Type $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{output\+\_\+buffer,  }\item[{int}]{output\+\_\+dim\+\_\+x,  }\item[{int}]{output\+\_\+dim\+\_\+y,  }\item[{int}]{output\+\_\+pad\+\_\+x,  }\item[{int}]{output\+\_\+pad\+\_\+y,  }\item[{int}]{num\+\_\+channels,  }\item[{int}]{window\+\_\+dim\+\_\+x,  }\item[{int}]{window\+\_\+dim\+\_\+y,  }\item[{int}]{offset\+\_\+stride\+\_\+x,  }\item[{int}]{offset\+\_\+stride\+\_\+y }\end{DoxyParamCaption})}



Rearrange matrix columns into 2D image blocks. 

This is an optimized implementation of col2im for 2D data. col2im will automatically call this routine if it detects 2D data. 

Definition at line 443 of file im2col.\+cpp.


\begin{DoxyCode}
453                                           \{
454 
455   \textcolor{comment}{// col2im parameters}
456   \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_start\_x = -output\_pad\_x;
457   \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_start\_y = -output\_pad\_y;
458   \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_end\_x = output\_dim\_x + output\_pad\_x - window\_dim\_x + 1;
459   \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_end\_y = output\_dim\_y + output\_pad\_y - window\_dim\_y + 1;
460   \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_num\_x = (offset\_end\_x - offset\_start\_x + offset\_stride\_x - 1) / offset\_stride\_x;
461   \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_num\_y = (offset\_end\_y - offset\_start\_y + offset\_stride\_y - 1) / offset\_stride\_y;
462   \textcolor{keyword}{const} \textcolor{keywordtype}{int} input\_height = num\_channels * window\_dim\_x * window\_dim\_y;
463 
464   \textcolor{comment}{// Iterate through output entries}
465 \textcolor{preprocessor}{  #pragma omp parallel for collapse(3)}
466   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} channel = 0; channel < num\_channels; ++channel) \{
467     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} output\_pos\_y = 0;
468         output\_pos\_y < output\_dim\_y;
469         ++output\_pos\_y) \{
470       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} output\_pos\_x = 0;
471           output\_pos\_x < output\_dim\_x;
472           ++output\_pos\_x) \{
473 
474         \textcolor{comment}{// Get output entry}
475         \textcolor{keyword}{const} \textcolor{keywordtype}{int} output\_index = (output\_pos\_x
476                                   + output\_pos\_y * output\_dim\_x
477                                   + channel * output\_dim\_x * output\_dim\_y);
478         DataType output\_entry = 0;
479 
480         \textcolor{comment}{// Get window offsets containing output entry}
481         \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_x\_lower = (output\_pos\_x - offset\_start\_x - window\_dim\_x + offset\_stride\_x) / 
      offset\_stride\_x;
482         \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_y\_lower = (output\_pos\_y - offset\_start\_y - window\_dim\_y + offset\_stride\_y) / 
      offset\_stride\_y;
483         \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_x\_upper = (output\_pos\_x - offset\_start\_x) / offset\_stride\_x;
484         \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_y\_upper = (output\_pos\_y - offset\_start\_y) / offset\_stride\_y;
485         \textcolor{keyword}{const} \textcolor{keywordtype}{int} first\_offset\_x = std::max(offset\_x\_lower, 0);
486         \textcolor{keyword}{const} \textcolor{keywordtype}{int} first\_offset\_y = std::max(offset\_y\_lower, 0);
487         \textcolor{keyword}{const} \textcolor{keywordtype}{int} last\_offset\_x = std::min(offset\_x\_upper, offset\_num\_x - 1);
488         \textcolor{keyword}{const} \textcolor{keywordtype}{int} last\_offset\_y = std::min(offset\_y\_upper, offset\_num\_y - 1);
489 
490         \textcolor{comment}{// Iterate through window offsets}
491         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} offset\_y = first\_offset\_y;
492             offset\_y <= last\_offset\_y;
493             ++offset\_y) \{
494           \textcolor{keyword}{const} \textcolor{keywordtype}{int} window\_pos\_y = output\_pos\_y - (offset\_start\_y + offset\_y * offset\_stride\_y);
495           \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} offset\_x = first\_offset\_x;
496               offset\_x <= last\_offset\_x;
497               ++offset\_x) \{
498             \textcolor{keyword}{const} \textcolor{keywordtype}{int} window\_pos\_x = output\_pos\_x - (offset\_start\_x + offset\_x * offset\_stride\_x);
499 
500             \textcolor{comment}{// Get input entry}
501             \textcolor{keyword}{const} \textcolor{keywordtype}{int} input\_row = (window\_pos\_x
502                                    + window\_pos\_y * window\_dim\_x
503                                    + channel * window\_dim\_x * window\_dim\_y);
504             \textcolor{keyword}{const} \textcolor{keywordtype}{int} input\_col = offset\_x + offset\_y * offset\_num\_x;
505             \textcolor{keyword}{const} \textcolor{keywordtype}{int} input\_index = input\_row + input\_col * input\_height;
506 
507             \textcolor{comment}{// Add input entry to output entry}
508             output\_entry += input\_buffer[input\_index];
509 
510           \}
511         \}
512 
513         \textcolor{comment}{// Update output entry}
514         output\_buffer[output\_index] = output\_entry;
515 
516       \}
517     \}
518   \}
519 
520 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a1953674a43b284f0abb5c5e4db94b2b9_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a47ac6e95c1670424f9867770fd5b9f60}\label{namespacelbann_a47ac6e95c1670424f9867770fd5b9f60}} 
\index{lbann@{lbann}!columnwise\+\_\+covariance@{columnwise\+\_\+covariance}}
\index{columnwise\+\_\+covariance@{columnwise\+\_\+covariance}!lbann@{lbann}}
\subsubsection{\texorpdfstring{columnwise\+\_\+covariance()}{columnwise\_covariance()}}
{\footnotesize\ttfamily void lbann\+::columnwise\+\_\+covariance (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{data1,  }\item[{const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{data2,  }\item[{const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{means1,  }\item[{const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{means2,  }\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{cov }\end{DoxyParamCaption})}



Compute column-\/wise covariances. 


\begin{DoxyParams}{Parameters}
{\em data1} & Input matrix in U,V format. \\
\hline
{\em data2} & Input matrix in U,V format. \\
\hline
{\em means1} & Column-\/wise mean vector for data1 in S\+T\+AR,V format. \\
\hline
{\em means2} & Column-\/wise mean vector for data2 in S\+T\+AR,V format. \\
\hline
{\em cov} & Covariance vector in S\+T\+AR,V format. Output as a row vector with same number of columns as \textquotesingle{}data1\textquotesingle{}. \\
\hline
\end{DoxyParams}


Definition at line 365 of file statistics.\+cpp.


\begin{DoxyCode}
369                                              \{
370 
371   \textcolor{comment}{// Check matrix formats and dimensions are valid}
372   El::DistData data1\_dist(data1), data2\_dist(data2),
373     means1\_dist(means1), means2\_dist(means2), covs\_dist(covs);
374   \textcolor{keywordflow}{if}(data1\_dist != data2\_dist
375      || means1\_dist.colDist != El::STAR
376      || means1\_dist.rowDist != data1\_dist.rowDist
377      || means1\_dist != means2\_dist
378      || means1\_dist != covs\_dist) \{
379     \textcolor{keywordflow}{throw} lbann\_exception(\textcolor{stringliteral}{"columnwise\_covariance: invalid matrix format"});
380   \}
381   \textcolor{keywordflow}{if}(data1.Height() != data2.Height() || data1.Width() != data2.Width()) \{
382     \textcolor{keywordflow}{throw} lbann\_exception(\textcolor{stringliteral}{"columnwise\_covariance: data matrix dimensions don't match"});
383   \}
384 
385   \textcolor{comment}{// Matrix dimensions}
386   \textcolor{keyword}{const} El::Int height = data1.Height();
387   \textcolor{keyword}{const} El::Int width = data1.Width();
388   \textcolor{keyword}{const} El::Int local\_height = data1.LocalHeight();
389   \textcolor{keyword}{const} El::Int local\_width = data1.LocalWidth();
390 
391   \textcolor{comment}{// Initialize covariance}
392   covs.Resize(1, width);
393 
394   \textcolor{comment}{// Local matrices}
395   \textcolor{keyword}{const} \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_data1 = data1.LockedMatrix();
396   \textcolor{keyword}{const} \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_data2 = data2.LockedMatrix();
397   \textcolor{keyword}{const} \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_means1 = means1.LockedMatrix();
398   \textcolor{keyword}{const} \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_means2 = means2.LockedMatrix();
399   \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_covs = covs.Matrix();
400 
401   \textcolor{comment}{// Accumulate sum and divide to get covariance}
402 \textcolor{preprocessor}{  #pragma omp parallel for}
403   \textcolor{keywordflow}{for}(El::Int col = 0; col < local\_width; ++col) \{
404     DataType sum = 0;
405     \textcolor{keyword}{const} DataType mean1 = local\_means1(0, col);
406     \textcolor{keyword}{const} DataType mean2 = local\_means2(0, col);
407     \textcolor{keywordflow}{for}(El::Int row = 0; row < local\_height; ++row) \{
408       \textcolor{keyword}{const} DataType val1 = local\_data1(row, col);
409       \textcolor{keyword}{const} DataType val2 = local\_data2(row, col);
410       sum += (val1 - mean1) * (val2 - mean2);
411     \}
412     local\_covs(0, col) = sum;
413   \}
414   AllReduce(covs, covs.RedundantComm(), El::mpi::SUM);
415   local\_covs *= DataType(1) / height;
416 
417 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a47ac6e95c1670424f9867770fd5b9f60_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a213d429a27c3e8676a3ebec40c24005c}\label{namespacelbann_a213d429a27c3e8676a3ebec40c24005c}} 
\index{lbann@{lbann}!columnwise\+\_\+mean\+\_\+and\+\_\+stdev@{columnwise\+\_\+mean\+\_\+and\+\_\+stdev}}
\index{columnwise\+\_\+mean\+\_\+and\+\_\+stdev@{columnwise\+\_\+mean\+\_\+and\+\_\+stdev}!lbann@{lbann}}
\subsubsection{\texorpdfstring{columnwise\+\_\+mean\+\_\+and\+\_\+stdev()}{columnwise\_mean\_and\_stdev()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void lbann\+::columnwise\+\_\+mean\+\_\+and\+\_\+stdev (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{data,  }\item[{\hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{means,  }\item[{\hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{stdevs }\end{DoxyParamCaption})}



Compute column-\/wise means and standard deviations. 


\begin{DoxyParams}{Parameters}
{\em data} & Input matrix. \\
\hline
{\em means} & Mean vector. Output as a row vector with same number of columns as \textquotesingle{}data\textquotesingle{}. \\
\hline
{\em stdevs} & Standard deviation vector. Output as a row vector with same number of columns as \textquotesingle{}data\textquotesingle{}. \\
\hline
\end{DoxyParams}


Definition at line 100 of file statistics.\+cpp.


\begin{DoxyCode}
102                                             \{
103 
104   \textcolor{comment}{// Matrix dimensions}
105   \textcolor{keyword}{const} El::Int height = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.Height();
106   \textcolor{keyword}{const} El::Int width = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.Width();
107 
108   \textcolor{comment}{// Initialize outputs}
109   means.Resize(1, width);
110   stdevs.Resize(1, width);
111 
112   \textcolor{comment}{// Compute mean and standard deviation of each matrix column}
113 \textcolor{preprocessor}{  #pragma omp parallel for}
114   \textcolor{keywordflow}{for}(El::Int col = 0; col < width; ++col) \{
115     \textcolor{keyword}{const} DataType shift = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}(0, col);
116     DataType shifted\_sum = 0;
117     DataType shifted\_sqsum = 0;
118     \textcolor{keywordflow}{for}(El::Int row = 0; row < height; ++row) \{
119       \textcolor{keyword}{const} DataType shifted\_val = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}(row, col) - shift;
120       shifted\_sum += shifted\_val;
121       shifted\_sqsum += shifted\_val * shifted\_val;
122     \}
123     \textcolor{keyword}{const} DataType shifted\_mean = shifted\_sum / height;
124     \textcolor{keyword}{const} DataType shifted\_sqmean = shifted\_sqsum / height;
125     \textcolor{keyword}{const} DataType mean = shifted\_mean + shift;
126     \textcolor{keyword}{const} DataType var = std::max(shifted\_sqmean - shifted\_mean * shifted\_mean,
127                                   DataType(0));
128     \textcolor{keyword}{const} DataType stdev = std::sqrt(var);
129     means(0, col) = mean;
130     stdevs(0, col) = stdev;
131   \}
132 
133 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a213d429a27c3e8676a3ebec40c24005c_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a213d429a27c3e8676a3ebec40c24005c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a085b697db535c10a6fd6689cc4445bd4}\label{namespacelbann_a085b697db535c10a6fd6689cc4445bd4}} 
\index{lbann@{lbann}!columnwise\+\_\+mean\+\_\+and\+\_\+stdev@{columnwise\+\_\+mean\+\_\+and\+\_\+stdev}}
\index{columnwise\+\_\+mean\+\_\+and\+\_\+stdev@{columnwise\+\_\+mean\+\_\+and\+\_\+stdev}!lbann@{lbann}}
\subsubsection{\texorpdfstring{columnwise\+\_\+mean\+\_\+and\+\_\+stdev()}{columnwise\_mean\_and\_stdev()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void lbann\+::columnwise\+\_\+mean\+\_\+and\+\_\+stdev (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{data,  }\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{means,  }\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{stdevs }\end{DoxyParamCaption})}



Compute column-\/wise means and standard deviations. 

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000008}{Todo}]Numerically stable implementation \end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em data} & Input matrix in U,V format. \\
\hline
{\em means} & Mean vector in S\+T\+AR,V format. Output as a row vector with same number of columns as \textquotesingle{}data\textquotesingle{}. \\
\hline
{\em stdevs} & Standard deviation vector in S\+T\+AR,V format. Output as a row vector with same number of columns as \textquotesingle{}data\textquotesingle{}. \\
\hline
\end{DoxyParams}


Definition at line 184 of file statistics.\+cpp.


\begin{DoxyCode}
186                                                    \{
187 
188 \textcolor{preprocessor}{#ifdef LBANN\_DEBUG}
189   El::DistData data\_dist(\hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}), means\_dist(means), stdevs\_dist(stdevs);
190   \textcolor{keywordflow}{if}(means\_dist.colDist != El::STAR
191       || means\_dist.rowDist != data\_dist.rowDist
192       || stdevs\_dist.colDist != El::STAR
193       || stdevs\_dist.rowDist != data\_dist.rowDist) \{
194     \textcolor{keywordflow}{throw} lbann\_exception(\textcolor{stringliteral}{"columnwise\_mean\_and\_stdev: invalid matrix format"});
195   \}
196 \textcolor{preprocessor}{#endif // #ifdef LBANN\_DEBUG}
197 
198   \textcolor{comment}{// Matrix dimensions}
199   \textcolor{keyword}{const} El::Int height = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.Height();
200   \textcolor{keyword}{const} El::Int local\_width = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.LocalWidth();
201 
202   \hyperlink{namespacelbann_ab043d2f2f9dea0ee861aff3a38216b24}{columnwise\_sums\_and\_sqsums}(\hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}, means, stdevs);
203   \textcolor{comment}{// Local matrices}
204   \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_means = means.Matrix();
205   \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_stdevs = stdevs.Matrix();
206 
207   \textcolor{keywordflow}{for}(El::Int col = 0; col < local\_width; ++col) \{
208     \textcolor{keyword}{const} DataType mean = local\_means(0, col) / height;
209     \textcolor{keyword}{const} DataType sqmean = local\_stdevs(0, col) / height;
210     \textcolor{keyword}{const} DataType var = std::max(sqmean - mean * mean, DataType(0));
211     \textcolor{keyword}{const} DataType stdev = std::sqrt(var);
212     local\_means(0, col) = mean;
213     local\_stdevs(0, col) = stdev;
214   \}
215 
216 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a085b697db535c10a6fd6689cc4445bd4_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_ab043d2f2f9dea0ee861aff3a38216b24}\label{namespacelbann_ab043d2f2f9dea0ee861aff3a38216b24}} 
\index{lbann@{lbann}!columnwise\+\_\+sums\+\_\+and\+\_\+sqsums@{columnwise\+\_\+sums\+\_\+and\+\_\+sqsums}}
\index{columnwise\+\_\+sums\+\_\+and\+\_\+sqsums@{columnwise\+\_\+sums\+\_\+and\+\_\+sqsums}!lbann@{lbann}}
\subsubsection{\texorpdfstring{columnwise\+\_\+sums\+\_\+and\+\_\+sqsums()}{columnwise\_sums\_and\_sqsums()}}
{\footnotesize\ttfamily void lbann\+::columnwise\+\_\+sums\+\_\+and\+\_\+sqsums (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{data,  }\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{sums,  }\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{sqsums }\end{DoxyParamCaption})}



Compute column-\/wise sum and sqsum. 

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000007}{Todo}]Numerically stable implementation \end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em data} & Input matrix in U,V format. \\
\hline
{\em sum} & Sum vector in S\+T\+AR,V format. Output as a row vector with same number of columns as \textquotesingle{}data\textquotesingle{}. \\
\hline
{\em sqsum} & Sum of squared vector in S\+T\+AR,V format. Output as a row vector with same number of columns as \textquotesingle{}data\textquotesingle{}. \\
\hline
\end{DoxyParams}


Definition at line 136 of file statistics.\+cpp.


\begin{DoxyCode}
138                                                    \{
139 
140 \textcolor{preprocessor}{#ifdef LBANN\_DEBUG}
141   El::DistData data\_dist(\hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}), sum\_dist(sums), sqsum\_dist(sqsums);
142   \textcolor{keywordflow}{if}(sum\_dist.colDist != El::STAR
143       || sum\_dist.rowDist != data\_dist.rowDist
144       || sqsum\_dist.colDist != El::STAR
145       || sqsum\_dist.rowDist != data\_dist.rowDist) \{
146     \textcolor{keywordflow}{throw} lbann\_exception(\textcolor{stringliteral}{"columnwise\_sum\_and\_sqsum: invalid matrix format"});
147   \}
148 \textcolor{preprocessor}{#endif // #ifdef LBANN\_DEBUG}
149 
150   \textcolor{comment}{// Matrix dimensions}
151   \textcolor{keyword}{const} El::Int width = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.Width();
152   \textcolor{keyword}{const} El::Int local\_height = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.LocalHeight();
153   \textcolor{keyword}{const} El::Int local\_width = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.LocalWidth();
154 
155   \textcolor{comment}{// Initialize outputs}
156   sums.Resize(1, width);
157   sqsums.Resize(1, width);
158 
159   \textcolor{comment}{// Local matrices}
160   \textcolor{keyword}{const} \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_data = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.LockedMatrix();
161   \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_sum = sums.Matrix();
162   \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_sqsum = sqsums.Matrix();
163 
164   \textcolor{comment}{// Compute sum and sum of squares of each matrix column}
165 \textcolor{preprocessor}{  #pragma omp parallel for}
166   \textcolor{keywordflow}{for}(El::Int col = 0; col < local\_width; ++col) \{
167     DataType sum\_val = 0;
168     DataType sqsum\_val = 0;
169     \textcolor{keywordflow}{for}(El::Int row = 0; row < local\_height; ++row) \{
170       \textcolor{keyword}{const} DataType val = local\_data(row, col);
171       sum\_val += val;
172       sqsum\_val += val * val;
173     \}
174     local\_sum(0, col) = sum\_val;
175     local\_sqsum(0, col) = sqsum\_val;
176   \}
177 
178   \textcolor{comment}{// Allreduce sums and sums of squares}
179   AllReduce(sums, sums.RedundantComm(), El::mpi::SUM);
180   AllReduce(sqsums, sqsums.RedundantComm(), El::mpi::SUM);
181 
182 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_ab043d2f2f9dea0ee861aff3a38216b24_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_aedcfce41af2eae595ce58b1180f66bd1}\label{namespacelbann_aedcfce41af2eae595ce58b1180f66bd1}} 
\index{lbann@{lbann}!count\+\_\+sorter@{count\+\_\+sorter}}
\index{count\+\_\+sorter@{count\+\_\+sorter}!lbann@{lbann}}
\subsubsection{\texorpdfstring{count\+\_\+sorter()}{count\_sorter()}}
{\footnotesize\ttfamily bool lbann\+::count\+\_\+sorter (\begin{DoxyParamCaption}\item[{const std\+::pair$<$ std\+::string, long $>$ \&}]{a,  }\item[{const std\+::pair$<$ std\+::string, long $>$ \&}]{b }\end{DoxyParamCaption})}



Definition at line 103 of file stack\+\_\+profiler.\+cpp.


\begin{DoxyCode}
103                                                                                          \{
104   \textcolor{keywordflow}{return} a.second > b.second;
105 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_aedcfce41af2eae595ce58b1180f66bd1_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a1208673c880ccf0e1a9c5db6a8ed81f8}\label{namespacelbann_a1208673c880ccf0e1a9c5db6a8ed81f8}} 
\index{lbann@{lbann}!create\+\_\+dir@{create\+\_\+dir}}
\index{create\+\_\+dir@{create\+\_\+dir}!lbann@{lbann}}
\subsubsection{\texorpdfstring{create\+\_\+dir()}{create\_dir()}}
{\footnotesize\ttfamily bool lbann\+::create\+\_\+dir (\begin{DoxyParamCaption}\item[{const std\+::string}]{dirname }\end{DoxyParamCaption})}

Create a directory, and return true if successful. If a directory with the same name already exists, simply return true. 

Definition at line 182 of file file\+\_\+utils.\+cpp.


\begin{DoxyCode}
182                                          \{
183   std::string dir = dirname;
184   \textcolor{keywordflow}{if} (!dir.empty() && path\_delimiter::check(dir.back())) \{
185     dir.pop\_back();
186   \}
187 
188   \textcolor{keywordflow}{if} (dir.empty()) \{
189     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
190   \}
191 
192   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} file\_exists = \hyperlink{namespacelbann_a4fac6c6483965395fa79d31061485f9f}{check\_if\_file\_exists}(dir);
193 
194   \textcolor{keywordflow}{if} (file\_exists) \{
195     \textcolor{keywordflow}{if} (!\hyperlink{namespacelbann_a3ee4a1fa7a82c30999de9eb626c68311}{check\_if\_dir\_exists}(dir)) \{
196       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
197     \} \textcolor{keywordflow}{else} \{
198       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
199     \}
200   \}
201 
202   std::string cmd = std::string(\textcolor{stringliteral}{"mkdir -p "}) + dir;
203 \textcolor{preprocessor}{#if 1 // for ray}
204   \textcolor{keywordtype}{char} cmdstr[cmd.size()+1];
205   std::copy(cmd.begin(), cmd.end(), &cmdstr[0]);
206   cmdstr[cmd.size()] = \textcolor{charliteral}{'\(\backslash\)0'};
207   \textcolor{keyword}{const} \textcolor{keywordtype}{int} r = ::system(&cmdstr[0]);
208 \textcolor{preprocessor}{#else}
209   \textcolor{keyword}{const} \textcolor{keywordtype}{int} r = ::system(cmd.c\_str());
210 \textcolor{preprocessor}{#endif}
211 
212   \textcolor{keywordflow}{if} (WEXITSTATUS(r) == 0x10) \{
213     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
214   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!\hyperlink{namespacelbann_a3ee4a1fa7a82c30999de9eb626c68311}{check\_if\_dir\_exists}(dir)) \{
215     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
216   \}
217   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
218 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a1208673c880ccf0e1a9c5db6a8ed81f8_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=315pt]{namespacelbann_a1208673c880ccf0e1a9c5db6a8ed81f8_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a26debfaa06e8490c7f258ed7923870c7}\label{namespacelbann_a26debfaa06e8490c7f258ed7923870c7}} 
\index{lbann@{lbann}!display\+\_\+omp\+\_\+setup@{display\+\_\+omp\+\_\+setup}}
\index{display\+\_\+omp\+\_\+setup@{display\+\_\+omp\+\_\+setup}!lbann@{lbann}}
\subsubsection{\texorpdfstring{display\+\_\+omp\+\_\+setup()}{display\_omp\_setup()}}
{\footnotesize\ttfamily void lbann\+::display\+\_\+omp\+\_\+setup (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 198 of file omp\+\_\+diagnostics.\+cpp.


\begin{DoxyCode}
199 \{
200 \textcolor{preprocessor}{#ifdef LBANN\_GNU\_LINUX}
201   \textcolor{keywordtype}{int} rank, np, secs, len, mpi\_only, mpi\_subset;
202   \textcolor{keywordtype}{char} hostname[MPI\_MAX\_PROCESSOR\_NAME];
203   MPI\_Comm\_rank(MPI\_COMM\_WORLD, &rank);
204   MPI\_Comm\_size(MPI\_COMM\_WORLD, &np);
205   MPI\_Get\_processor\_name(hostname, &len);
206 
207   secs = \hyperlink{namespacelbann_a17d55032bad5bb02903f9b1d933836a4}{get\_sleep\_sec}();
208   (void) secs;
209   mpi\_only = \hyperlink{namespacelbann_aa4ee6571e54db5cee7f263029147e5f2}{get\_env\_var}(\textcolor{stringliteral}{"MPI\_ONLY"});
210   mpi\_subset = \hyperlink{namespacelbann_aa4ee6571e54db5cee7f263029147e5f2}{get\_env\_var}(\textcolor{stringliteral}{"MPI\_SUBSET"});
211 
212 
213 \textcolor{preprocessor}{  #ifdef HPM}
214     hpmInit(0, \textcolor{stringliteral}{"HPMTest"});
215     hpmStart(1, \textcolor{stringliteral}{"Region 1"});
216 \textcolor{preprocessor}{  #endif}
217 
218   \textcolor{keywordflow}{if} (rank == 0)
219     printf(\textcolor{stringliteral}{"\(\backslash\)n"});
220 
221   \textcolor{keywordflow}{if} (mpi\_only != 0) \{
222     \textcolor{keywordflow}{if} (mpi\_subset) \{
223       \hyperlink{namespacelbann_acbd15ead7411cf84db559cc39a82f445}{print\_affinity\_subset}(rank, np, hostname);
224     \}\textcolor{keywordflow}{else} \{
225       \hyperlink{namespacelbann_a4fd83a86cf27ca7bc1e01576a5ee36e0}{print\_affinity}(rank, np, hostname);
226     \}
227   \}\textcolor{keywordflow}{else} \{
228     \textcolor{comment}{/* Fork a team of threads giving them their own copies of variables */}
229 \textcolor{preprocessor}{#pragma omp parallel shared(rank, np, secs, hostname)}
230     \{
231       \hyperlink{namespacelbann_a31acedf53bb67180043939832c0220d3}{th\_print\_affinity}(rank, np, hostname);
232     \}  \textcolor{comment}{/* All threads join master thread and disband */}
233   \}
234 
235 \textcolor{preprocessor}{#ifdef HPM}
236   hpmStop(1);
237   hpmTerminate(0);
238 \textcolor{preprocessor}{#endif}
239 \textcolor{preprocessor}{#endif // LBANN\_GNU\_LINUX}
240 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=332pt]{namespacelbann_a26debfaa06e8490c7f258ed7923870c7_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a02f197bc772ef04f1ac51eb191a02cab}\label{namespacelbann_a02f197bc772ef04f1ac51eb191a02cab}} 
\index{lbann@{lbann}!ends\+With@{ends\+With}}
\index{ends\+With@{ends\+With}!lbann@{lbann}}
\subsubsection{\texorpdfstring{ends\+With()}{endsWith()}}
{\footnotesize\ttfamily static bool lbann\+::ends\+With (\begin{DoxyParamCaption}\item[{const std\+::string}]{main\+Str,  }\item[{const std\+::string \&}]{to\+Match }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 142 of file base.\+hpp.


\begin{DoxyCode}
143 \{
144   \textcolor{keywordflow}{if}(mainStr.size() >= toMatch.size() &&
145      mainStr.compare(mainStr.size() - toMatch.size(), toMatch.size(), toMatch) == 0)
146     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
147   \textcolor{keywordflow}{else}
148     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
149 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a02f197bc772ef04f1ac51eb191a02cab_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a604ae9da0173b8be2bfb6877997d6d5c}\label{namespacelbann_a604ae9da0173b8be2bfb6877997d6d5c}} 
\index{lbann@{lbann}!entrywise\+\_\+mean\+\_\+and\+\_\+stdev@{entrywise\+\_\+mean\+\_\+and\+\_\+stdev}}
\index{entrywise\+\_\+mean\+\_\+and\+\_\+stdev@{entrywise\+\_\+mean\+\_\+and\+\_\+stdev}!lbann@{lbann}}
\subsubsection{\texorpdfstring{entrywise\+\_\+mean\+\_\+and\+\_\+stdev()}{entrywise\_mean\_and\_stdev()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void lbann\+::entrywise\+\_\+mean\+\_\+and\+\_\+stdev (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{data,  }\item[{Data\+Type \&}]{mean,  }\item[{Data\+Type \&}]{stdev }\end{DoxyParamCaption})}



Compute mean and standard deviation over matrix entries. 


\begin{DoxyParams}{Parameters}
{\em data} & Input matrix. \\
\hline
{\em means} & Mean value (output). \\
\hline
{\em stdevs} & Standard deviation (output). \\
\hline
\end{DoxyParams}


Definition at line 32 of file statistics.\+cpp.


\begin{DoxyCode}
34                                                \{
35   \textcolor{comment}{// Note: This routine is primarily called in an OpenMP-parallelized}
36   \textcolor{comment}{// loop in data\_readers/image\_preprocessor.hpp. If a more}
37   \textcolor{comment}{// significant use-case is found, it may be worthwhile parallelizing}
38   \textcolor{comment}{// the loop.}
39 
40   \textcolor{comment}{// Matrix dimensions}
41   \textcolor{keyword}{const} El::Int height = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.Height();
42   \textcolor{keyword}{const} El::Int width = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.Width();
43   \textcolor{keyword}{const} El::Int \hyperlink{structc__hash__table_afd5bfd9640fc5b72f75457fb7dd89663}{size} = height * width;
44 
45   \textcolor{comment}{// Compute sums over matrix entries}
46   \textcolor{keyword}{const} DataType shift = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}(0, 0);
47   DataType shifted\_sum = 0;
48   DataType shifted\_sqsum = 0;
49   \textcolor{keywordflow}{for}(El::Int col = 0; col < width; ++col) \{
50     \textcolor{keywordflow}{for}(El::Int row = 0; row < height; ++row) \{
51       \textcolor{keyword}{const} DataType shifted\_val = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}(row, col) - shift;
52       shifted\_sum += shifted\_val;
53       shifted\_sqsum += shifted\_val * shifted\_val;
54     \}
55   \}
56 
57   \textcolor{comment}{// Compute mean and standard deviation}
58   \textcolor{keyword}{const} DataType shifted\_mean = shifted\_sum / \hyperlink{structc__hash__table_afd5bfd9640fc5b72f75457fb7dd89663}{size};
59   \textcolor{keyword}{const} DataType shifted\_sqmean = shifted\_sqsum / \hyperlink{structc__hash__table_afd5bfd9640fc5b72f75457fb7dd89663}{size};
60   mean = shifted\_mean + shift;
61   \textcolor{keyword}{const} DataType var = std::max(shifted\_sqmean - shifted\_mean * shifted\_mean,
62                                 DataType(0));
63   stdev = std::sqrt(var);
64 
65 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a604ae9da0173b8be2bfb6877997d6d5c_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a604ae9da0173b8be2bfb6877997d6d5c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a99fdd84cb5f060ac1c78ec66769669ba}\label{namespacelbann_a99fdd84cb5f060ac1c78ec66769669ba}} 
\index{lbann@{lbann}!entrywise\+\_\+mean\+\_\+and\+\_\+stdev@{entrywise\+\_\+mean\+\_\+and\+\_\+stdev}}
\index{entrywise\+\_\+mean\+\_\+and\+\_\+stdev@{entrywise\+\_\+mean\+\_\+and\+\_\+stdev}!lbann@{lbann}}
\subsubsection{\texorpdfstring{entrywise\+\_\+mean\+\_\+and\+\_\+stdev()}{entrywise\_mean\_and\_stdev()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void lbann\+::entrywise\+\_\+mean\+\_\+and\+\_\+stdev (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{data,  }\item[{Data\+Type \&}]{mean,  }\item[{Data\+Type \&}]{stdev }\end{DoxyParamCaption})}



Compute mean and standard deviation over matrix entries. 


\begin{DoxyParams}{Parameters}
{\em data} & Input matrix. \\
\hline
{\em means} & Mean value (output). \\
\hline
{\em stdevs} & Standard deviation (output). \\
\hline
\end{DoxyParams}


Definition at line 67 of file statistics.\+cpp.


\begin{DoxyCode}
69                                                \{
70 
71   \textcolor{comment}{// Matrix dimensions}
72   \textcolor{keyword}{const} El::Int \hyperlink{structc__hash__table_afd5bfd9640fc5b72f75457fb7dd89663}{size} = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.Height() * \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.Width();
73   \textcolor{keyword}{const} El::Int local\_height = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.LocalHeight();
74   \textcolor{keyword}{const} El::Int local\_width = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.LocalWidth();
75 
76   \textcolor{comment}{// Local matrices}
77   \textcolor{keyword}{const} \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_data = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.LockedMatrix();
78 
79   \textcolor{comment}{// Compute sums over matrix entries}
80   DataType sum = 0;
81   DataType sqsum = 0;
82 \textcolor{preprocessor}{  #pragma omp parallel for reduction(+:sum,sqsum) collapse(2)}
83   \textcolor{keywordflow}{for}(El::Int col = 0; col < local\_width; ++col) \{
84     \textcolor{keywordflow}{for}(El::Int row = 0; row < local\_height; ++row) \{
85       \textcolor{keyword}{const} DataType val = local\_data(row, col);
86       sum += val;
87       sqsum += val * val;
88     \}
89   \}
90   DataType sum\_sqsum[2] = \{sum, sqsum\};  \textcolor{comment}{// Pack to do one allreduce.}
91   El::mpi::AllReduce(sum\_sqsum, 2, \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.DistComm());
92 
93   \textcolor{comment}{// Compute mean and standard deviation}
94   mean = sum\_sqsum[0] / \hyperlink{structc__hash__table_afd5bfd9640fc5b72f75457fb7dd89663}{size};
95   \textcolor{keyword}{const} DataType var = std::max(sum\_sqsum[1] / size - mean * mean, DataType(0));
96   stdev = std::sqrt(var);
97 
98 \}
\end{DoxyCode}
\mbox{\Hypertarget{namespacelbann_aefae2a9fc9d742ece0fa8ca7ed9ee137}\label{namespacelbann_aefae2a9fc9d742ece0fa8ca7ed9ee137}} 
\index{lbann@{lbann}!exists@{exists}}
\index{exists@{exists}!lbann@{lbann}}
\subsubsection{\texorpdfstring{exists()}{exists()}}
{\footnotesize\ttfamily int lbann\+::exists (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Definition at line 79 of file file\+\_\+io.\+cpp.


\begin{DoxyCode}
79                                   \{
80   \textcolor{comment}{// get our rank}
81   \textcolor{keywordtype}{int} rank;
82   MPI\_Comm\_rank(\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}, &rank);
83 
84   \textcolor{comment}{// check whether file exists}
85   \textcolor{keyword}{struct }stat buffer;
86   \textcolor{keywordtype}{int} \hyperlink{namespacelbann_aefae2a9fc9d742ece0fa8ca7ed9ee137}{exists} = 0;
87   \textcolor{keywordflow}{if} (rank == 0) \{
88     \textcolor{comment}{// TODO: would be nice to use something lighter weight than stat here}
89     \textcolor{keywordflow}{if} (stat(file, &buffer) == 0) \{
90       exists = 1;
91     \}
92   \}
93   MPI\_Bcast(&exists, 1, MPI\_INT, 0, MPI\_COMM\_WORLD);
94 
95   \textcolor{keywordflow}{return} \hyperlink{namespacelbann_aefae2a9fc9d742ece0fa8ca7ed9ee137}{exists};
96 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_aefae2a9fc9d742ece0fa8ca7ed9ee137_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a557aaed6267e7aaf583a75149e9c670c}\label{namespacelbann_a557aaed6267e7aaf583a75149e9c670c}} 
\index{lbann@{lbann}!fast\+\_\+rand\+\_\+int@{fast\+\_\+rand\+\_\+int}}
\index{fast\+\_\+rand\+\_\+int@{fast\+\_\+rand\+\_\+int}!lbann@{lbann}}
\subsubsection{\texorpdfstring{fast\+\_\+rand\+\_\+int()}{fast\_rand\_int()}}
{\footnotesize\ttfamily template$<$typename Generator , typename T $>$ \\
T lbann\+::fast\+\_\+rand\+\_\+int (\begin{DoxyParamCaption}\item[{Generator \&}]{g,  }\item[{T}]{max }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Return random integers uniformly distributed in \mbox{[}0, max). 
\begin{DoxyParams}{Parameters}
{\em g} & C++ uniform random bit generator. \\
\hline
{\em max} & Upper bound on the distribution. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
It turns out that the G\+CC std\+::uniform\+\_\+int\+\_\+distribution is really slow. That implementation is used by most compilers. This implementation is roughly five times faster than that one. 
\end{DoxyNote}


Definition at line 68 of file random.\+hpp.


\begin{DoxyCode}
68                                             \{
69   \textcolor{keyword}{typename} Generator::result\_type x;
70   \textcolor{keywordflow}{do} \{
71     x = g();
72   \} \textcolor{keywordflow}{while} (x >= (Generator::max() - Generator::max() % \hyperlink{base_8hpp_ac47a6ee5278a53898222a48639a2bf39a2ffe4e77325d9a7152f7086ea7aa5114}{max}));
73   \textcolor{keywordflow}{return} x % \hyperlink{base_8hpp_ac47a6ee5278a53898222a48639a2bf39a2ffe4e77325d9a7152f7086ea7aa5114}{max};
74 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a557aaed6267e7aaf583a75149e9c670c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a2fe8cea17a147566b73260f557b51006}\label{namespacelbann_a2fe8cea17a147566b73260f557b51006}} 
\index{lbann@{lbann}!fast\+\_\+rand\+\_\+int\+\_\+pow2@{fast\+\_\+rand\+\_\+int\+\_\+pow2}}
\index{fast\+\_\+rand\+\_\+int\+\_\+pow2@{fast\+\_\+rand\+\_\+int\+\_\+pow2}!lbann@{lbann}}
\subsubsection{\texorpdfstring{fast\+\_\+rand\+\_\+int\+\_\+pow2()}{fast\_rand\_int\_pow2()}}
{\footnotesize\ttfamily template$<$typename Generator , typename T $>$ \\
T lbann\+::fast\+\_\+rand\+\_\+int\+\_\+pow2 (\begin{DoxyParamCaption}\item[{Generator \&}]{g,  }\item[{T}]{max }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Faster variant of fast\+\_\+rand\+\_\+int in the case that max is a power of 2. Do not call this if max is not a power of 2. 

Definition at line 81 of file random.\+hpp.


\begin{DoxyCode}
81                                                  \{
82   \textcolor{keyword}{typename} Generator::result\_type x;
83   \hyperlink{base_8hpp_ac47a6ee5278a53898222a48639a2bf39a2ffe4e77325d9a7152f7086ea7aa5114}{max} -= 1;
84   \textcolor{keyword}{const} \textcolor{keyword}{typename} Generator::result\_type upper = Generator::max() -
85       (Generator::max() & (\textcolor{keyword}{typename} Generator::result\_type) \hyperlink{base_8hpp_ac47a6ee5278a53898222a48639a2bf39a2ffe4e77325d9a7152f7086ea7aa5114}{max});
86   \textcolor{keywordflow}{do} \{
87     x = g();
88   \} \textcolor{keywordflow}{while} (x >= upper);
89   \textcolor{keywordflow}{return} x & ((\textcolor{keyword}{typename} Generator::result\_type) \hyperlink{base_8hpp_ac47a6ee5278a53898222a48639a2bf39a2ffe4e77325d9a7152f7086ea7aa5114}{max});
90 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a2fe8cea17a147566b73260f557b51006_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a2fe8cea17a147566b73260f557b51006_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a99724ee5a6647a1d8bff6764b9aa5fac}\label{namespacelbann_a99724ee5a6647a1d8bff6764b9aa5fac}} 
\index{lbann@{lbann}!finalize@{finalize}}
\index{finalize@{finalize}!lbann@{lbann}}
\subsubsection{\texorpdfstring{finalize()}{finalize()}}
{\footnotesize\ttfamily void lbann\+::finalize (\begin{DoxyParamCaption}\item[{\hyperlink{classlbann_1_1lbann__comm}{lbann\+\_\+comm} $\ast$}]{comm = {\ttfamily nullptr} }\end{DoxyParamCaption})}

Perform finalization. 

Definition at line 88 of file base.\+cpp.


\begin{DoxyCode}
88                                 \{
89   \textcolor{keywordflow}{if} (\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm} != \textcolor{keyword}{nullptr}) \{
90     \textcolor{keyword}{delete} \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm};
91   \}
92   El::Finalize();
93 \}
\end{DoxyCode}
\mbox{\Hypertarget{namespacelbann_abd116f95f55d0e29d9a0cc386139c4b4}\label{namespacelbann_abd116f95f55d0e29d9a0cc386139c4b4}} 
\index{lbann@{lbann}!gaussian\+\_\+fill@{gaussian\+\_\+fill}}
\index{gaussian\+\_\+fill@{gaussian\+\_\+fill}!lbann@{lbann}}
\subsubsection{\texorpdfstring{gaussian\+\_\+fill()}{gaussian\_fill()}}
{\footnotesize\ttfamily void lbann\+::gaussian\+\_\+fill (\begin{DoxyParamCaption}\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{mat,  }\item[{El\+::\+Int}]{m,  }\item[{El\+::\+Int}]{n,  }\item[{Data\+Type}]{mean = {\ttfamily 0.0f},  }\item[{Data\+Type}]{stddev = {\ttfamily 1.0f} }\end{DoxyParamCaption})}

Make mat into an m x n matrix where each entry is independently drawn from a Gaussian distribution with given mean and standard deviation. Unless selected so at compile-\/time, this ensures the entries of the matrix do not change as the grid it is distributed over changes; that is, it will have the same entries when mat spans any number of processes. 

Definition at line 166 of file random.\+cpp.


\begin{DoxyCode}
167                                     \{
168 \textcolor{preprocessor}{#ifdef LBANN\_PARALLEL\_RANDOM\_MATRICES}
169   El::Gaussian(mat, m, n, mean, stddev);
170 \textcolor{preprocessor}{#else}
171   \hyperlink{namespacelbann_a2f40602f0503f9737325bb267e5c4dcc}{gaussian\_fill\_procdet}(mat, m, n, mean, stddev);
172 \textcolor{preprocessor}{#endif  // LBANN\_PARALLEL\_RANDOM\_MATRICES}
173 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_abd116f95f55d0e29d9a0cc386139c4b4_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_abd116f95f55d0e29d9a0cc386139c4b4_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a2f40602f0503f9737325bb267e5c4dcc}\label{namespacelbann_a2f40602f0503f9737325bb267e5c4dcc}} 
\index{lbann@{lbann}!gaussian\+\_\+fill\+\_\+procdet@{gaussian\+\_\+fill\+\_\+procdet}}
\index{gaussian\+\_\+fill\+\_\+procdet@{gaussian\+\_\+fill\+\_\+procdet}!lbann@{lbann}}
\subsubsection{\texorpdfstring{gaussian\+\_\+fill\+\_\+procdet()}{gaussian\_fill\_procdet()}}
{\footnotesize\ttfamily void lbann\+::gaussian\+\_\+fill\+\_\+procdet (\begin{DoxyParamCaption}\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{mat,  }\item[{El\+::\+Int}]{m,  }\item[{El\+::\+Int}]{n,  }\item[{Data\+Type}]{mean = {\ttfamily 0.0f},  }\item[{Data\+Type}]{stddev = {\ttfamily 1.0f} }\end{DoxyParamCaption})}

Make mat into an m x n matrix where each entry is independently drawn from a Gaussian distribution with given mean and standard deviation. This always ensures that the entries of the matrix do not change as the grid it is distributed over changes. 

Definition at line 192 of file random.\+cpp.


\begin{DoxyCode}
193                                             \{
194   El::Zeros(mat, m, n);
195   \textcolor{keywordflow}{if} (mat.Grid().Rank() == 0) \{
196     mat.Reserve(n * m);
197     \textcolor{keyword}{auto}& gen = \hyperlink{namespacelbann_a4fea7ba21017b49d1e34394b4c20c764}{get\_generator}();
198     std::normal\_distribution<DataType> dist(mean, stddev);
199     \textcolor{keywordflow}{for} (El::Int col = 0; col < n; ++col) \{
200       \textcolor{keywordflow}{for} (El::Int row = 0; row < m; ++row) \{
201         mat.QueueUpdate(row, col, dist(gen));
202       \}
203     \}
204   \}
205   mat.ProcessQueues();
206 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=325pt]{namespacelbann_a2f40602f0503f9737325bb267e5c4dcc_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a2f40602f0503f9737325bb267e5c4dcc_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a4b08fd1410911d1303176bafa031fcb4}\label{namespacelbann_a4b08fd1410911d1303176bafa031fcb4}} 
\index{lbann@{lbann}!get\+\_\+affinity@{get\+\_\+affinity}}
\index{get\+\_\+affinity@{get\+\_\+affinity}!lbann@{lbann}}
\subsubsection{\texorpdfstring{get\+\_\+affinity()}{get\_affinity()}}
{\footnotesize\ttfamily int lbann\+::get\+\_\+affinity (\begin{DoxyParamCaption}\item[{uint8\+\_\+t $\ast$}]{cpus,  }\item[{uint8\+\_\+t $\ast$}]{count }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacelbann_aea9a4378326fd51236a8343c43cc4a7c}\label{namespacelbann_aea9a4378326fd51236a8343c43cc4a7c}} 
\index{lbann@{lbann}!get\+\_\+basename\+\_\+without\+\_\+ext@{get\+\_\+basename\+\_\+without\+\_\+ext}}
\index{get\+\_\+basename\+\_\+without\+\_\+ext@{get\+\_\+basename\+\_\+without\+\_\+ext}!lbann@{lbann}}
\subsubsection{\texorpdfstring{get\+\_\+basename\+\_\+without\+\_\+ext()}{get\_basename\_without\_ext()}}
{\footnotesize\ttfamily std\+::string lbann\+::get\+\_\+basename\+\_\+without\+\_\+ext (\begin{DoxyParamCaption}\item[{const std\+::string}]{file\+\_\+name }\end{DoxyParamCaption})}



Return basename without extention. 



Definition at line 99 of file file\+\_\+utils.\+cpp.


\begin{DoxyCode}
99                                                               \{
100   std::string dir;
101   std::string basename;
102   \hyperlink{namespacelbann_a1ce6832a54235a5fb333f50fffbe1b63}{parse\_path}(file\_name, dir, basename);
103 
104   \textcolor{keywordtype}{size\_t} pos = basename.find\_last\_of(\textcolor{charliteral}{'.'});
105   \textcolor{keywordflow}{if} (pos == 0u) \{
106     \textcolor{keywordflow}{return} basename;
107   \}
108   \textcolor{keywordflow}{return} basename.substr(0, pos);
109 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{namespacelbann_aea9a4378326fd51236a8343c43cc4a7c_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_aea9a4378326fd51236a8343c43cc4a7c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_ab5665dc52c53faca0caa55b509e2e654}\label{namespacelbann_ab5665dc52c53faca0caa55b509e2e654}} 
\index{lbann@{lbann}!get\+\_\+comm\+\_\+type\+\_\+name@{get\+\_\+comm\+\_\+type\+\_\+name}}
\index{get\+\_\+comm\+\_\+type\+\_\+name@{get\+\_\+comm\+\_\+type\+\_\+name}!lbann@{lbann}}
\subsubsection{\texorpdfstring{get\+\_\+comm\+\_\+type\+\_\+name()}{get\_comm\_type\_name()}}
{\footnotesize\ttfamily std\+::string lbann\+::get\+\_\+comm\+\_\+type\+\_\+name (\begin{DoxyParamCaption}\item[{\hyperlink{classlbann_1_1lbann__callback__imcomm_acf7e894b3381e7f9b71020dc73594d6a}{lbann\+\_\+callback\+\_\+imcomm\+::comm\+\_\+type}}]{m }\end{DoxyParamCaption})}

returns a string representation of the weight\+\_\+initialization 

Definition at line 270 of file callback\+\_\+imcomm.\+cpp.


\begin{DoxyCode}
270                                                                \{
271   \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{int})m < 0 or (\textcolor{keywordtype}{int})m >= (\textcolor{keywordtype}{int})\hyperlink{namespacelbann_add9e1dd52afa73f994d5d3a44c25a818}{comm\_type\_names}.size()) \{
272     \textcolor{keywordflow}{throw}(std::string\{\} + \_\_FILE\_\_ + \textcolor{stringliteral}{" "} + std::to\_string(\_\_LINE\_\_) + \textcolor{stringliteral}{" :: "}
273            + \textcolor{stringliteral}{" Invalid comm\_type"});
274   \}
275   \textcolor{keywordflow}{return} \hyperlink{namespacelbann_add9e1dd52afa73f994d5d3a44c25a818}{comm\_type\_names}[(int)m];
276 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_ab5665dc52c53faca0caa55b509e2e654_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_aba9d11cb3a739cd84e7234ceeb32d098}\label{namespacelbann_aba9d11cb3a739cd84e7234ceeb32d098}} 
\index{lbann@{lbann}!get\+\_\+data\+\_\+seq\+\_\+generator@{get\+\_\+data\+\_\+seq\+\_\+generator}}
\index{get\+\_\+data\+\_\+seq\+\_\+generator@{get\+\_\+data\+\_\+seq\+\_\+generator}!lbann@{lbann}}
\subsubsection{\texorpdfstring{get\+\_\+data\+\_\+seq\+\_\+generator()}{get\_data\_seq\_generator()}}
{\footnotesize\ttfamily \hyperlink{namespacelbann_aab7fa584bac85b9085aa8b8c5a888356}{rng\+\_\+gen} \& lbann\+::get\+\_\+data\+\_\+seq\+\_\+generator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Return a reference to the global L\+B\+A\+NN random number generator used for shuffling the data samples within each mini-\/bathc \begin{DoxyNote}{Note}
If compiling with Open\+MP, this is stored in a threadprivate variable. 
\end{DoxyNote}


Definition at line 68 of file random.\+cpp.


\begin{DoxyCode}
68                                   \{
69   \hyperlink{namespaceanonymous__namespace_02random_8cpp_03_ac1d3d0259f3e9c9b75e9701ae727d16e}{return ::data\_seq\_generator};
70 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_aba9d11cb3a739cd84e7234ceeb32d098_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_aa4ee6571e54db5cee7f263029147e5f2}\label{namespacelbann_aa4ee6571e54db5cee7f263029147e5f2}} 
\index{lbann@{lbann}!get\+\_\+env\+\_\+var@{get\+\_\+env\+\_\+var}}
\index{get\+\_\+env\+\_\+var@{get\+\_\+env\+\_\+var}!lbann@{lbann}}
\subsubsection{\texorpdfstring{get\+\_\+env\+\_\+var()}{get\_env\_var()}}
{\footnotesize\ttfamily int lbann\+::get\+\_\+env\+\_\+var (\begin{DoxyParamCaption}\item[{const char $\ast$}]{id }\end{DoxyParamCaption})}

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=319pt]{namespacelbann_aa4ee6571e54db5cee7f263029147e5f2_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_ad9a28639b0953886bbcb7fc366783a17}\label{namespacelbann_ad9a28639b0953886bbcb7fc366783a17}} 
\index{lbann@{lbann}!get\+\_\+ext\+\_\+name@{get\+\_\+ext\+\_\+name}}
\index{get\+\_\+ext\+\_\+name@{get\+\_\+ext\+\_\+name}!lbann@{lbann}}
\subsubsection{\texorpdfstring{get\+\_\+ext\+\_\+name()}{get\_ext\_name()}}
{\footnotesize\ttfamily std\+::string lbann\+::get\+\_\+ext\+\_\+name (\begin{DoxyParamCaption}\item[{const std\+::string}]{file\+\_\+name }\end{DoxyParamCaption})}



Return file extention name. 



Definition at line 85 of file file\+\_\+utils.\+cpp.


\begin{DoxyCode}
85                                                   \{
86   std::string dir;
87   std::string basename;
88   \hyperlink{namespacelbann_a1ce6832a54235a5fb333f50fffbe1b63}{parse\_path}(file\_name, dir, basename);
89 
90   \textcolor{keywordtype}{size\_t} pos = basename.find\_last\_of(\textcolor{charliteral}{'.'});
91   \textcolor{keywordflow}{if} (pos == 0u) \{
92     \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};  \textcolor{comment}{// hidden file}
93   \}
94   \textcolor{keywordflow}{return} basename.substr(pos+1, basename.size());
95 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=321pt]{namespacelbann_ad9a28639b0953886bbcb7fc366783a17_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_ad9a28639b0953886bbcb7fc366783a17_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_ae6ce9c2fdec6f81803f6b1a6555c31c5}\label{namespacelbann_ae6ce9c2fdec6f81803f6b1a6555c31c5}} 
\index{lbann@{lbann}!get\+\_\+fast\+\_\+generator@{get\+\_\+fast\+\_\+generator}}
\index{get\+\_\+fast\+\_\+generator@{get\+\_\+fast\+\_\+generator}!lbann@{lbann}}
\subsubsection{\texorpdfstring{get\+\_\+fast\+\_\+generator()}{get\_fast\_generator()}}
{\footnotesize\ttfamily \hyperlink{namespacelbann_af16616ffa6a3616836eabadd6ce837ec}{fast\+\_\+rng\+\_\+gen} \& lbann\+::get\+\_\+fast\+\_\+generator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Return a reference to a possibly-\/faster global L\+B\+A\+NN random number generator. Compared to get\+\_\+generator, this should be slightly faster. \begin{DoxyNote}{Note}
If compiling with Open\+MP, this is stored in a threadprivate variable. 
\end{DoxyNote}


Definition at line 64 of file random.\+cpp.


\begin{DoxyCode}
64                                    \{
65   \hyperlink{namespaceanonymous__namespace_02random_8cpp_03_a349f572cec05cd0e2469b799774a8602}{return ::fast\_generator};
66 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_ae6ce9c2fdec6f81803f6b1a6555c31c5_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a4fea7ba21017b49d1e34394b4c20c764}\label{namespacelbann_a4fea7ba21017b49d1e34394b4c20c764}} 
\index{lbann@{lbann}!get\+\_\+generator@{get\+\_\+generator}}
\index{get\+\_\+generator@{get\+\_\+generator}!lbann@{lbann}}
\subsubsection{\texorpdfstring{get\+\_\+generator()}{get\_generator()}}
{\footnotesize\ttfamily \hyperlink{namespacelbann_aab7fa584bac85b9085aa8b8c5a888356}{rng\+\_\+gen} \& lbann\+::get\+\_\+generator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Return a reference to the global L\+B\+A\+NN random number generator. \begin{DoxyNote}{Note}
If compiling with Open\+MP, this is stored in a threadprivate variable. 
\end{DoxyNote}


Definition at line 60 of file random.\+cpp.


\begin{DoxyCode}
60                          \{
61   \hyperlink{namespaceanonymous__namespace_02random_8cpp_03_a83826c4b587d1825f13b833be6fe047f}{return ::generator};
62 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a4fea7ba21017b49d1e34394b4c20c764_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_abee17f56525b3894b0d3621a307faebd}\label{namespacelbann_abee17f56525b3894b0d3621a307faebd}} 
\index{lbann@{lbann}!get\+\_\+num\+\_\+pus@{get\+\_\+num\+\_\+pus}}
\index{get\+\_\+num\+\_\+pus@{get\+\_\+num\+\_\+pus}!lbann@{lbann}}
\subsubsection{\texorpdfstring{get\+\_\+num\+\_\+pus()}{get\_num\_pus()}}
{\footnotesize\ttfamily int lbann\+::get\+\_\+num\+\_\+pus (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacelbann_a17d55032bad5bb02903f9b1d933836a4}\label{namespacelbann_a17d55032bad5bb02903f9b1d933836a4}} 
\index{lbann@{lbann}!get\+\_\+sleep\+\_\+sec@{get\+\_\+sleep\+\_\+sec}}
\index{get\+\_\+sleep\+\_\+sec@{get\+\_\+sleep\+\_\+sec}!lbann@{lbann}}
\subsubsection{\texorpdfstring{get\+\_\+sleep\+\_\+sec()}{get\_sleep\_sec()}}
{\footnotesize\ttfamily int lbann\+::get\+\_\+sleep\+\_\+sec (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=329pt]{namespacelbann_a17d55032bad5bb02903f9b1d933836a4_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a478d36031ff0659893c4322cd856157f}\label{namespacelbann_a478d36031ff0659893c4322cd856157f}} 
\index{lbann@{lbann}!get\+\_\+time@{get\+\_\+time}}
\index{get\+\_\+time@{get\+\_\+time}!lbann@{lbann}}
\subsubsection{\texorpdfstring{get\+\_\+time()}{get\_time()}}
{\footnotesize\ttfamily double lbann\+::get\+\_\+time (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Return time in fractional seconds since an epoch. 

Definition at line 37 of file timer.\+hpp.


\begin{DoxyCode}
37                          \{
38   \textcolor{keyword}{using namespace }std::chrono;
39   \textcolor{keywordflow}{return} duration\_cast<duration<double>>(
40            steady\_clock::now().time\_since\_epoch()).count();
41 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a478d36031ff0659893c4322cd856157f_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_af3f2c9055423e1fe3380b1ad4c4ab5ef}\label{namespacelbann_af3f2c9055423e1fe3380b1ad4c4ab5ef}} 
\index{lbann@{lbann}!get\+\_\+tokens@{get\+\_\+tokens}}
\index{get\+\_\+tokens@{get\+\_\+tokens}!lbann@{lbann}}
\subsubsection{\texorpdfstring{get\+\_\+tokens()}{get\_tokens()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::vector$<$ int $>$ lbann\+::get\+\_\+tokens (\begin{DoxyParamCaption}\item[{std\+::string}]{str,  }\item[{const std\+::vector$<$ char $>$}]{delims }\end{DoxyParamCaption})}



Tokenize a string into integers by an ordered sequence of delimiter characters. 



Definition at line 38 of file file\+\_\+utils.\+cpp.


\begin{DoxyCode}
38                                                                        \{
39   std::vector<int> tokens;
40   \textcolor{keywordtype}{size\_t} pos;
41 
42   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto} d : delims) \{
43     pos = str.find\_first\_of(d);
44     \textcolor{keywordflow}{if} (pos == std::string::npos) \{
45      \textcolor{comment}{// std::cerr << "Not able to split " << str << " by " << d << std::endl;}
46       \textcolor{keywordflow}{return} std::vector<int>();
47     \}
48     tokens.push\_back(atoi(str.substr(0, pos).c\_str()));
49     str = str.substr(pos+1, str.size());
50   \}
51 
52   \textcolor{keywordflow}{return} tokens;
53 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_af3f2c9055423e1fe3380b1ad4c4ab5ef_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_ac02a174553cf05f779743be1c92f1912}\label{namespacelbann_ac02a174553cf05f779743be1c92f1912}} 
\index{lbann@{lbann}!get\+\_\+tokens@{get\+\_\+tokens}}
\index{get\+\_\+tokens@{get\+\_\+tokens}!lbann@{lbann}}
\subsubsection{\texorpdfstring{get\+\_\+tokens()}{get\_tokens()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::string $>$ lbann\+::get\+\_\+tokens (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{const std\+::string}]{delims }\end{DoxyParamCaption})}



Tokenize a string into substrings by set of delimiter characters. 



Definition at line 55 of file file\+\_\+utils.\+cpp.


\begin{DoxyCode}
55                                                                              \{
56   std::vector<std::string> parsed;
57   \textcolor{keywordtype}{size\_t} pos\_start = 0u;
58   \textcolor{keywordtype}{size\_t} pos\_end = 0u;
59 
60   \textcolor{keywordflow}{while} ((pos\_end != std::string::npos) && (pos\_start != std::string::npos)) \{
61     pos\_start = str.find\_first\_not\_of(delims, pos\_end);
62     \textcolor{keywordflow}{if} (pos\_start != std::string::npos) \{
63       pos\_end = str.find\_first\_of(delims, pos\_start);
64       parsed.push\_back(str.substr(pos\_start, (pos\_end-pos\_start)));
65     \}
66   \}
67   \textcolor{keywordflow}{return} parsed;
68 \}
\end{DoxyCode}
\mbox{\Hypertarget{namespacelbann_a840c9f1d5f27bc30d081fb90529889e6}\label{namespacelbann_a840c9f1d5f27bc30d081fb90529889e6}} 
\index{lbann@{lbann}!glob@{glob}}
\index{glob@{glob}!lbann@{lbann}}
\subsubsection{\texorpdfstring{glob()}{glob()}}
{\footnotesize\ttfamily std\+::vector$<$std\+::string$>$ lbann\+::glob (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{pattern }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Wrapper around glob, which searches for paths matching pattern according to the shell. Note this does not do tilde expansion. 

Definition at line 42 of file glob.\+hpp.


\begin{DoxyCode}
42                                                            \{
43   glob\_t pglob;
44   \textcolor{keywordtype}{int} r = \hyperlink{namespacelbann_a840c9f1d5f27bc30d081fb90529889e6}{glob}(pattern.c\_str(), 0, \textcolor{keyword}{nullptr}, &pglob);
45   \textcolor{keywordflow}{if} (r != 0) \{
46     \textcolor{comment}{// Either an error or no match.}
47     \textcolor{keywordflow}{if} (r == GLOB\_NOMATCH) \{
48       \textcolor{keywordflow}{return} \{\};
49     \} \textcolor{keywordflow}{else} \{
50       \textcolor{keywordflow}{throw} lbann\_exception(\textcolor{stringliteral}{"glob error"});
51     \}
52   \}
53   std::vector<std::string> results(pglob.gl\_pathc);
54   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < pglob.gl\_pathc; ++i) \{
55     results[i] = std::string(pglob.gl\_pathv[i]);
56   \}
57   globfree(&pglob);
58   \textcolor{keywordflow}{return} results;
59 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a840c9f1d5f27bc30d081fb90529889e6_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_aa3636a1979e40da2af91f30a12b90db9}\label{namespacelbann_aa3636a1979e40da2af91f30a12b90db9}} 
\index{lbann@{lbann}!im2col@{im2col}}
\index{im2col@{im2col}!lbann@{lbann}}
\subsubsection{\texorpdfstring{im2col()}{im2col()}}
{\footnotesize\ttfamily void lbann\+::im2col (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{im,  }\item[{\hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{col,  }\item[{int}]{num\+\_\+channels,  }\item[{int}]{im\+\_\+num\+\_\+dims,  }\item[{const int $\ast$}]{im\+\_\+dims,  }\item[{const int $\ast$}]{im\+\_\+pads,  }\item[{const int $\ast$}]{window\+\_\+dims,  }\item[{const int $\ast$}]{window\+\_\+strides }\end{DoxyParamCaption})}



Rearrange image blocks into matrix columns. 

The \textquotesingle{}col\textquotesingle{} matrix is generated from the \textquotesingle{}im\textquotesingle{} tensor im by shifting a window across im. Each column of col is produced by positioning the window, extracting entries from im, and flattening. 
\begin{DoxyParams}{Parameters}
{\em im} & im tensor, represented as a column vector. \\
\hline
{\em col} & col matrix. Height should be equal to window size and width equal to number of window shifts. Data should be contiguous. \\
\hline
{\em num\+\_\+channels} & Number of channels in im tensor. \\
\hline
{\em im\+\_\+num\+\_\+dims} & Number of dimensions in im tensor. \\
\hline
{\em im\+\_\+dims} & im tensor dimensions. \\
\hline
{\em im\+\_\+pads} & Zero pads for im tensor. \\
\hline
{\em window\+\_\+dims} & Dimensions of window. \\
\hline
{\em window\+\_\+strides} & Window shift strides. \\
\hline
\end{DoxyParams}


Definition at line 32 of file im2col.\+cpp.


\begin{DoxyCode}
39                                         \{
40 
41   \textcolor{comment}{// Input and output parameters}
42   \textcolor{keyword}{const} \textcolor{keywordtype}{int} col\_height = col.Height();
43   \textcolor{keyword}{const} \textcolor{keywordtype}{int} col\_width = col.Width();
44   \textcolor{keyword}{const} DataType *\_\_restrict\_\_ im\_buffer = im.LockedBuffer();
45   DataType *\_\_restrict\_\_ col\_buffer = col.Buffer();
46 
47   \textcolor{comment}{// im2col parameters}
48   std::vector<int> offset\_start(im\_num\_dims);
49   std::vector<int> offset\_end(im\_num\_dims);
50   std::vector<int> offset\_stride(im\_num\_dims);
51   std::vector<int> offset\_num(im\_num\_dims);
52   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} d = 0; d < im\_num\_dims; ++d) \{
53     offset\_start[d] = -im\_pads[d];
54     offset\_end[d] = im\_dims[d] + im\_pads[d] - window\_dims[d] + 1;
55     offset\_stride[d] = window\_strides[d];
56     offset\_num[d] = (offset\_end[d] - offset\_start[d] + offset\_stride[d] - 1) / offset\_stride[d];
57   \}
58 
59 \textcolor{preprocessor}{  #ifdef LBANN\_DEBUG}
60   \textcolor{keyword}{const} \textcolor{keywordtype}{int} im\_size = im.Height();
61   \textcolor{comment}{// Check matrix dimensions}
62   \textcolor{keyword}{const} \textcolor{keywordtype}{int} expected\_im\_size = std::accumulate(im\_dims,
63                                                im\_dims + im\_num\_dims,
64                                                num\_channels,
65                                                std::multiplies<int>());
66   \textcolor{keyword}{const} \textcolor{keywordtype}{int} expected\_col\_height = std::accumulate(window\_dims,
67                                                   window\_dims + im\_num\_dims,
68                                                   num\_channels,
69                                                   std::multiplies<int>());
70   \textcolor{keyword}{const} \textcolor{keywordtype}{int} expected\_col\_width = std::accumulate(offset\_num.begin(),
71                                                  offset\_num.end(),
72                                                  1,
73                                                  std::multiplies<int>());
74   \textcolor{keywordflow}{if}(im\_size != expected\_im\_size || im.Width() != 1) \{
75     std::stringstream ss;
76     ss << \textcolor{stringliteral}{"im2col: im matrix has invalid dimensions "}
77        << \textcolor{stringliteral}{"(expected "} << expected\_im\_size << \textcolor{stringliteral}{" x "} << 1 << \textcolor{stringliteral}{", "}
78        << \textcolor{stringliteral}{"found "} << im\_size << \textcolor{stringliteral}{" x "} << im.Width() << \textcolor{stringliteral}{")"};
79     \textcolor{keywordflow}{throw} lbann\_exception(ss.str());
80   \}
81   \textcolor{keywordflow}{if}(col\_height != expected\_col\_height
82      || col\_width != expected\_col\_width) \{
83     std::stringstream ss;
84     ss << \textcolor{stringliteral}{"im2col: col matrix has invalid dimensions "}
85        << \textcolor{stringliteral}{"(expected "} << expected\_col\_height << \textcolor{stringliteral}{" x "} << expected\_col\_width << \textcolor{stringliteral}{", "}
86        << \textcolor{stringliteral}{"found "} << col\_height << \textcolor{stringliteral}{" x "} << col\_width << \textcolor{stringliteral}{")"};
87     \textcolor{keywordflow}{throw} lbann\_exception(ss.str());
88   \}
89 \textcolor{preprocessor}{  #endif // LBANN\_DEBUG  }
90 
91   \textcolor{comment}{// Call optimized routine for 1x1 im2col}
92   std::vector<int> zeros(im\_num\_dims, 0), ones(im\_num\_dims, 1);
93   \textcolor{keywordflow}{if}(std::equal(im\_pads, im\_pads + im\_num\_dims, zeros.begin())
94      && std::equal(window\_dims, window\_dims + im\_num\_dims, ones.begin())
95      && std::equal(window\_strides, window\_strides + im\_num\_dims, ones.begin())) \{
96     \hyperlink{namespacelbann_a3d099edd7d1b09889e0d2133bb83d5bf}{im2col\_1x1}(im\_buffer, col\_buffer, num\_channels, im\_num\_dims, im\_dims);
97     \textcolor{keywordflow}{return};
98   \}
99 
100   \textcolor{comment}{// Call optimized routine for 2D data}
101   \textcolor{keywordflow}{if}(im\_num\_dims == 2) \{
102     \hyperlink{namespacelbann_adc05d10657be77ccd9a74b1621c416c3}{im2col\_2d}(im\_buffer, col\_buffer,
103               im\_dims[1], im\_dims[0], im\_pads[1], im\_pads[0], num\_channels,
104               window\_dims[1], window\_dims[0],
105               window\_strides[1], window\_strides[0]);
106     \textcolor{keywordflow}{return};
107   \}
108 
109   \textcolor{comment}{// Iterate through col matrix columns}
110 \textcolor{preprocessor}{  #pragma omp parallel for}
111   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} col\_col = 0; col\_col < col\_width; ++col\_col) \{
112 
113     \textcolor{comment}{// Initialize arrays}
114     std::vector<int> offset\_pos(im\_num\_dims);
115     std::vector<int> window\_pos(im\_num\_dims);
116 
117     \textcolor{comment}{// Get position of current offset}
118     \textcolor{keywordtype}{int} col\_col\_remainder = col\_col;
119     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} d = im\_num\_dims-1; d >= 0; --d) \{
120       \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset = col\_col\_remainder % offset\_num[d];
121       offset\_pos[d] = offset\_start[d] + offset * offset\_stride[d];
122       col\_col\_remainder /= offset\_num[d];
123     \}
124 
125     \textcolor{comment}{// Iterate through col matrix entries}
126     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} col\_row = 0; col\_row < col\_height; ++col\_row) \{
127       \textcolor{keyword}{const} \textcolor{keywordtype}{int} col\_index = col\_row + col\_col * col\_height;
128 
129       \textcolor{comment}{// Get position in window and channel}
130       \textcolor{keywordtype}{int} col\_row\_remainder = col\_row;
131       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} d = im\_num\_dims-1; d >= 0; --d) \{
132         window\_pos[d] = col\_row\_remainder % window\_dims[d];
133         col\_row\_remainder /= window\_dims[d];
134       \}
135       \textcolor{keyword}{const} \textcolor{keywordtype}{int} channel = col\_row\_remainder;
136 
137       \textcolor{comment}{// Get im matrix entry}
138       \textcolor{keywordtype}{bool} im\_pos\_valid = \textcolor{keyword}{true};
139       \textcolor{keywordtype}{int} im\_index = channel;
140       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} d = 0; d < im\_num\_dims; ++d) \{
141         \textcolor{keyword}{const} \textcolor{keywordtype}{int} im\_pos = offset\_pos[d] + window\_pos[d];
142         im\_pos\_valid = im\_pos\_valid && 0 <= im\_pos && im\_pos < im\_dims[d];
143         im\_index = im\_pos + im\_index * im\_dims[d];
144       \}
145 
146       \textcolor{comment}{// Copy im matrix entry to col matrix if valid}
147       col\_buffer[col\_index] = (im\_pos\_valid ?
148                                im\_buffer[im\_index] : DataType(0));
149 
150     \}
151   \}
152 
153 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=288pt]{namespacelbann_aa3636a1979e40da2af91f30a12b90db9_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_aa3636a1979e40da2af91f30a12b90db9_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a3d099edd7d1b09889e0d2133bb83d5bf}\label{namespacelbann_a3d099edd7d1b09889e0d2133bb83d5bf}} 
\index{lbann@{lbann}!im2col\+\_\+1x1@{im2col\+\_\+1x1}}
\index{im2col\+\_\+1x1@{im2col\+\_\+1x1}!lbann@{lbann}}
\subsubsection{\texorpdfstring{im2col\+\_\+1x1()}{im2col\_1x1()}}
{\footnotesize\ttfamily void lbann\+::im2col\+\_\+1x1 (\begin{DoxyParamCaption}\item[{const Data\+Type $\ast$}]{input\+\_\+buffer,  }\item[{Data\+Type $\ast$}]{output\+\_\+buffer,  }\item[{int}]{num\+\_\+channels,  }\item[{int}]{num\+\_\+input\+\_\+dims,  }\item[{const int $\ast$}]{input\+\_\+dims }\end{DoxyParamCaption})}



Rearrange 1x1 image blocks into matrix columns. 

This is an optimized implementation of im2col when the window has a size of one, there is no padding, and the window stride is one. im2col will automatically call this routine if it detects a 1x1 im2col. 

Definition at line 350 of file im2col.\+cpp.


\begin{DoxyCode}
354                                         \{
355   \textcolor{keyword}{const} \textcolor{keywordtype}{int} spatial\_size = std::accumulate(input\_dims,
356                                            input\_dims + num\_input\_dims,
357                                            1,
358                                            std::multiplies<int>());
359   \textcolor{keyword}{const} \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} input\_matrix(spatial\_size, num\_channels, input\_buffer, spatial\_size);
360   \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} output\_matrix(num\_channels, spatial\_size, output\_buffer, num\_channels);
361   El::Transpose(input\_matrix, output\_matrix);
362 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a3d099edd7d1b09889e0d2133bb83d5bf_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_adc05d10657be77ccd9a74b1621c416c3}\label{namespacelbann_adc05d10657be77ccd9a74b1621c416c3}} 
\index{lbann@{lbann}!im2col\+\_\+2d@{im2col\+\_\+2d}}
\index{im2col\+\_\+2d@{im2col\+\_\+2d}!lbann@{lbann}}
\subsubsection{\texorpdfstring{im2col\+\_\+2d()}{im2col\_2d()}}
{\footnotesize\ttfamily void lbann\+::im2col\+\_\+2d (\begin{DoxyParamCaption}\item[{const Data\+Type $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{input\+\_\+buffer,  }\item[{Data\+Type $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{output\+\_\+buffer,  }\item[{int}]{input\+\_\+dim\+\_\+x,  }\item[{int}]{input\+\_\+dim\+\_\+y,  }\item[{int}]{input\+\_\+pad\+\_\+x,  }\item[{int}]{input\+\_\+pad\+\_\+y,  }\item[{int}]{num\+\_\+channels,  }\item[{int}]{window\+\_\+dim\+\_\+x,  }\item[{int}]{window\+\_\+dim\+\_\+y,  }\item[{int}]{offset\+\_\+stride\+\_\+x,  }\item[{int}]{offset\+\_\+stride\+\_\+y }\end{DoxyParamCaption})}



Rearrange 2D image blocks into matrix columns. 

This is an optimized implementation of im2col for 2D data. im2col will automatically call this routine if it detects 2D data. 

Definition at line 364 of file im2col.\+cpp.


\begin{DoxyCode}
374                                           \{
375 
376   \textcolor{comment}{// im2col parameters}
377   \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_start\_x = -input\_pad\_x;
378   \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_start\_y = -input\_pad\_y;
379   \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_end\_x = input\_dim\_x + input\_pad\_x - window\_dim\_x + 1;
380   \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_end\_y = input\_dim\_y + input\_pad\_y - window\_dim\_y + 1;
381   \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_num\_x = (offset\_end\_x - offset\_start\_x + offset\_stride\_x - 1) / offset\_stride\_x;
382   \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_num\_y = (offset\_end\_y - offset\_start\_y + offset\_stride\_y - 1) / offset\_stride\_y;
383   \textcolor{keyword}{const} \textcolor{keywordtype}{int} output\_height = num\_channels * window\_dim\_x * window\_dim\_y;
384 
385   \textcolor{comment}{// Iterate through output matrix entries}
386 \textcolor{preprocessor}{  #pragma omp parallel for collapse(5)}
387   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} offset\_y = 0; offset\_y < offset\_num\_y; ++offset\_y) \{
388     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} offset\_x = 0; offset\_x < offset\_num\_x; ++offset\_x) \{
389       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} channel = 0; channel < num\_channels; ++channel) \{
390         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} window\_pos\_y = 0;
391             window\_pos\_y < window\_dim\_y;
392             ++window\_pos\_y) \{
393           \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} window\_pos\_x = 0;
394               window\_pos\_x < window\_dim\_x;
395               ++window\_pos\_x) \{
396 
397             \textcolor{comment}{// Get input entry}
398             \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_pos\_y = offset\_start\_y + offset\_y * offset\_stride\_y;
399             \textcolor{keyword}{const} \textcolor{keywordtype}{int} offset\_pos\_x = offset\_start\_x + offset\_x * offset\_stride\_x;
400             \textcolor{keyword}{const} \textcolor{keywordtype}{int} input\_pos\_y = offset\_pos\_y + window\_pos\_y;
401             \textcolor{keyword}{const} \textcolor{keywordtype}{int} input\_pos\_x = offset\_pos\_x + window\_pos\_x;
402             \textcolor{keyword}{const} \textcolor{keywordtype}{int} input\_index = (input\_pos\_x
403                                      + input\_pos\_y * input\_dim\_x
404                                      + channel * input\_dim\_x * input\_dim\_y);
405             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} input\_pos\_valid = (0 <= input\_pos\_y
406                                           && input\_pos\_y < input\_dim\_y
407                                           && 0 <= input\_pos\_x
408                                           && input\_pos\_x < input\_dim\_x);
409 
410             \textcolor{comment}{// Get output entry}
411             \textcolor{keyword}{const} \textcolor{keywordtype}{int} output\_row = (window\_pos\_x
412                                     + window\_pos\_y * window\_dim\_x
413                                     + channel * window\_dim\_x * window\_dim\_y);
414             \textcolor{keyword}{const} \textcolor{keywordtype}{int} output\_col = offset\_x + offset\_y * offset\_num\_x;
415             \textcolor{keyword}{const} \textcolor{keywordtype}{int} output\_index = output\_row + output\_col * output\_height;
416 
417             \textcolor{comment}{// Copy input entry to output entry if valid}
418             output\_buffer[output\_index]
419               = input\_pos\_valid ? input\_buffer[input\_index] : DataType(0);
420 
421           \}
422         \}
423       \}
424     \}
425   \}
426 
427 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_adc05d10657be77ccd9a74b1621c416c3_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a8987701a637ff0e678114aa77e9c4d40}\label{namespacelbann_a8987701a637ff0e678114aa77e9c4d40}} 
\index{lbann@{lbann}!init\+\_\+data\+\_\+seq\+\_\+random@{init\+\_\+data\+\_\+seq\+\_\+random}}
\index{init\+\_\+data\+\_\+seq\+\_\+random@{init\+\_\+data\+\_\+seq\+\_\+random}!lbann@{lbann}}
\subsubsection{\texorpdfstring{init\+\_\+data\+\_\+seq\+\_\+random()}{init\_data\_seq\_random()}}
{\footnotesize\ttfamily void lbann\+::init\+\_\+data\+\_\+seq\+\_\+random (\begin{DoxyParamCaption}\item[{int}]{seed = {\ttfamily -\/1} }\end{DoxyParamCaption})}

Initialize a random number generator (with optional seed) that is specifically used for sequencing the training / testing data samples. Using a separate R\+NG for the data sequences helps provide a stable training result that does not vary with how much I/O parallelism is applied. \begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000031}{Todo}]Support saving/restoring the generator\textquotesingle{}s state. This is directly supported via the $>$$>$ and $<$$<$ operators on the generator (reading/writing from/to a stream). \end{DoxyRefDesc}


Definition at line 147 of file random.\+cpp.


\begin{DoxyCode}
147                                     \{
148   \textcolor{keywordflow}{if} (seed == -1) \{
149     \textcolor{comment}{// Seed with a random value.}
150     std::random\_device rd;
151     seed = rd();
152   \}
153 
154   \textcolor{comment}{// Seed every OpenMP thread, if present.}
155   \textcolor{comment}{// Note: Threadprivate OMP variables don't work with dynamic threads.}
156 \textcolor{preprocessor}{#ifdef \_OPENMP}
157 \textcolor{preprocessor}{  #pragma omp parallel}
158   \{
159     \hyperlink{namespacelbann_aba9d11cb3a739cd84e7234ceeb32d098}{get\_data\_seq\_generator}().seed(seed);
160   \}
161 \textcolor{preprocessor}{#else}
162   \hyperlink{namespacelbann_aba9d11cb3a739cd84e7234ceeb32d098}{get\_data\_seq\_generator}().seed(seed);
163 \textcolor{preprocessor}{#endif}
164 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=328pt]{namespacelbann_a8987701a637ff0e678114aa77e9c4d40_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a8987701a637ff0e678114aa77e9c4d40_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_acef152f20e422b3aea1a3c1691a533ac}\label{namespacelbann_acef152f20e422b3aea1a3c1691a533ac}} 
\index{lbann@{lbann}!init\+\_\+random@{init\+\_\+random}}
\index{init\+\_\+random@{init\+\_\+random}!lbann@{lbann}}
\subsubsection{\texorpdfstring{init\+\_\+random()}{init\_random()}}
{\footnotesize\ttfamily void lbann\+::init\+\_\+random (\begin{DoxyParamCaption}\item[{int}]{seed = {\ttfamily -\/1},  }\item[{\hyperlink{classlbann_1_1lbann__comm}{lbann\+\_\+comm} $\ast$}]{comm = {\ttfamily nullptr} }\end{DoxyParamCaption})}

Initialize the random number generator (with optional seed). 
\begin{DoxyParams}{Parameters}
{\em comm} & If present, mixes the process\textquotesingle{}s rank within the model into the seed; if not, uses the M\+PI world rank. \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000030}{Todo}]Support saving/restoring the generator\textquotesingle{}s state. This is directly supported via the $>$$>$ and $<$$<$ operators on the generator (reading/writing from/to a stream). \end{DoxyRefDesc}


Definition at line 106 of file random.\+cpp.


\begin{DoxyCode}
106                                              \{
107   \textcolor{keywordflow}{if} (seed != -1) \{
108     \textcolor{comment}{// Seed every OpenMP thread, if present.}
109     \textcolor{comment}{// Note: Threadprivate OMP variables don't work with dynamic threads.}
110 \textcolor{preprocessor}{#ifdef \_OPENMP}
111 \textcolor{preprocessor}{    #pragma omp parallel}
112     \{
113       \hyperlink{namespacelbann_a4fea7ba21017b49d1e34394b4c20c764}{get\_generator}().seed((seed << 8) | omp\_get\_thread\_num());
114       \hyperlink{namespacelbann_ae6ce9c2fdec6f81803f6b1a6555c31c5}{get\_fast\_generator}().seed((seed << 8) | omp\_get\_thread\_num());
115     \}
116 \textcolor{preprocessor}{#else}
117     \hyperlink{namespacelbann_a4fea7ba21017b49d1e34394b4c20c764}{get\_generator}().seed(seed);
118     \hyperlink{namespacelbann_ae6ce9c2fdec6f81803f6b1a6555c31c5}{get\_fast\_generator}().seed(seed);
119 \textcolor{preprocessor}{#endif}
120 \textcolor{preprocessor}{#ifdef LBANN\_SET\_EL\_RNG}
121     \textcolor{keywordflow}{if} (\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm} != \textcolor{keyword}{nullptr}) \{
122       El::Generator().seed(seed ^ \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}->get\_rank\_in\_model());
123     \} \textcolor{keywordflow}{else} \{
124       El::Generator().seed(seed ^ El::mpi::Rank(El::mpi::COMM\_WORLD));
125     \}
126 \textcolor{preprocessor}{#endif}
127   \} \textcolor{keywordflow}{else} \{
128     \textcolor{comment}{// Seed with a random value.}
129     std::random\_device rd;
130     \textcolor{keywordtype}{unsigned} rand\_val = rd();
131 \textcolor{preprocessor}{#ifdef \_OPENMP}
132 \textcolor{preprocessor}{    #pragma omp parallel}
133     \{
134       \hyperlink{namespacelbann_a4fea7ba21017b49d1e34394b4c20c764}{get\_generator}().seed((rand\_val << 8) | omp\_get\_thread\_num());
135       \hyperlink{namespacelbann_ae6ce9c2fdec6f81803f6b1a6555c31c5}{get\_fast\_generator}().seed((rand\_val << 8) | omp\_get\_thread\_num());
136     \}
137 \textcolor{preprocessor}{#else}
138     \hyperlink{namespacelbann_a4fea7ba21017b49d1e34394b4c20c764}{get\_generator}().seed(rand\_val);
139     \hyperlink{namespacelbann_ae6ce9c2fdec6f81803f6b1a6555c31c5}{get\_fast\_generator}().seed(rand\_val);
140 \textcolor{preprocessor}{#endif}
141 \textcolor{preprocessor}{#ifdef LBANN\_SET\_EL\_RNG}
142     El::Generator().seed(rand\_val);
143 \textcolor{preprocessor}{#endif}
144   \}
145 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=344pt]{namespacelbann_acef152f20e422b3aea1a3c1691a533ac_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_acef152f20e422b3aea1a3c1691a533ac_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a3d91b615e42bf5744deeed770879bc8c}\label{namespacelbann_a3d91b615e42bf5744deeed770879bc8c}} 
\index{lbann@{lbann}!initialize@{initialize}}
\index{initialize@{initialize}!lbann@{lbann}}
\subsubsection{\texorpdfstring{initialize()}{initialize()}}
{\footnotesize\ttfamily \hyperlink{classlbann_1_1lbann__comm}{lbann\+\_\+comm} $\ast$ lbann\+::initialize (\begin{DoxyParamCaption}\item[{int \&}]{argc,  }\item[{char $\ast$$\ast$\&}]{argv,  }\item[{int}]{seed = {\ttfamily -\/1} }\end{DoxyParamCaption})}

Initialize L\+B\+A\+NN. The comm instance this returns places every process in one model. This can be changed with \hyperlink{classlbann_1_1lbann__comm_a0ae02c4083623d2e1381336a73fdb379}{lbann\+\_\+comm\+::split\+\_\+models} afterward. 
\begin{DoxyParams}{Parameters}
{\em argc} & The program\textquotesingle{}s argc. \\
\hline
{\em argv} & The program\textquotesingle{}s argv. \\
\hline
{\em seed} & Optional seed for random number generators. \\
\hline
\end{DoxyParams}


Definition at line 46 of file base.\+cpp.


\begin{DoxyCode}
46                                                           \{
47   \textcolor{comment}{// Initialize Elemental.}
48   El::Initialize(argc, argv);
49   \textcolor{comment}{// Create a new comm object.}
50   \textcolor{comment}{// Initial creation with every process in one model.}
51   \textcolor{keyword}{auto}* \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm} = \textcolor{keyword}{new} lbann\_comm(0);
52 \textcolor{preprocessor}{#if defined(LBANN\_TOPO\_AWARE)}
53   \textcolor{comment}{// Determine the number of NUMA nodes present.}
54   hwloc\_topology\_t topo;
55   hwloc\_topology\_init(&topo);
56   hwloc\_topology\_load(topo);
57   \textcolor{keywordtype}{int} numa\_depth = hwloc\_get\_type\_depth(topo, HWLOC\_OBJ\_NUMANODE);
58   \textcolor{keywordflow}{if} (numa\_depth == HWLOC\_TYPE\_DEPTH\_UNKNOWN) \{
59     std::cout << \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}->get\_rank\_in\_world() <<
60               \textcolor{stringliteral}{": cannot determine hwloc NUMA-node depth"} << std::endl;
61   \}
62   \textcolor{keywordtype}{int} num\_numa\_nodes = hwloc\_get\_nbobjs\_by\_depth(topo, numa\_depth);
63   \textcolor{comment}{// Warn if there are more NUMA nodes than processes per node.}
64   \textcolor{comment}{// It's probably fine if there are more processes than NUMA nodes for now.}
65   \textcolor{comment}{// We can adjust that later when we better understand the threaded perf.}
66   \textcolor{keywordtype}{int} ppn = \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}->get\_procs\_per\_node();
67   \textcolor{keywordflow}{if} (num\_numa\_nodes > ppn) \{
68     \textcolor{keywordflow}{if} (\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}->get\_rank\_in\_node() == 0) \{
69       std::cout << \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}->get\_rank\_in\_world() <<
70                 \textcolor{stringliteral}{": WARNING: node has "} << num\_numa\_nodes <<
71                 \textcolor{stringliteral}{" NUMA nodes but you have "} << ppn << \textcolor{stringliteral}{" processes per node"} <<
72                 std::endl;
73     \}
74   \}
75   hwloc\_topology\_destroy(topo);
76 \textcolor{preprocessor}{#endif}
77   \textcolor{comment}{// Initialize local random number generators.}
78   \hyperlink{namespacelbann_acef152f20e422b3aea1a3c1691a533ac}{init\_random}(seed);
79   \hyperlink{namespacelbann_a8987701a637ff0e678114aa77e9c4d40}{init\_data\_seq\_random}(seed);
80 
81   \textcolor{comment}{//initialization for stack tracing when a signal is raised}
82   \textcolor{comment}{//or an lbann\_exception thrown.}
83   \hyperlink{namespacelbann_1_1stack__trace_a1063a9a501d78a7525224461e155a483}{stack\_trace::set\_lbann\_stack\_trace\_world\_rank}(
      \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}->get\_rank\_in\_world());
84 
85   \textcolor{keywordflow}{return} \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm};
86 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a3d91b615e42bf5744deeed770879bc8c_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_af3507a38f8992e27898d63551a987341}\label{namespacelbann_af3507a38f8992e27898d63551a987341}} 
\index{lbann@{lbann}!Layer\+::instantiate\+\_\+matrices$<$ data\+\_\+layout\+::\+D\+A\+T\+A\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L $>$@{Layer\+::instantiate\+\_\+matrices$<$ data\+\_\+layout\+::\+D\+A\+T\+A\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L $>$}}
\index{Layer\+::instantiate\+\_\+matrices$<$ data\+\_\+layout\+::\+D\+A\+T\+A\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L $>$@{Layer\+::instantiate\+\_\+matrices$<$ data\+\_\+layout\+::\+D\+A\+T\+A\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L $>$}!lbann@{lbann}}
\subsubsection{\texorpdfstring{Layer\+::instantiate\+\_\+matrices$<$ data\+\_\+layout\+::\+D\+A\+T\+A\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L $>$()}{Layer::instantiate\_matrices< data\_layout::DATA\_PARALLEL >()}}
{\footnotesize\ttfamily template$<$$>$ \\
void \hyperlink{classlbann_1_1Layer_a2d50e9af2a9aa7e6741deb555641c30c}{lbann\+::\+Layer\+::instantiate\+\_\+matrices}$<$ \hyperlink{base_8hpp_a786677cbfb3f5677b4d84f3056eb08dba37d2a3465f7cbf4ab60f4e79944d0638}{data\+\_\+layout\+::\+D\+A\+T\+A\+\_\+\+P\+A\+R\+A\+L\+L\+EL} $>$ (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a9951bb1719d534e0401b1f06cad19eab}{El\+::\+Grid} \&}]{grid }\end{DoxyParamCaption})}



Definition at line 569 of file layer.\+cpp.


\begin{DoxyCode}
569                                                                              \{
570   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < get\_num\_parents(); ++i) \{
571     m\_prev\_activations.push\_back(\textcolor{keyword}{new} \hyperlink{base_8hpp_aa4ec814c4a8f15b4ea2b24b3af94ef23}{StarVCMat}(grid));
572     m\_error\_signals.push\_back(\textcolor{keyword}{new} \hyperlink{base_8hpp_aa4ec814c4a8f15b4ea2b24b3af94ef23}{StarVCMat}(grid));
573   \}
574   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < get\_num\_children(); ++i) \{
575     m\_activations.push\_back(\textcolor{keyword}{new} \hyperlink{base_8hpp_aa4ec814c4a8f15b4ea2b24b3af94ef23}{StarVCMat}(grid));
576     m\_prev\_error\_signals.push\_back(\textcolor{keyword}{new} \hyperlink{base_8hpp_aa4ec814c4a8f15b4ea2b24b3af94ef23}{StarVCMat}(grid));
577   \}
578 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_af3507a38f8992e27898d63551a987341_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a32006e2c89920b1ff6e8a2318650dd7f}\label{namespacelbann_a32006e2c89920b1ff6e8a2318650dd7f}} 
\index{lbann@{lbann}!Layer\+::instantiate\+\_\+matrices$<$ data\+\_\+layout\+::\+M\+O\+D\+E\+L\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L $>$@{Layer\+::instantiate\+\_\+matrices$<$ data\+\_\+layout\+::\+M\+O\+D\+E\+L\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L $>$}}
\index{Layer\+::instantiate\+\_\+matrices$<$ data\+\_\+layout\+::\+M\+O\+D\+E\+L\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L $>$@{Layer\+::instantiate\+\_\+matrices$<$ data\+\_\+layout\+::\+M\+O\+D\+E\+L\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L $>$}!lbann@{lbann}}
\subsubsection{\texorpdfstring{Layer\+::instantiate\+\_\+matrices$<$ data\+\_\+layout\+::\+M\+O\+D\+E\+L\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L $>$()}{Layer::instantiate\_matrices< data\_layout::MODEL\_PARALLEL >()}}
{\footnotesize\ttfamily template$<$$>$ \\
void \hyperlink{classlbann_1_1Layer_a2d50e9af2a9aa7e6741deb555641c30c}{lbann\+::\+Layer\+::instantiate\+\_\+matrices}$<$ \hyperlink{base_8hpp_a786677cbfb3f5677b4d84f3056eb08dbac94d7b0e44ab8bdcdad694a673cdeae0}{data\+\_\+layout\+::\+M\+O\+D\+E\+L\+\_\+\+P\+A\+R\+A\+L\+L\+EL} $>$ (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a9951bb1719d534e0401b1f06cad19eab}{El\+::\+Grid} \&}]{grid }\end{DoxyParamCaption})}



Definition at line 557 of file layer.\+cpp.


\begin{DoxyCode}
557                                                                               \{
558   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < get\_num\_parents(); ++i) \{
559     m\_prev\_activations.push\_back(\textcolor{keyword}{new} \hyperlink{base_8hpp_a50f80e25e2fbefe6b32d270b8d4f8d19}{MCMRMat}(grid));
560     m\_error\_signals.push\_back(\textcolor{keyword}{new} \hyperlink{base_8hpp_a50f80e25e2fbefe6b32d270b8d4f8d19}{MCMRMat}(grid));
561   \}
562   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < get\_num\_children(); ++i) \{
563     m\_activations.push\_back(\textcolor{keyword}{new} \hyperlink{base_8hpp_a50f80e25e2fbefe6b32d270b8d4f8d19}{MCMRMat}(grid));
564     m\_prev\_error\_signals.push\_back(\textcolor{keyword}{new} \hyperlink{base_8hpp_a50f80e25e2fbefe6b32d270b8d4f8d19}{MCMRMat}(grid));
565   \}
566 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a32006e2c89920b1ff6e8a2318650dd7f_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_aedccb3bf2d674ccb5573ab9960720731}\label{namespacelbann_aedccb3bf2d674ccb5573ab9960720731}} 
\index{lbann@{lbann}!lbann\+\_\+report\+\_\+exception@{lbann\+\_\+report\+\_\+exception}}
\index{lbann\+\_\+report\+\_\+exception@{lbann\+\_\+report\+\_\+exception}!lbann@{lbann}}
\subsubsection{\texorpdfstring{lbann\+\_\+report\+\_\+exception()}{lbann\_report\_exception()}}
{\footnotesize\ttfamily void lbann\+::lbann\+\_\+report\+\_\+exception (\begin{DoxyParamCaption}\item[{\hyperlink{classlbann_1_1lbann__exception}{lbann\+\_\+exception} \&}]{e,  }\item[{\hyperlink{classlbann_1_1lbann__comm}{lbann\+\_\+comm} $\ast$}]{comm = {\ttfamily nullptr},  }\item[{std\+::ostream \&}]{os = {\ttfamily std\+:\+:cerr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 55 of file exception.\+hpp.


\begin{DoxyCode}
55                                                                                                           \{
56   \textcolor{keywordflow}{if}( std::string(e.what()) != \textcolor{stringliteral}{""} ) \{
57     \textcolor{keywordflow}{if}(\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm} != \textcolor{keyword}{nullptr}) \{
58       os << \textcolor{stringliteral}{"LBANN: rank "} << \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}->get\_rank\_in\_model() << \textcolor{stringliteral}{" of model "} << 
      \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}->get\_model\_rank() <<\textcolor{stringliteral}{" caught error message:"};
59     \} \textcolor{keywordflow}{else} \{
60       os << \textcolor{stringliteral}{"LBANN: caught error message:"};
61     \}
62     os << \textcolor{stringliteral}{"\(\backslash\)t"} << e.what() << std::endl;
63   \}
64   El::mpi::Abort( El::mpi::COMM\_WORLD, 1 );
65 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=337pt]{namespacelbann_aedccb3bf2d674ccb5573ab9960720731_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_aedccb3bf2d674ccb5573ab9960720731_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a9c2447a7dfde8f6fb73c5f12f20046f9}\label{namespacelbann_a9c2447a7dfde8f6fb73c5f12f20046f9}} 
\index{lbann@{lbann}!load\+\_\+file@{load\+\_\+file}}
\index{load\+\_\+file@{load\+\_\+file}!lbann@{lbann}}
\subsubsection{\texorpdfstring{load\+\_\+file()}{load\_file()}}
{\footnotesize\ttfamily template$<$typename T  = std\+::vector$<$unsigned char$>$$>$ \\
bool lbann\+::load\+\_\+file (\begin{DoxyParamCaption}\item[{const std\+::string}]{filename,  }\item[{T \&}]{buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Load a file into a buffer. 



Definition at line 68 of file file\+\_\+utils.\+hpp.


\begin{DoxyCode}
68                                                         \{
69   std::ifstream file(filename, std::ios::binary);
70   \textcolor{keywordflow}{if} (!file.good()) \{
71     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
72   \}
73 
74   file.unsetf(std::ios::skipws);
75 
76   file.seekg(0, std::ios::end);
77   \textcolor{keyword}{const} std::streampos file\_size = file.tellg();
78 
79   file.seekg(0, std::ios::beg);
80 
81   buf.reserve(file\_size);
82 
83   buf.insert(buf.begin(),
84              std::istream\_iterator<unsigned char>(file),
85              std::istream\_iterator<unsigned char>());
86 
87   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
88 \}
\end{DoxyCode}
\mbox{\Hypertarget{namespacelbann_a59f65281406da5bc57f49d8ec682be2d}\label{namespacelbann_a59f65281406da5bc57f49d8ec682be2d}} 
\index{lbann@{lbann}!load\+\_\+mnist\+\_\+data@{load\+\_\+mnist\+\_\+data}}
\index{load\+\_\+mnist\+\_\+data@{load\+\_\+mnist\+\_\+data}!lbann@{lbann}}
\subsubsection{\texorpdfstring{load\+\_\+mnist\+\_\+data()}{load\_mnist\_data()}}
{\footnotesize\ttfamily void lbann\+::load\+\_\+mnist\+\_\+data (\begin{DoxyParamCaption}\item[{const std\+::string}]{imagepath,  }\item[{const std\+::string}]{labelpath,  }\item[{const int}]{m\+\_\+first\+\_\+n,  }\item[{std\+::vector$<$ std\+::vector$<$ unsigned char $>$ $>$ \&}]{m\+\_\+image\+\_\+data }\end{DoxyParamCaption})}



Definition at line 74 of file data\+\_\+reader\+\_\+mnist.\+cpp.


\begin{DoxyCode}
75                                                                            \{
76 
77   \textcolor{comment}{// read labels}
78   FILE *fplbl = fopen(labelpath.c\_str(), \textcolor{stringliteral}{"rb"});
79   \textcolor{keywordflow}{if} (!fplbl) \{
80     \textcolor{keywordflow}{throw} lbann\_exception(
81       std::string\{\} + \_\_FILE\_\_ + \textcolor{stringliteral}{" "} + std::to\_string(\_\_LINE\_\_) +
82       \textcolor{stringliteral}{" :: load\_mnist\_data: failed to open file: "} + labelpath);
83   \}
84 
85   \textcolor{keywordtype}{int} magicnum1, numitems1;
86   fread(&magicnum1, 4, 1, fplbl);
87   fread(&numitems1, 4, 1, fplbl);
88   \hyperlink{namespacelbann_a0fd8bc0ad31da913a124683f5ec4fdf1}{\_\_swapEndianInt}((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}&)magicnum1);
89   \hyperlink{namespacelbann_a0fd8bc0ad31da913a124683f5ec4fdf1}{\_\_swapEndianInt}((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}&)numitems1);
90 
91   \textcolor{comment}{// read images}
92   FILE *fpimg = fopen(imagepath.c\_str(), \textcolor{stringliteral}{"rb"});
93   \textcolor{keywordflow}{if} (!fpimg) \{
94     \textcolor{keywordflow}{throw} lbann\_exception(
95       std::string\{\} + \_\_FILE\_\_ + \textcolor{stringliteral}{" "} + std::to\_string(\_\_LINE\_\_) +
96       \textcolor{stringliteral}{" :: load\_mnist\_data: failed to open file: "} + imagepath);
97   \}
98 
99   \textcolor{keywordtype}{int} magicnum2, numitems2, imgwidth, imgheight;
100   fread(&magicnum2, 4, 1, fpimg);
101   fread(&numitems2, 4, 1, fpimg);
102   fread(&imgwidth, 4, 1, fpimg);
103   fread(&imgheight, 4, 1, fpimg);
104   \hyperlink{namespacelbann_a0fd8bc0ad31da913a124683f5ec4fdf1}{\_\_swapEndianInt}((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}&)magicnum2);
105   \hyperlink{namespacelbann_a0fd8bc0ad31da913a124683f5ec4fdf1}{\_\_swapEndianInt}((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}&)numitems2);
106   \hyperlink{namespacelbann_a0fd8bc0ad31da913a124683f5ec4fdf1}{\_\_swapEndianInt}((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}&)imgwidth);
107   \hyperlink{namespacelbann_a0fd8bc0ad31da913a124683f5ec4fdf1}{\_\_swapEndianInt}((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}&)imgheight);
108 
109   \textcolor{keywordflow}{if} (numitems1 != numitems2) \{
110     fclose(fplbl);
111     fclose(fpimg);
112     \textcolor{keywordflow}{throw} lbann\_exception(
113       std::string\{\} + \_\_FILE\_\_ + \textcolor{stringliteral}{" "} + std::to\_string(\_\_LINE\_\_) +
114       \textcolor{stringliteral}{" :: load\_mnist\_data: numitems1 != numitems2"});
115   \}
116 
117   \textcolor{keywordflow}{if} (m\_first\_n > 0) \{
118     numitems1 = m\_first\_n > numitems1 ? numitems1 : m\_first\_n;
119   \}
120 
121   \textcolor{comment}{// set to array}
122   m\_image\_data.resize(numitems1);
123   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} n = 0; n < numitems1; n++) \{
124     m\_image\_data[n].resize(1+(imgwidth * imgheight));
125     fread(&m\_image\_data[n][0], 1, 1, fplbl);
126     fread(&m\_image\_data[n][1], imgwidth * imgheight, 1, fpimg);
127   \}
128   fclose(fpimg);
129   fclose(fplbl);
130 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a59f65281406da5bc57f49d8ec682be2d_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a59f65281406da5bc57f49d8ec682be2d_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_ab76114a0e8cc90c28bcb9e7d01eec89a}\label{namespacelbann_ab76114a0e8cc90c28bcb9e7d01eec89a}} 
\index{lbann@{lbann}!load\+\_\+rng\+\_\+from\+\_\+checkpoint\+\_\+shared@{load\+\_\+rng\+\_\+from\+\_\+checkpoint\+\_\+shared}}
\index{load\+\_\+rng\+\_\+from\+\_\+checkpoint\+\_\+shared@{load\+\_\+rng\+\_\+from\+\_\+checkpoint\+\_\+shared}!lbann@{lbann}}
\subsubsection{\texorpdfstring{load\+\_\+rng\+\_\+from\+\_\+checkpoint\+\_\+shared()}{load\_rng\_from\_checkpoint\_shared()}}
{\footnotesize\ttfamily bool lbann\+::load\+\_\+rng\+\_\+from\+\_\+checkpoint\+\_\+shared (\begin{DoxyParamCaption}\item[{\hyperlink{classlbann_1_1persist}{persist} \&}]{p }\end{DoxyParamCaption})}



Definition at line 89 of file random.\+cpp.


\begin{DoxyCode}
89                                                 \{
90   std::string rng\_name;
91   rng\_name = std::string(p.m\_checkpoint\_dir) + \textcolor{stringliteral}{"/rng\_seq\_generator"};
92   std::ifstream rng\_seq(rng\_name);
93   rng\_seq >> \hyperlink{namespaceanonymous__namespace_02random_8cpp_03_ac1d3d0259f3e9c9b75e9701ae727d16e}{::data\_seq\_generator};
94 
95   rng\_name = std::string(p.m\_checkpoint\_dir) + \textcolor{stringliteral}{"/rng\_generator"};
96   std::ifstream rng(rng\_name);
97   rng >> \hyperlink{namespaceanonymous__namespace_02random_8cpp_03_a83826c4b587d1825f13b833be6fe047f}{::generator};
98  
99   rng\_name = std::string(p.m\_checkpoint\_dir) + \textcolor{stringliteral}{"/rng\_fast\_generator"};
100   std::ifstream rng\_fast(rng\_name);
101   rng\_fast >> \hyperlink{namespaceanonymous__namespace_02random_8cpp_03_a349f572cec05cd0e2469b799774a8602}{::fast\_generator};
102 
103   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
104 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_ab76114a0e8cc90c28bcb9e7d01eec89a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a8830dea8eef0ab5b93d68e2358ceeb1a}\label{namespacelbann_a8830dea8eef0ab5b93d68e2358ceeb1a}} 
\index{lbann@{lbann}!makedir@{makedir}}
\index{makedir@{makedir}!lbann@{lbann}}
\subsubsection{\texorpdfstring{makedir()}{makedir()}}
{\footnotesize\ttfamily int lbann\+::makedir (\begin{DoxyParamCaption}\item[{const char $\ast$}]{dirname }\end{DoxyParamCaption})}



Definition at line 49 of file file\+\_\+io.\+cpp.


\begin{DoxyCode}
49                                   \{
50   \textcolor{comment}{// get our rank}
51   \textcolor{keywordtype}{int} rank;
52   MPI\_Comm\_rank(\hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm}, &rank);
53 
54   \textcolor{comment}{// have rank 0 create directory}
55   \textcolor{keywordtype}{int} mkdir\_rc;
56   \textcolor{keywordflow}{if} (rank == 0) \{
57     mkdir\_rc = mkdir(dir, \hyperlink{file__io_8cpp_a8a08135bfddb4c7375212d2ace2e24b7}{mode\_dir});
58     \textcolor{keywordflow}{if} (mkdir\_rc != 0) \{
59       \textcolor{keywordflow}{if} (errno == EEXIST) \{
60         \textcolor{comment}{// not an error if the directory already exists}
61         mkdir\_rc = 0;
62       \} \textcolor{keywordflow}{else} \{
63         fprintf(stderr, \textcolor{stringliteral}{"ERROR: Failed to create directory `%s' (%d: %s) @ %s:%d\(\backslash\)n"},
64                 dir, errno, strerror(errno), \_\_FILE\_\_, \_\_LINE\_\_
65                );
66         fflush(stderr);
67       \}
68     \}
69   \}
70 
71   \textcolor{comment}{// bcast whether directory was created or not}
72   MPI\_Bcast(&mkdir\_rc, 1, MPI\_INT, 0, \hyperlink{file__io_8cpp_ab048c6f9fcbcfaa57ce68b00263dbebe}{comm});
73 
74   \textcolor{comment}{// return 1 if dir was created successfully}
75   \textcolor{keywordtype}{int} ret = (mkdir\_rc == 0);
76   \textcolor{keywordflow}{return} ret;
77 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a8830dea8eef0ab5b93d68e2358ceeb1a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a351610c8df00514e8942756c2099fedc}\label{namespacelbann_a351610c8df00514e8942756c2099fedc}} 
\index{lbann@{lbann}!modify\+\_\+file\+\_\+name@{modify\+\_\+file\+\_\+name}}
\index{modify\+\_\+file\+\_\+name@{modify\+\_\+file\+\_\+name}!lbann@{lbann}}
\subsubsection{\texorpdfstring{modify\+\_\+file\+\_\+name()}{modify\_file\_name()}}
{\footnotesize\ttfamily std\+::string lbann\+::modify\+\_\+file\+\_\+name (\begin{DoxyParamCaption}\item[{const std\+::string}]{file\+\_\+name,  }\item[{const std\+::string}]{tag,  }\item[{const std\+::string}]{new\+\_\+ext }\end{DoxyParamCaption})}

Add tag to a file name and/or change the extension. i.\+e., given a file\+\_\+name as \char`\"{}name.\+ext\char`\"{}, a new name \char`\"{}name.\+tag.\+new\+\_\+ext\char`\"{} is returned If a new extension is not specified, it assumes the same. To change the extension without adding a tag, set tag to a null string. 

Definition at line 137 of file file\+\_\+utils.\+cpp.


\begin{DoxyCode}
137                                                                                                     \{
138   std::string dir;
139   std::string name;
140   \textcolor{keywordtype}{bool} ok = \hyperlink{namespacelbann_a1ce6832a54235a5fb333f50fffbe1b63}{parse\_path}(file\_name, dir, name);
141   \textcolor{keywordflow}{if} (!ok) \{
142     \textcolor{keywordflow}{return} std::string();
143   \}
144   std::string ext = (new\_ext.empty() ? \hyperlink{namespacelbann_ad9a28639b0953886bbcb7fc366783a17}{get\_ext\_name}(name) : new\_ext);
145   name = \hyperlink{namespacelbann_aea9a4378326fd51236a8343c43cc4a7c}{get\_basename\_without\_ext}(name);
146 
147   \textcolor{keywordflow}{if} (!tag.empty()) \{
148     name = name + \textcolor{charliteral}{'.'} + tag;
149   \}
150   \textcolor{keywordflow}{return} (dir + name + \textcolor{charliteral}{'.'} + ext);
151 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a351610c8df00514e8942756c2099fedc_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=349pt]{namespacelbann_a351610c8df00514e8942756c2099fedc_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a6084b9319eea1997f8446fa3e6879532}\label{namespacelbann_a6084b9319eea1997f8446fa3e6879532}} 
\index{lbann@{lbann}!openread@{openread}}
\index{openread@{openread}!lbann@{lbann}}
\subsubsection{\texorpdfstring{openread()}{openread()}}
{\footnotesize\ttfamily int lbann\+::openread (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Definition at line 98 of file file\+\_\+io.\+cpp.


\begin{DoxyCode}
98                                     \{
99   \textcolor{comment}{// open the file for writing}
100   \textcolor{keywordtype}{int} fd = open(file, O\_RDONLY);
101   \textcolor{keywordflow}{if} (fd == -1) \{
102   \}
103   \textcolor{keywordflow}{return} fd;
104 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a6084b9319eea1997f8446fa3e6879532_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_af596e6d2be603e9cf808c98f5412490a}\label{namespacelbann_af596e6d2be603e9cf808c98f5412490a}} 
\index{lbann@{lbann}!openwrite@{openwrite}}
\index{openwrite@{openwrite}!lbann@{lbann}}
\subsubsection{\texorpdfstring{openwrite()}{openwrite()}}
{\footnotesize\ttfamily int lbann\+::openwrite (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Definition at line 119 of file file\+\_\+io.\+cpp.


\begin{DoxyCode}
119                                      \{
120   \textcolor{comment}{// define mode (permissions) for new file}
121   mode\_t mode\_file = S\_IWUSR | S\_IRUSR | S\_IWGRP | S\_IRGRP;
122   \textcolor{comment}{// open the file for writing}
123   \textcolor{keywordtype}{int} fd = open(file, O\_WRONLY | O\_CREAT | O\_TRUNC, mode\_file);
124   \textcolor{keywordflow}{if} (fd == -1) \{
125     fprintf(stderr, \textcolor{stringliteral}{"ERROR: Failed to create file `%s' (%d: %s) @ %s:%d\(\backslash\)n"},
126             file, errno, strerror(errno), \_\_FILE\_\_, \_\_LINE\_\_
127            );
128     fflush(stderr);
129   \}
130   \textcolor{keywordflow}{return} fd;
131 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_af596e6d2be603e9cf808c98f5412490a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a1ce6832a54235a5fb333f50fffbe1b63}\label{namespacelbann_a1ce6832a54235a5fb333f50fffbe1b63}} 
\index{lbann@{lbann}!parse\+\_\+path@{parse\+\_\+path}}
\index{parse\+\_\+path@{parse\+\_\+path}!lbann@{lbann}}
\subsubsection{\texorpdfstring{parse\+\_\+path()}{parse\_path()}}
{\footnotesize\ttfamily bool lbann\+::parse\+\_\+path (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{path,  }\item[{std\+::string \&}]{dir,  }\item[{std\+::string \&}]{basename }\end{DoxyParamCaption})}



Divide a given path into dir and basename. 



Definition at line 71 of file file\+\_\+utils.\+cpp.


\begin{DoxyCode}
71                                                                             \{
72   std::string::const\_iterator nb =
73     std::find\_if(path.rbegin(), path.rend(), path\_delimiter()).base();
74   dir =  std::string(path.begin(), nb);
75   basename = std::string(nb, path.end());
76   \textcolor{keywordflow}{if} (basename.empty()) \{
77     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
78   \}
79 
80   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
81 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a1ce6832a54235a5fb333f50fffbe1b63_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a4fd83a86cf27ca7bc1e01576a5ee36e0}\label{namespacelbann_a4fd83a86cf27ca7bc1e01576a5ee36e0}} 
\index{lbann@{lbann}!print\+\_\+affinity@{print\+\_\+affinity}}
\index{print\+\_\+affinity@{print\+\_\+affinity}!lbann@{lbann}}
\subsubsection{\texorpdfstring{print\+\_\+affinity()}{print\_affinity()}}
{\footnotesize\ttfamily void lbann\+::print\+\_\+affinity (\begin{DoxyParamCaption}\item[{int}]{rank,  }\item[{int}]{np,  }\item[{char $\ast$}]{host }\end{DoxyParamCaption})}

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=318pt]{namespacelbann_a4fd83a86cf27ca7bc1e01576a5ee36e0_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_acbd15ead7411cf84db559cc39a82f445}\label{namespacelbann_acbd15ead7411cf84db559cc39a82f445}} 
\index{lbann@{lbann}!print\+\_\+affinity\+\_\+subset@{print\+\_\+affinity\+\_\+subset}}
\index{print\+\_\+affinity\+\_\+subset@{print\+\_\+affinity\+\_\+subset}!lbann@{lbann}}
\subsubsection{\texorpdfstring{print\+\_\+affinity\+\_\+subset()}{print\_affinity\_subset()}}
{\footnotesize\ttfamily void lbann\+::print\+\_\+affinity\+\_\+subset (\begin{DoxyParamCaption}\item[{int}]{rank,  }\item[{int}]{np,  }\item[{char $\ast$}]{host }\end{DoxyParamCaption})}

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=318pt]{namespacelbann_acbd15ead7411cf84db559cc39a82f445_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a85385e2a9e058b6720300b4cbdd2b1d0}\label{namespacelbann_a85385e2a9e058b6720300b4cbdd2b1d0}} 
\index{lbann@{lbann}!read\+\_\+bytes@{read\+\_\+bytes}}
\index{read\+\_\+bytes@{read\+\_\+bytes}!lbann@{lbann}}
\subsubsection{\texorpdfstring{read\+\_\+bytes()}{read\_bytes()}}
{\footnotesize\ttfamily bool lbann\+::read\+\_\+bytes (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{void $\ast$}]{buf,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Definition at line 647 of file persist.\+cpp.


\begin{DoxyCode}
647                                                                        \{
648   \textcolor{keywordflow}{if} (fd >= 0) \{
649     ssize\_t rc = read(fd, buf, size);
650     \textcolor{keywordflow}{if} (rc != (ssize\_t) size) \{
651       \textcolor{keywordflow}{throw} lbann\_exception(std::string(\textcolor{stringliteral}{"Failed to read: "}) + name);
652       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
653     \}
654   \}
655   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
656 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a85385e2a9e058b6720300b4cbdd2b1d0_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a0306ed35d6d90cf4fbdce7a72ad62ca7}\label{namespacelbann_a0306ed35d6d90cf4fbdce7a72ad62ca7}} 
\index{lbann@{lbann}!read\+\_\+distmat@{read\+\_\+distmat}}
\index{read\+\_\+distmat@{read\+\_\+distmat}!lbann@{lbann}}
\subsubsection{\texorpdfstring{read\+\_\+distmat()}{read\_distmat()}}
{\footnotesize\ttfamily bool lbann\+::read\+\_\+distmat (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{\hyperlink{base_8hpp_a0fab5387556805cfeac3e7e567bf66c5}{Dist\+Mat} $\ast$}]{M,  }\item[{uint64\+\_\+t $\ast$}]{bytes }\end{DoxyParamCaption})}



Definition at line 619 of file persist.\+cpp.


\begin{DoxyCode}
619                                                                               \{
620   \textcolor{comment}{// check whether file exists}
621   \textcolor{keywordtype}{int} \hyperlink{namespacelbann_aefae2a9fc9d742ece0fa8ca7ed9ee137}{exists} = \hyperlink{namespacelbann_aefae2a9fc9d742ece0fa8ca7ed9ee137}{lbann::exists}(name);
622   \textcolor{keywordflow}{if} (! exists) \{
623     \textcolor{keywordflow}{throw} lbann\_exception(std::string(\textcolor{stringliteral}{"Failed to read distmat: "}) + name);
624     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
625   \}
626 
627   Read(*M, name, El::BINARY, \textcolor{keyword}{true});
628   \textcolor{comment}{//Read\_MPI(M, name, BINARY, 1);}
629 
630   uint64\_t bytes\_read = 2 * \textcolor{keyword}{sizeof}(int) + M->Height() * M->Width() * \textcolor{keyword}{sizeof}(DataType);
631   *bytes += bytes\_read;
632 
633   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
634 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=291pt]{namespacelbann_a0306ed35d6d90cf4fbdce7a72ad62ca7_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a0306ed35d6d90cf4fbdce7a72ad62ca7_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a66f98f36cf54dca622f1186309961dd4}\label{namespacelbann_a66f98f36cf54dca622f1186309961dd4}} 
\index{lbann@{lbann}!read\+\_\+double@{read\+\_\+double}}
\index{read\+\_\+double@{read\+\_\+double}!lbann@{lbann}}
\subsubsection{\texorpdfstring{read\+\_\+double()}{read\_double()}}
{\footnotesize\ttfamily bool lbann\+::read\+\_\+double (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{double $\ast$}]{val }\end{DoxyParamCaption})}



Definition at line 696 of file persist.\+cpp.


\begin{DoxyCode}
696                                                              \{
697   \textcolor{keywordflow}{return} \hyperlink{namespacelbann_a85385e2a9e058b6720300b4cbdd2b1d0}{lbann::read\_bytes}(fd, name, val, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double}));
698 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=313pt]{namespacelbann_a66f98f36cf54dca622f1186309961dd4_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a66f98f36cf54dca622f1186309961dd4_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_acd0595f8c31773a3a46f477a83e4c0f3}\label{namespacelbann_acd0595f8c31773a3a46f477a83e4c0f3}} 
\index{lbann@{lbann}!read\+\_\+float@{read\+\_\+float}}
\index{read\+\_\+float@{read\+\_\+float}!lbann@{lbann}}
\subsubsection{\texorpdfstring{read\+\_\+float()}{read\_float()}}
{\footnotesize\ttfamily bool lbann\+::read\+\_\+float (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{float $\ast$}]{val }\end{DoxyParamCaption})}



Definition at line 688 of file persist.\+cpp.


\begin{DoxyCode}
688                                                            \{
689   \textcolor{keywordflow}{return} \hyperlink{namespacelbann_a85385e2a9e058b6720300b4cbdd2b1d0}{lbann::read\_bytes}(fd, name, val, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}));
690 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=302pt]{namespacelbann_acd0595f8c31773a3a46f477a83e4c0f3_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_acd0595f8c31773a3a46f477a83e4c0f3_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_acb5b0f1b30c9ab2fba700bb953515810}\label{namespacelbann_acb5b0f1b30c9ab2fba700bb953515810}} 
\index{lbann@{lbann}!read\+\_\+int32\+\_\+contig@{read\+\_\+int32\+\_\+contig}}
\index{read\+\_\+int32\+\_\+contig@{read\+\_\+int32\+\_\+contig}!lbann@{lbann}}
\subsubsection{\texorpdfstring{read\+\_\+int32\+\_\+contig()}{read\_int32\_contig()}}
{\footnotesize\ttfamily bool lbann\+::read\+\_\+int32\+\_\+contig (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{int32\+\_\+t $\ast$}]{buf,  }\item[{uint64\+\_\+t}]{count }\end{DoxyParamCaption})}



Definition at line 679 of file persist.\+cpp.


\begin{DoxyCode}
679                                                                                     \{
680   \textcolor{keywordtype}{size\_t} bytes = count * \textcolor{keyword}{sizeof}(int32\_t);
681   \textcolor{keywordflow}{return} \hyperlink{namespacelbann_a85385e2a9e058b6720300b4cbdd2b1d0}{lbann::read\_bytes}(fd, name, buf, bytes);
682 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=337pt]{namespacelbann_acb5b0f1b30c9ab2fba700bb953515810_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_acb5b0f1b30c9ab2fba700bb953515810_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_abebab8298e56db6a455a9ed08ab42bb4}\label{namespacelbann_abebab8298e56db6a455a9ed08ab42bb4}} 
\index{lbann@{lbann}!read\+\_\+latest@{read\+\_\+latest}}
\index{read\+\_\+latest@{read\+\_\+latest}!lbann@{lbann}}
\subsubsection{\texorpdfstring{read\+\_\+latest()}{read\_latest()}}
{\footnotesize\ttfamily static bool lbann\+::read\+\_\+latest (\begin{DoxyParamCaption}\item[{const char $\ast$}]{dir,  }\item[{const char $\ast$}]{name,  }\item[{int $\ast$}]{epoch\+Last,  }\item[{int $\ast$}]{train\+Last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Reads the \char`\"{}latest\char`\"{} file and returns the epoch number and sample offset for most recent checkpoint. 



Definition at line 124 of file callback\+\_\+checkpoint.\+cpp.


\begin{DoxyCode}
124                                                                                            \{
125   \textcolor{comment}{// assume we don't have a file, we'll return -1 in that case}
126   *epochLast = -1;
127   *trainLast = -1;
128   \textcolor{comment}{// define filename}
129   \textcolor{keywordtype}{char} filename[1024];
130   sprintf(filename, \textcolor{stringliteral}{"%s/%s"}, dir, name);
131   \textcolor{comment}{// open the file for reading}
132   \textcolor{keywordtype}{int} fd = \hyperlink{namespacelbann_a6084b9319eea1997f8446fa3e6879532}{openread}(filename);
133   \textcolor{keywordflow}{if} (fd != -1) \{
134     \textcolor{comment}{// read epoch from file}
135     \textcolor{keywordtype}{char} field[256];
136     \hyperlink{namespacelbann_a784843ebce0e596dba31c1d981a7f087}{read\_string}(fd, \textcolor{stringliteral}{"shared.last"}, field, \textcolor{keyword}{sizeof}(field));
137     \textcolor{keywordtype}{int} ret = sscanf(field, \textcolor{stringliteral}{"epoch=%d step=%d\(\backslash\)n"}, epochLast, trainLast);
138     \textcolor{comment}{// close our file}
139     \hyperlink{namespacelbann_a38dd30b2ae8214f6595708264369ddb8}{closeread}(fd, filename);
140     \textcolor{keywordflow}{if}(ret != 2) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}
141   \}
142   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
143 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=308pt]{namespacelbann_abebab8298e56db6a455a9ed08ab42bb4_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_abebab8298e56db6a455a9ed08ab42bb4_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a784843ebce0e596dba31c1d981a7f087}\label{namespacelbann_a784843ebce0e596dba31c1d981a7f087}} 
\index{lbann@{lbann}!read\+\_\+string@{read\+\_\+string}}
\index{read\+\_\+string@{read\+\_\+string}!lbann@{lbann}}
\subsubsection{\texorpdfstring{read\+\_\+string()}{read\_string()}}
{\footnotesize\ttfamily bool lbann\+::read\+\_\+string (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{char $\ast$}]{buf,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Definition at line 711 of file persist.\+cpp.


\begin{DoxyCode}
711                                                                         \{
712   \textcolor{keywordflow}{if} (fd > 0) \{
713     ssize\_t rc = read(fd, buf, size);
714     \textcolor{keywordflow}{if} (rc <= 0) \{
715       \textcolor{keywordflow}{throw} lbann\_exception(std::string(\textcolor{stringliteral}{"Failed to read: "}) + name);
716       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
717     \}
718   \}
719   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
720 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a784843ebce0e596dba31c1d981a7f087_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_aedcde4d93c4feb5090c927de1c45b90d}\label{namespacelbann_aedcde4d93c4feb5090c927de1c45b90d}} 
\index{lbann@{lbann}!read\+\_\+uint32@{read\+\_\+uint32}}
\index{read\+\_\+uint32@{read\+\_\+uint32}!lbann@{lbann}}
\subsubsection{\texorpdfstring{read\+\_\+uint32()}{read\_uint32()}}
{\footnotesize\ttfamily bool lbann\+::read\+\_\+uint32 (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{uint32\+\_\+t $\ast$}]{val }\end{DoxyParamCaption})}



Definition at line 662 of file persist.\+cpp.


\begin{DoxyCode}
662                                                                \{
663   \textcolor{keywordflow}{return} \hyperlink{namespacelbann_a85385e2a9e058b6720300b4cbdd2b1d0}{lbann::read\_bytes}(fd, name, val, \textcolor{keyword}{sizeof}(uint32\_t));
664 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=310pt]{namespacelbann_aedcde4d93c4feb5090c927de1c45b90d_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_aedcde4d93c4feb5090c927de1c45b90d_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a7ca20ac4f0ec9feaa2f6d5b6ef3c8865}\label{namespacelbann_a7ca20ac4f0ec9feaa2f6d5b6ef3c8865}} 
\index{lbann@{lbann}!read\+\_\+uint64@{read\+\_\+uint64}}
\index{read\+\_\+uint64@{read\+\_\+uint64}!lbann@{lbann}}
\subsubsection{\texorpdfstring{read\+\_\+uint64()}{read\_uint64()}}
{\footnotesize\ttfamily bool lbann\+::read\+\_\+uint64 (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{uint64\+\_\+t $\ast$}]{val }\end{DoxyParamCaption})}



Definition at line 670 of file persist.\+cpp.


\begin{DoxyCode}
670                                                                \{
671   \textcolor{keywordflow}{return} \hyperlink{namespacelbann_a85385e2a9e058b6720300b4cbdd2b1d0}{lbann::read\_bytes}(fd, name, val, \textcolor{keyword}{sizeof}(uint64\_t));
672 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=310pt]{namespacelbann_a7ca20ac4f0ec9feaa2f6d5b6ef3c8865_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a7ca20ac4f0ec9feaa2f6d5b6ef3c8865_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_ab2c2ad3c98b9991a6307b123617dbfb2}\label{namespacelbann_ab2c2ad3c98b9991a6307b123617dbfb2}} 
\index{lbann@{lbann}!read\+Dist@{read\+Dist}}
\index{read\+Dist@{read\+Dist}!lbann@{lbann}}
\subsubsection{\texorpdfstring{read\+Dist()}{readDist()}}
{\footnotesize\ttfamily bool lbann\+::read\+Dist (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{filename,  }\item[{\hyperlink{base_8hpp_a0fab5387556805cfeac3e7e567bf66c5}{Dist\+Mat} \&}]{M,  }\item[{uint64\+\_\+t $\ast$}]{bytes }\end{DoxyParamCaption})}



Given an open file descriptor, file name, and a matrix, read the matrix from the file descriptor, return the number of bytes read. 



Definition at line 119 of file persist.\+cpp.


\begin{DoxyCode}
119                                                                               \{
120   \textcolor{comment}{// read in the header}
121   \textcolor{keyword}{struct }\hyperlink{structlayer__header}{layer\_header} header;
122   ssize\_t read\_rc = read(fd, &header, \textcolor{keyword}{sizeof}(header));
123   \textcolor{keywordflow}{if} (read\_rc != \textcolor{keyword}{sizeof}(header)) \{
124     \textcolor{comment}{// error!}
125     \textcolor{keywordflow}{throw} lbann\_exception(\textcolor{stringliteral}{"Failed to read layer header"});
126   \}
127   *bytes += read\_rc;
128 
129   \textcolor{comment}{// resize our global matrix}
130   El::Int \hyperlink{structlayer__header_ad986e4b92e5b455e066fd349725c6bd9}{height} = header.height;
131   El::Int \hyperlink{structlayer__header_af1f45c9c74db048ea424114418f22d50}{width}  = header.width;
132   M.Resize(height, width);
133 
134   \textcolor{comment}{// TODO: check that header values match up}
135 
136   \textcolor{keywordflow}{if}(M.ColStride() == 1 && M.RowStride() == 1) \{
137     \textcolor{keywordflow}{if}(M.Height() == M.LDim()) \{
138       \textcolor{keyword}{auto} *buf = (\textcolor{keywordtype}{void} *) M.Buffer();
139       El::Int bufsize = height * width * \textcolor{keyword}{sizeof}(DataType);
140       read\_rc = read(fd, buf, bufsize);
141       \textcolor{keywordflow}{if} (read\_rc != bufsize) \{
142         \textcolor{comment}{// error!}
143         \textcolor{keywordflow}{throw} lbann\_exception(\textcolor{stringliteral}{"Failed to read layer data"});
144       \}
145       *bytes += read\_rc;
146     \} \textcolor{keywordflow}{else} \{
147       \textcolor{keywordflow}{for}(El::Int j = 0; j < \hyperlink{structlayer__header_af1f45c9c74db048ea424114418f22d50}{width}; ++j) \{
148         \textcolor{keyword}{auto} *buf = (\textcolor{keywordtype}{void} *) M.Buffer(0, j);
149         El::Int bufsize = height * \textcolor{keyword}{sizeof}(DataType);
150         read\_rc = read(fd, buf, bufsize);
151         \textcolor{keywordflow}{if} (read\_rc != bufsize) \{
152           \textcolor{comment}{// error!}
153           \textcolor{keywordflow}{throw} lbann\_exception(\textcolor{stringliteral}{"Failed to read layer data"});
154         \}
155         *bytes += read\_rc;
156       \}
157     \}
158   \} \textcolor{keywordflow}{else} \{
159     \textcolor{keyword}{const} El::Int localHeight = M.LocalHeight();
160     \textcolor{keyword}{const} El::Int localWidth = M.LocalWidth();
161     \textcolor{keyword}{const} El::Int lDim = M.LDim();
162     \textcolor{keywordflow}{if}(localHeight == lDim) \{
163       \textcolor{keyword}{auto} *buf = (\textcolor{keywordtype}{void} *) M.Buffer();
164       El::Int bufsize = localHeight * localWidth * \textcolor{keyword}{sizeof}(DataType);
165       read\_rc = read(fd, buf, bufsize);
166       \textcolor{keywordflow}{if} (read\_rc != bufsize) \{
167         \textcolor{comment}{// error!}
168         \textcolor{keywordflow}{throw} lbann\_exception(\textcolor{stringliteral}{"Failed to read layer data"});
169       \}
170       *bytes += read\_rc;
171     \} \textcolor{keywordflow}{else} \{
172       \textcolor{keywordflow}{for}(El::Int jLoc = 0; jLoc < localWidth; ++jLoc) \{
173         \textcolor{keyword}{auto} *buf = (\textcolor{keywordtype}{void} *) M.Buffer(0, jLoc);
174         El::Int bufsize = localHeight * \textcolor{keyword}{sizeof}(DataType);
175         read\_rc = read(fd, buf, bufsize);
176         \textcolor{keywordflow}{if} (read\_rc != bufsize) \{
177           \textcolor{comment}{// error!}
178           \textcolor{keywordflow}{throw} lbann\_exception(\textcolor{stringliteral}{"Failed to read layer data"});
179         \}
180         *bytes += read\_rc;
181       \}
182     \}
183   \}
184   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
185 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_ab2c2ad3c98b9991a6307b123617dbfb2_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a481f0c268c74d3ec8b81861472559870}\label{namespacelbann_a481f0c268c74d3ec8b81861472559870}} 
\index{lbann@{lbann}!rng\+\_\+bernoulli@{rng\+\_\+bernoulli}}
\index{rng\+\_\+bernoulli@{rng\+\_\+bernoulli}!lbann@{lbann}}
\subsubsection{\texorpdfstring{rng\+\_\+bernoulli()}{rng\_bernoulli()}}
{\footnotesize\ttfamily template$<$typename D\+Type  = Data\+Type$>$ \\
void lbann\+::rng\+\_\+bernoulli (\begin{DoxyParamCaption}\item[{const float}]{p,  }\item[{\hyperlink{base_8hpp_a0fab5387556805cfeac3e7e567bf66c5}{Dist\+Mat} $\ast$}]{m }\end{DoxyParamCaption})}

Multiply entries of distributed matrix with a multiplier generated according to bernoulli\+\_\+distribution the scale for undropped inputs at training time given as $ 1 / (1 - p) $ 

Definition at line 183 of file random.\+hpp.


\begin{DoxyCode}
183                                               \{
184 
186   \textcolor{keywordtype}{float} scale = 1. / (1. - p);
187 
188   \textcolor{comment}{//@todo: use seed from parameter}
189   rng<std::bernoulli\_distribution,DType> myrn(p); \textcolor{comment}{//magic seed?}
190 
191   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} row = 0; row < m->LocalHeight(); ++row) \{
192     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} col = 0; col < m->LocalWidth(); ++col) \{
193       m->Set(row,col,myrn.gen()*scale); \textcolor{comment}{//SetLocal?}
194     \}
195   \}
196 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a481f0c268c74d3ec8b81861472559870_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a0c713b77f8e191addc1e0210037f9e5f}\label{namespacelbann_a0c713b77f8e191addc1e0210037f9e5f}} 
\index{lbann@{lbann}!rowwise\+\_\+mean\+\_\+and\+\_\+stdev@{rowwise\+\_\+mean\+\_\+and\+\_\+stdev}}
\index{rowwise\+\_\+mean\+\_\+and\+\_\+stdev@{rowwise\+\_\+mean\+\_\+and\+\_\+stdev}!lbann@{lbann}}
\subsubsection{\texorpdfstring{rowwise\+\_\+mean\+\_\+and\+\_\+stdev()}{rowwise\_mean\_and\_stdev()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void lbann\+::rowwise\+\_\+mean\+\_\+and\+\_\+stdev (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{data,  }\item[{\hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{means,  }\item[{\hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{stdevs }\end{DoxyParamCaption})}



Compute row-\/wise means and standard deviations. 


\begin{DoxyParams}{Parameters}
{\em data} & Input matrix. \\
\hline
{\em means} & Mean vector. Output as a column vector with same number of rows as \textquotesingle{}data\textquotesingle{}. \\
\hline
{\em stdevs} & Standard deviation vector. Output as a column vector with same number of rows as \textquotesingle{}data\textquotesingle{}. \\
\hline
\end{DoxyParams}


Definition at line 218 of file statistics.\+cpp.


\begin{DoxyCode}
220                                          \{
221 
222   \textcolor{comment}{// Matrix dimensions}
223   \textcolor{keyword}{const} El::Int \hyperlink{structlayer__header_ad986e4b92e5b455e066fd349725c6bd9}{height} = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.Height();
224   \textcolor{keyword}{const} El::Int \hyperlink{structlayer__header_af1f45c9c74db048ea424114418f22d50}{width} = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.Width();
225 
226   \textcolor{comment}{// Initialize outputs}
227   means.Resize(height, 1);
228   stdevs.Resize(height, 1);
229 
230   \textcolor{comment}{// Iterate through row blocks}
231   \textcolor{keyword}{const} El::Int block\_size = 16;
232 \textcolor{preprocessor}{  #pragma omp parallel for}
233   \textcolor{keywordflow}{for}(El::Int row\_start = 0; row\_start < \hyperlink{structlayer__header_ad986e4b92e5b455e066fd349725c6bd9}{height}; row\_start += block\_size) \{
234     \textcolor{keyword}{const} El::Int row\_end = std::min(row\_start + block\_size, height);
235 
236     \textcolor{comment}{// Initialize shift and sums for each row}
237     \textcolor{keyword}{auto} *shifts = \textcolor{keyword}{new} DataType[block\_size];
238     \textcolor{keywordflow}{for}(El::Int row = row\_start; row < row\_end; ++row) \{
239       means(row, 0) = 0;
240       stdevs(row, 0) = 0;
241       shifts[row-row\_start] = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}(row, 0);
242     \}
243 
244     \textcolor{comment}{// Iterate through blocks in row block}
245     \textcolor{keywordflow}{for}(El::Int col\_start = 0; col\_start < \hyperlink{structlayer__header_af1f45c9c74db048ea424114418f22d50}{width}; col\_start += block\_size) \{
246       \textcolor{keyword}{const} El::Int col\_end = std::min(col\_start + block\_size, width);
247 
248       \textcolor{comment}{// Compute sums by iterating through block entries}
249       \textcolor{keywordflow}{for}(El::Int col = col\_start; col < col\_end; ++col) \{
250         \textcolor{keywordflow}{for}(El::Int row = row\_start; row < row\_end; ++row) \{
251           \textcolor{keyword}{const} DataType shift = shifts[row - row\_start];
252           \textcolor{keyword}{const} DataType shifted\_val = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}(row, col) - shift;
253           means(row, 0) += shifted\_val;
254           stdevs(row, 0) += shifted\_val * shifted\_val;
255         \}
256       \}
257 
258     \}
259 
260     \textcolor{comment}{// Compute mean and standard deviation of each row}
261     \textcolor{keywordflow}{for}(El::Int row = row\_start; row < row\_end; ++row) \{
262       \textcolor{keyword}{const} DataType shifted\_mean = means(row, 0) / \hyperlink{structlayer__header_af1f45c9c74db048ea424114418f22d50}{width};
263       \textcolor{keyword}{const} DataType shifted\_sqmean = stdevs(row, 0) / \hyperlink{structlayer__header_af1f45c9c74db048ea424114418f22d50}{width};
264       \textcolor{keyword}{const} DataType mean = shifted\_mean + shifts[row - row\_start];
265       \textcolor{keyword}{const} DataType var = std::max(shifted\_sqmean - shifted\_mean * shifted\_mean,
266                                     DataType(0));
267       \textcolor{keyword}{const} DataType stdev = std::sqrt(var);
268       means(row, 0) = mean;
269       stdevs(row, 0) = stdev;
270     \}
271 
272     \textcolor{comment}{// Deallocate shifts}
273     \textcolor{keyword}{delete}[] shifts;
274 
275   \}
276 
277 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a0c713b77f8e191addc1e0210037f9e5f_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a9b1fd2f864f421aa0bd9f8582ad87c14}\label{namespacelbann_a9b1fd2f864f421aa0bd9f8582ad87c14}} 
\index{lbann@{lbann}!rowwise\+\_\+mean\+\_\+and\+\_\+stdev@{rowwise\+\_\+mean\+\_\+and\+\_\+stdev}}
\index{rowwise\+\_\+mean\+\_\+and\+\_\+stdev@{rowwise\+\_\+mean\+\_\+and\+\_\+stdev}!lbann@{lbann}}
\subsubsection{\texorpdfstring{rowwise\+\_\+mean\+\_\+and\+\_\+stdev()}{rowwise\_mean\_and\_stdev()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void lbann\+::rowwise\+\_\+mean\+\_\+and\+\_\+stdev (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{data,  }\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{means,  }\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{stdevs }\end{DoxyParamCaption})}



Compute row-\/wise means and standard deviations. 

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000010}{Todo}]Numerically stable implementation \end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em data} & Input matrix in U,V format. \\
\hline
{\em means} & Mean vector in U,S\+T\+AR format. Output as a column vector with same number of rows as \textquotesingle{}data\textquotesingle{}. \\
\hline
{\em stdevs} & Standard deviation vector in U,S\+T\+AR format. Output as a column vector with same number of rows as \textquotesingle{}data\textquotesingle{}. \\
\hline
\end{DoxyParams}


Definition at line 338 of file statistics.\+cpp.


\begin{DoxyCode}
340                                                 \{
341 
342   
343   \textcolor{keyword}{const} El::Int \hyperlink{structlayer__header_af1f45c9c74db048ea424114418f22d50}{width} = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.Width();
344   \textcolor{keyword}{const} El::Int local\_height = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.LocalHeight();
345 
346   \hyperlink{namespacelbann_a6b342b3e5b3fbb08b97b6d90aa68d121}{rowwise\_sums\_and\_sqsums}(\hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}, means, stdevs);
347   
348   \textcolor{comment}{// Local matrices}
349   \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_means = means.Matrix();
350   \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_stdevs = stdevs.Matrix();
351   
352   \textcolor{comment}{// Compute mean and standard deviation of each matrix row}
353 \textcolor{preprocessor}{  #pragma omp parallel for}
354   \textcolor{keywordflow}{for}(El::Int row = 0; row < local\_height; ++row) \{
355     \textcolor{keyword}{const} DataType mean = local\_means(row, 0) / \hyperlink{structlayer__header_af1f45c9c74db048ea424114418f22d50}{width};
356     \textcolor{keyword}{const} DataType sqmean = local\_stdevs(row, 0) / \hyperlink{structlayer__header_af1f45c9c74db048ea424114418f22d50}{width};
357     \textcolor{keyword}{const} DataType var = std::max(sqmean - mean * mean, DataType(0));
358     \textcolor{keyword}{const} DataType stdev = std::sqrt(var);
359     local\_means(row, 0) = mean;
360     local\_stdevs(row, 0) = stdev;
361   \}
362 
363 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=340pt]{namespacelbann_a9b1fd2f864f421aa0bd9f8582ad87c14_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a6b342b3e5b3fbb08b97b6d90aa68d121}\label{namespacelbann_a6b342b3e5b3fbb08b97b6d90aa68d121}} 
\index{lbann@{lbann}!rowwise\+\_\+sums\+\_\+and\+\_\+sqsums@{rowwise\+\_\+sums\+\_\+and\+\_\+sqsums}}
\index{rowwise\+\_\+sums\+\_\+and\+\_\+sqsums@{rowwise\+\_\+sums\+\_\+and\+\_\+sqsums}!lbann@{lbann}}
\subsubsection{\texorpdfstring{rowwise\+\_\+sums\+\_\+and\+\_\+sqsums()}{rowwise\_sums\_and\_sqsums()}}
{\footnotesize\ttfamily void lbann\+::rowwise\+\_\+sums\+\_\+and\+\_\+sqsums (\begin{DoxyParamCaption}\item[{const \hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{data,  }\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{sums,  }\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{sqsums }\end{DoxyParamCaption})}



Compute row-\/wise sum and sum of squares. 

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000009}{Todo}]Numerically stable implementation \end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em data} & Input matrix in U,V format. \\
\hline
{\em sum} & Sum vector in U,S\+T\+AR format. Output as a column vector with same number of rows as \textquotesingle{}data\textquotesingle{}. \\
\hline
{\em sqsum} & Sum of squared in U,S\+T\+AR format. Output as a column vector with same number of rows as \textquotesingle{}data\textquotesingle{}. \\
\hline
\end{DoxyParams}


Definition at line 280 of file statistics.\+cpp.


\begin{DoxyCode}
282                                                 \{
283 
284 \textcolor{preprocessor}{#ifdef LBANN\_DEBUG}
285   El::DistData data\_dist(\hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}), sum\_dist(sums), sqsum\_dist(sqsums);
286   \textcolor{keywordflow}{if}(sum\_dist.colDist != data\_dist.colDist
287       || sum\_dist.rowDist != El::STAR
288       || sqsum\_dist.colDist != data\_dist.colDist
289       || sqsum\_dist.rowDist != El::STAR) \{
290     \textcolor{keywordflow}{throw} lbann\_exception(\textcolor{stringliteral}{"rowwise\_sums\_and\_sqsums: invalid matrix format"});
291   \}
292 \textcolor{preprocessor}{#endif // #ifdef LBANN\_DEBUG}
293 
294   \textcolor{comment}{// Matrix dimensions}
295   \textcolor{keyword}{const} El::Int \hyperlink{structlayer__header_ad986e4b92e5b455e066fd349725c6bd9}{height} = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.Height();
296   \textcolor{keyword}{const} El::Int local\_height = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.LocalHeight();
297   \textcolor{keyword}{const} El::Int local\_width = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.LocalWidth();
298 
299   \textcolor{comment}{// Initialize outputs}
300   sums.Resize(height, 1);
301   sqsums.Resize(height, 1);
302 
303   \textcolor{comment}{// Local matrices}
304   \textcolor{keyword}{const} \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_data = \hyperlink{namespacelbann_1_1cnpy__utils_a9ac86d96ccb1f8b4b2ea16441738781f}{data}.LockedMatrix();
305   \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_sum = sums.Matrix();
306   \hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat}& local\_sqsum = sqsums.Matrix();
307 
308   \textcolor{comment}{// Iterate through row blocks}
309   \textcolor{keyword}{const} El::Int block\_size = 16;
310 \textcolor{preprocessor}{  #pragma omp parallel for}
311   \textcolor{keywordflow}{for}(El::Int row\_start = 0; row\_start < local\_height; row\_start += block\_size) \{
312     \textcolor{keyword}{const} El::Int row\_end = std::min(row\_start + block\_size, local\_height);
313 
314     \textcolor{comment}{// Iterate through blocks in row block}
315     \textcolor{keywordflow}{for}(El::Int col\_start = 0; col\_start < local\_width; col\_start += block\_size) \{
316       \textcolor{keyword}{const} El::Int col\_end = std::min(col\_start + block\_size, local\_width);
317 
318       \textcolor{comment}{// Compute sums by iterating through block entries}
319       \textcolor{keywordflow}{for}(El::Int col = col\_start; col < col\_end; ++col) \{
320         \textcolor{keywordflow}{for}(El::Int row = row\_start; row < row\_end; ++row) \{
321           \textcolor{keyword}{const} DataType val = local\_data(row, col);
322           local\_sum(row, 0) += val;
323           local\_sqsum(row, 0) += val * val;
324         \}
325       \}
326 
327     \}
328 
329   \}
330 
331   \textcolor{comment}{// Allreduce sums and sums of squares}
332   AllReduce(sums, sums.RedundantComm(), El::mpi::SUM);
333   AllReduce(sqsums, sqsums.RedundantComm(), El::mpi::SUM);
334 
335 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=340pt]{namespacelbann_a6b342b3e5b3fbb08b97b6d90aa68d121_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_af68acf5b249e5360289d4c6a7bfa8985}\label{namespacelbann_af68acf5b249e5360289d4c6a7bfa8985}} 
\index{lbann@{lbann}!save\+\_\+rng\+\_\+to\+\_\+checkpoint\+\_\+shared@{save\+\_\+rng\+\_\+to\+\_\+checkpoint\+\_\+shared}}
\index{save\+\_\+rng\+\_\+to\+\_\+checkpoint\+\_\+shared@{save\+\_\+rng\+\_\+to\+\_\+checkpoint\+\_\+shared}!lbann@{lbann}}
\subsubsection{\texorpdfstring{save\+\_\+rng\+\_\+to\+\_\+checkpoint\+\_\+shared()}{save\_rng\_to\_checkpoint\_shared()}}
{\footnotesize\ttfamily bool lbann\+::save\+\_\+rng\+\_\+to\+\_\+checkpoint\+\_\+shared (\begin{DoxyParamCaption}\item[{\hyperlink{classlbann_1_1persist}{persist} \&}]{p }\end{DoxyParamCaption})}



Definition at line 72 of file random.\+cpp.


\begin{DoxyCode}
72                                               \{
73   std::string rng\_name;
74   rng\_name = std::string(p.m\_checkpoint\_dir) + \textcolor{stringliteral}{"/rng\_seq\_generator"};
75   std::ofstream rng\_seq(rng\_name);
76   rng\_seq << \hyperlink{namespaceanonymous__namespace_02random_8cpp_03_ac1d3d0259f3e9c9b75e9701ae727d16e}{::data\_seq\_generator};
77   
78   rng\_name = std::string(p.m\_checkpoint\_dir) + \textcolor{stringliteral}{"/rng\_generator"};
79   std::ofstream rng(rng\_name);
80   rng << \hyperlink{namespaceanonymous__namespace_02random_8cpp_03_a83826c4b587d1825f13b833be6fe047f}{::generator};
81   
82   rng\_name = std::string(p.m\_checkpoint\_dir) + \textcolor{stringliteral}{"/rng\_fast\_generator"};
83   std::ofstream rng\_fast(rng\_name);
84   rng\_fast << \hyperlink{namespaceanonymous__namespace_02random_8cpp_03_a349f572cec05cd0e2469b799774a8602}{::fast\_generator};
85 
86   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
87 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_af68acf5b249e5360289d4c6a7bfa8985_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a93facff1f3ce4e10e5d25cf80077fb93}\label{namespacelbann_a93facff1f3ce4e10e5d25cf80077fb93}} 
\index{lbann@{lbann}!set\+\_\+minibatch\+\_\+item@{set\+\_\+minibatch\+\_\+item}}
\index{set\+\_\+minibatch\+\_\+item@{set\+\_\+minibatch\+\_\+item}!lbann@{lbann}}
\subsubsection{\texorpdfstring{set\+\_\+minibatch\+\_\+item()}{set\_minibatch\_item()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void lbann\+::set\+\_\+minibatch\+\_\+item (\begin{DoxyParamCaption}\item[{\hyperlink{base_8hpp_a68f11fdc31b62516cb310831bbe54d73}{Mat} \&}]{M,  }\item[{const int}]{mb\+\_\+idx,  }\item[{const T $\ast$const}]{ptr,  }\item[{const size\+\_\+t}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 185 of file data\+\_\+reader\+\_\+jag.\+hpp.


\begin{DoxyCode}
185                                                                                                  \{
186   \textcolor{keywordflow}{if} ((count > 0u) && (ptr == \textcolor{keyword}{nullptr})) \{
187     \textcolor{keywordflow}{throw} lbann\_exception(std::string\{\} + \_\_FILE\_\_ + \textcolor{stringliteral}{" "} + std::to\_string(\_\_LINE\_\_) +
188                           \textcolor{stringliteral}{" :: attempt to dereference a nullptr "});
189   \}
190   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0u; i < count; ++i) \{
191     M.Set(static\_cast<El::Int>(i), static\_cast<El::Int>(mb\_idx), static\_cast<DataType>(ptr[i]));
192   \}
193 \}
\end{DoxyCode}
\mbox{\Hypertarget{namespacelbann_a31acedf53bb67180043939832c0220d3}\label{namespacelbann_a31acedf53bb67180043939832c0220d3}} 
\index{lbann@{lbann}!th\+\_\+print\+\_\+affinity@{th\+\_\+print\+\_\+affinity}}
\index{th\+\_\+print\+\_\+affinity@{th\+\_\+print\+\_\+affinity}!lbann@{lbann}}
\subsubsection{\texorpdfstring{th\+\_\+print\+\_\+affinity()}{th\_print\_affinity()}}
{\footnotesize\ttfamily void lbann\+::th\+\_\+print\+\_\+affinity (\begin{DoxyParamCaption}\item[{int}]{rank,  }\item[{int}]{np,  }\item[{char $\ast$}]{host }\end{DoxyParamCaption})}

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=332pt]{namespacelbann_a31acedf53bb67180043939832c0220d3_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a7336c565aa23c1dab784530c581db3d1}\label{namespacelbann_a7336c565aa23c1dab784530c581db3d1}} 
\index{lbann@{lbann}!uniform\+\_\+fill@{uniform\+\_\+fill}}
\index{uniform\+\_\+fill@{uniform\+\_\+fill}!lbann@{lbann}}
\subsubsection{\texorpdfstring{uniform\+\_\+fill()}{uniform\_fill()}}
{\footnotesize\ttfamily void lbann\+::uniform\+\_\+fill (\begin{DoxyParamCaption}\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{mat,  }\item[{El\+::\+Int}]{m,  }\item[{El\+::\+Int}]{n,  }\item[{Data\+Type}]{center = {\ttfamily 0.0f},  }\item[{Data\+Type}]{radius = {\ttfamily 1.0f} }\end{DoxyParamCaption})}

Make mat into an m x n matrix where each entry is independently uniformly sampled from a ball with the given center and radius. This makes the same guarantees as gaussian\+\_\+fill. 

Definition at line 183 of file random.\+cpp.


\begin{DoxyCode}
184                                    \{
185 \textcolor{preprocessor}{#ifdef LBANN\_PARALLEL\_RANDOM\_MATRICES}
186   El::Uniform(mat, m, n, center, radius);
187 \textcolor{preprocessor}{#else}
188   \hyperlink{namespacelbann_a93fc1b42be6ab461e803cb48d58c4d81}{uniform\_fill\_procdet}(mat, m, n, center, radius);
189 \textcolor{preprocessor}{#endif  // LBANN\_PARALLEL\_RANDOM\_MATRICES}
190 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a7336c565aa23c1dab784530c581db3d1_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a7336c565aa23c1dab784530c581db3d1_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a93fc1b42be6ab461e803cb48d58c4d81}\label{namespacelbann_a93fc1b42be6ab461e803cb48d58c4d81}} 
\index{lbann@{lbann}!uniform\+\_\+fill\+\_\+procdet@{uniform\+\_\+fill\+\_\+procdet}}
\index{uniform\+\_\+fill\+\_\+procdet@{uniform\+\_\+fill\+\_\+procdet}!lbann@{lbann}}
\subsubsection{\texorpdfstring{uniform\+\_\+fill\+\_\+procdet()}{uniform\_fill\_procdet()}}
{\footnotesize\ttfamily void lbann\+::uniform\+\_\+fill\+\_\+procdet (\begin{DoxyParamCaption}\item[{\hyperlink{base_8hpp_a9a697a504ae84010e7439ffec862b470}{Abs\+Dist\+Mat} \&}]{mat,  }\item[{El\+::\+Int}]{m,  }\item[{El\+::\+Int}]{n,  }\item[{Data\+Type}]{center = {\ttfamily 0.0f},  }\item[{Data\+Type}]{radius = {\ttfamily 1.0f} }\end{DoxyParamCaption})}

Make mat into an m x n matrix where each entry is independently uniformly sampled from a ball with the given center and radius. This makes the same guarantees as gaussian\+\_\+fill\+\_\+procdet. 

Definition at line 223 of file random.\+cpp.


\begin{DoxyCode}
224                                            \{
225   El::Zeros(mat, m, n);
226   \textcolor{keywordflow}{if} (mat.Grid().Rank() == 0) \{
227     mat.Reserve(n * m);
228     \textcolor{keyword}{auto}& gen = \hyperlink{namespacelbann_a4fea7ba21017b49d1e34394b4c20c764}{get\_generator}();
229     std::uniform\_real\_distribution<DataType> dist(center - radius,
230         center + radius);
231     \textcolor{keywordflow}{for} (El::Int col = 0; col < n; ++col) \{
232       \textcolor{keywordflow}{for} (El::Int row = 0; row < m; ++row) \{
233         mat.QueueUpdate(row, col, dist(gen));
234       \}
235     \}
236   \}
237   mat.ProcessQueues();
238 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=319pt]{namespacelbann_a93fc1b42be6ab461e803cb48d58c4d81_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a93fc1b42be6ab461e803cb48d58c4d81_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_aed95061796f19fa1648dcc99dc335abd}\label{namespacelbann_aed95061796f19fa1648dcc99dc335abd}} 
\index{lbann@{lbann}!write\+\_\+bytes@{write\+\_\+bytes}}
\index{write\+\_\+bytes@{write\+\_\+bytes}!lbann@{lbann}}
\subsubsection{\texorpdfstring{write\+\_\+bytes()}{write\_bytes()}}
{\footnotesize\ttfamily bool lbann\+::write\+\_\+bytes (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{const void $\ast$}]{buf,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Definition at line 636 of file persist.\+cpp.


\begin{DoxyCode}
636                                                                               \{
637   \textcolor{keywordflow}{if} (fd >= 0) \{
638     ssize\_t rc = write(fd, buf, size);
639     \textcolor{keywordflow}{if} (rc != (ssize\_t) size) \{
640       \textcolor{keywordflow}{throw} lbann\_exception(std::string(\textcolor{stringliteral}{"Failed to write: "}) + name);
641       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
642     \}
643   \}
644   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
645 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_aed95061796f19fa1648dcc99dc335abd_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_aa7b4e710f444588dfcf4188b84b33420}\label{namespacelbann_aa7b4e710f444588dfcf4188b84b33420}} 
\index{lbann@{lbann}!write\+\_\+distmat@{write\+\_\+distmat}}
\index{write\+\_\+distmat@{write\+\_\+distmat}!lbann@{lbann}}
\subsubsection{\texorpdfstring{write\+\_\+distmat()}{write\_distmat()}}
{\footnotesize\ttfamily bool lbann\+::write\+\_\+distmat (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{\hyperlink{base_8hpp_a0fab5387556805cfeac3e7e567bf66c5}{Dist\+Mat} $\ast$}]{M,  }\item[{uint64\+\_\+t $\ast$}]{bytes }\end{DoxyParamCaption})}



Definition at line 609 of file persist.\+cpp.


\begin{DoxyCode}
609                                                                                \{
610   Write(*M, name, El::BINARY, \textcolor{stringliteral}{""});
611   \textcolor{comment}{//Write\_MPI(M, name, BINARY, "");}
612 
613   uint64\_t bytes\_written = 2 * \textcolor{keyword}{sizeof}(int) + M->Height() * M->Width() * \textcolor{keyword}{sizeof}(DataType);
614   *bytes += bytes\_written;
615 
616   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
617 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_aa7b4e710f444588dfcf4188b84b33420_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a827b050911630a21f248b128e3859044}\label{namespacelbann_a827b050911630a21f248b128e3859044}} 
\index{lbann@{lbann}!write\+\_\+double@{write\+\_\+double}}
\index{write\+\_\+double@{write\+\_\+double}!lbann@{lbann}}
\subsubsection{\texorpdfstring{write\+\_\+double()}{write\_double()}}
{\footnotesize\ttfamily bool lbann\+::write\+\_\+double (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{double}]{val }\end{DoxyParamCaption})}



Definition at line 692 of file persist.\+cpp.


\begin{DoxyCode}
692                                                              \{
693   \textcolor{keywordflow}{return} \hyperlink{namespacelbann_aed95061796f19fa1648dcc99dc335abd}{lbann::write\_bytes}(fd, name, &val, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double}));
694 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=315pt]{namespacelbann_a827b050911630a21f248b128e3859044_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a827b050911630a21f248b128e3859044_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a73339e4587f8ce7f653be03a3a6cbcd0}\label{namespacelbann_a73339e4587f8ce7f653be03a3a6cbcd0}} 
\index{lbann@{lbann}!write\+\_\+float@{write\+\_\+float}}
\index{write\+\_\+float@{write\+\_\+float}!lbann@{lbann}}
\subsubsection{\texorpdfstring{write\+\_\+float()}{write\_float()}}
{\footnotesize\ttfamily bool lbann\+::write\+\_\+float (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{float}]{val }\end{DoxyParamCaption})}



Definition at line 684 of file persist.\+cpp.


\begin{DoxyCode}
684                                                            \{
685   \textcolor{keywordflow}{return} \hyperlink{namespacelbann_aed95061796f19fa1648dcc99dc335abd}{lbann::write\_bytes}(fd, name, &val, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}));
686 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=304pt]{namespacelbann_a73339e4587f8ce7f653be03a3a6cbcd0_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a73339e4587f8ce7f653be03a3a6cbcd0_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a917727ad7e4f0dfd6d5a609cdc6dd9e2}\label{namespacelbann_a917727ad7e4f0dfd6d5a609cdc6dd9e2}} 
\index{lbann@{lbann}!write\+\_\+int32\+\_\+contig@{write\+\_\+int32\+\_\+contig}}
\index{write\+\_\+int32\+\_\+contig@{write\+\_\+int32\+\_\+contig}!lbann@{lbann}}
\subsubsection{\texorpdfstring{write\+\_\+int32\+\_\+contig()}{write\_int32\_contig()}}
{\footnotesize\ttfamily bool lbann\+::write\+\_\+int32\+\_\+contig (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{const int32\+\_\+t $\ast$}]{buf,  }\item[{uint64\+\_\+t}]{count }\end{DoxyParamCaption})}



Definition at line 674 of file persist.\+cpp.


\begin{DoxyCode}
674                                                                                            \{
675   \textcolor{keywordtype}{size\_t} bytes = count * \textcolor{keyword}{sizeof}(int32\_t);
676   \textcolor{keywordflow}{return} \hyperlink{namespacelbann_aed95061796f19fa1648dcc99dc335abd}{lbann::write\_bytes}(fd, name, buf, bytes);
677 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=307pt]{namespacelbann_a917727ad7e4f0dfd6d5a609cdc6dd9e2_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a917727ad7e4f0dfd6d5a609cdc6dd9e2_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a35a39e949cfd1d7f8c15f94e4d44ecff}\label{namespacelbann_a35a39e949cfd1d7f8c15f94e4d44ecff}} 
\index{lbann@{lbann}!write\+\_\+latest@{write\+\_\+latest}}
\index{write\+\_\+latest@{write\+\_\+latest}!lbann@{lbann}}
\subsubsection{\texorpdfstring{write\+\_\+latest()}{write\_latest()}}
{\footnotesize\ttfamily static bool lbann\+::write\+\_\+latest (\begin{DoxyParamCaption}\item[{const char $\ast$}]{dir,  }\item[{const char $\ast$}]{name,  }\item[{int}]{epoch,  }\item[{int}]{train }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 108 of file callback\+\_\+checkpoint.\+cpp.


\begin{DoxyCode}
108                                                                                   \{
109   \textcolor{comment}{// define filename}
110   \textcolor{keywordtype}{char} filename[1024];
111   sprintf(filename, \textcolor{stringliteral}{"%s/%s"}, dir, name);
112   \textcolor{comment}{// open the file for writing}
113   \textcolor{keywordtype}{int} fd = \hyperlink{namespacelbann_af596e6d2be603e9cf808c98f5412490a}{openwrite}(filename);
114   \textcolor{keywordflow}{if} (fd != -1) \{
115     \textcolor{keywordtype}{char} field[256];
116     sprintf(field, \textcolor{stringliteral}{"epoch=%d step=%d\(\backslash\)n"}, epoch, train);
117     \hyperlink{namespacelbann_add2807d7303bd96d2804f0b14e894c68}{write\_string}(fd, \textcolor{stringliteral}{"shared.last"}, field, strlen(field));
118     \textcolor{comment}{// close our file}
119     \hyperlink{namespacelbann_aceeccedbbafccfa071b21ee99be794a5}{closewrite}(fd, filename);
120   \}
121   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
122 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=310pt]{namespacelbann_a35a39e949cfd1d7f8c15f94e4d44ecff_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a35a39e949cfd1d7f8c15f94e4d44ecff_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_add2807d7303bd96d2804f0b14e894c68}\label{namespacelbann_add2807d7303bd96d2804f0b14e894c68}} 
\index{lbann@{lbann}!write\+\_\+string@{write\+\_\+string}}
\index{write\+\_\+string@{write\+\_\+string}!lbann@{lbann}}
\subsubsection{\texorpdfstring{write\+\_\+string()}{write\_string()}}
{\footnotesize\ttfamily bool lbann\+::write\+\_\+string (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{const char $\ast$}]{buf,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Definition at line 700 of file persist.\+cpp.


\begin{DoxyCode}
700                                                                                \{
701   \textcolor{keywordflow}{if} (fd > 0) \{
702     ssize\_t rc = write(fd, buf, size);
703     \textcolor{keywordflow}{if} (rc != (ssize\_t) size) \{
704       \textcolor{keywordflow}{throw} lbann\_exception(std::string(\textcolor{stringliteral}{"Failed to write: "}) + name);
705       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
706     \}
707   \}
708   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
709 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_add2807d7303bd96d2804f0b14e894c68_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a3a801c9f48655f81b886af4bff083f27}\label{namespacelbann_a3a801c9f48655f81b886af4bff083f27}} 
\index{lbann@{lbann}!write\+\_\+uint32@{write\+\_\+uint32}}
\index{write\+\_\+uint32@{write\+\_\+uint32}!lbann@{lbann}}
\subsubsection{\texorpdfstring{write\+\_\+uint32()}{write\_uint32()}}
{\footnotesize\ttfamily bool lbann\+::write\+\_\+uint32 (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{uint32\+\_\+t}]{val }\end{DoxyParamCaption})}



Definition at line 658 of file persist.\+cpp.


\begin{DoxyCode}
658                                                                \{
659   \textcolor{keywordflow}{return} \hyperlink{namespacelbann_aed95061796f19fa1648dcc99dc335abd}{lbann::write\_bytes}(fd, name, &val, \textcolor{keyword}{sizeof}(uint32\_t));
660 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=313pt]{namespacelbann_a3a801c9f48655f81b886af4bff083f27_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a3a801c9f48655f81b886af4bff083f27_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_a234f8c7b9bbc2d9310d3e40314eb497c}\label{namespacelbann_a234f8c7b9bbc2d9310d3e40314eb497c}} 
\index{lbann@{lbann}!write\+\_\+uint64@{write\+\_\+uint64}}
\index{write\+\_\+uint64@{write\+\_\+uint64}!lbann@{lbann}}
\subsubsection{\texorpdfstring{write\+\_\+uint64()}{write\_uint64()}}
{\footnotesize\ttfamily bool lbann\+::write\+\_\+uint64 (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{name,  }\item[{uint64\+\_\+t}]{val }\end{DoxyParamCaption})}



Definition at line 666 of file persist.\+cpp.


\begin{DoxyCode}
666                                                                \{
667   \textcolor{keywordflow}{return} \hyperlink{namespacelbann_aed95061796f19fa1648dcc99dc335abd}{lbann::write\_bytes}(fd, name, &val, \textcolor{keyword}{sizeof}(uint64\_t));
668 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=313pt]{namespacelbann_a234f8c7b9bbc2d9310d3e40314eb497c_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_a234f8c7b9bbc2d9310d3e40314eb497c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_af640a9302803636e0b5deb110c1aee57}\label{namespacelbann_af640a9302803636e0b5deb110c1aee57}} 
\index{lbann@{lbann}!write\+Dist@{write\+Dist}}
\index{write\+Dist@{write\+Dist}!lbann@{lbann}}
\subsubsection{\texorpdfstring{write\+Dist()}{writeDist()}}
{\footnotesize\ttfamily bool lbann\+::write\+Dist (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char $\ast$}]{filename,  }\item[{const \hyperlink{base_8hpp_a0fab5387556805cfeac3e7e567bf66c5}{Dist\+Mat} \&}]{M,  }\item[{uint64\+\_\+t $\ast$}]{bytes }\end{DoxyParamCaption})}



Given an open file descriptor, file name, and a matrix, write the matrix to the file descriptor, return the number of bytes written. 



Definition at line 66 of file persist.\+cpp.


\begin{DoxyCode}
66                                                                                      \{
67   \textcolor{comment}{// TODO: store in network order}
68 
69   \textcolor{comment}{// build our header}
70   \textcolor{keyword}{struct }\hyperlink{structlayer__header}{layer\_header} header;
71   header.\hyperlink{structlayer__header_a325142c0466170c6627710106275c7fd}{rank}        = (uint64\_t) M.Grid().Rank();
72   header.width       = (uint64\_t) M.Width();
73   header.height      = (uint64\_t) M.Height();
74   header.localwidth  = (uint64\_t) M.LocalWidth();
75   header.localheight = (uint64\_t) M.LocalHeight();
76   header.ldim        = (uint64\_t) M.LDim();
77 
78   \textcolor{comment}{// write the header to the file}
79   ssize\_t write\_rc = write(fd, &header, \textcolor{keyword}{sizeof}(header));
80   \textcolor{keywordflow}{if} (write\_rc != \textcolor{keyword}{sizeof}(header)) \{
81     \textcolor{comment}{// error!}
82   \}
83   *bytes += write\_rc;
84 
85   \textcolor{comment}{// now write the data for our part of the distributed matrix}
86   \textcolor{keyword}{const} El::Int localHeight = M.LocalHeight();
87   \textcolor{keyword}{const} El::Int localWidth = M.LocalWidth();
88   \textcolor{keyword}{const} El::Int lDim = M.LDim();
89   \textcolor{keywordflow}{if}(localHeight == lDim) \{
90     \textcolor{comment}{// the local dimension in memory matches the local height,}
91     \textcolor{comment}{// so we can write our data in a single shot}
92     \textcolor{keyword}{auto} *buf = (\textcolor{keywordtype}{void} *) M.LockedBuffer();
93     El::Int bufsize = localHeight * localWidth * \textcolor{keyword}{sizeof}(DataType);
94     write\_rc = write(fd, buf, bufsize);
95     \textcolor{keywordflow}{if} (write\_rc != bufsize) \{
96       \textcolor{comment}{// error!}
97     \}
98     *bytes += write\_rc;
99   \} \textcolor{keywordflow}{else} \{
100     \textcolor{comment}{// TODO: if this padding is small, may not be a big deal to write it out anyway}
101     \textcolor{comment}{// we've got some padding along the first dimension}
102     \textcolor{comment}{// while storing the matrix in memory, avoid writing the padding}
103     \textcolor{keywordflow}{for}(El::Int j = 0; j < localWidth; ++j) \{
104       \textcolor{keyword}{auto} *buf = (\textcolor{keywordtype}{void} *) M.LockedBuffer(0, j);
105       El::Int bufsize = localHeight * \textcolor{keyword}{sizeof}(DataType);
106       write\_rc = write(fd, buf, bufsize);
107       \textcolor{keywordflow}{if} (write\_rc != bufsize) \{
108         \textcolor{comment}{// error!}
109       \}
110       *bytes += write\_rc;
111     \}
112   \}
113 
114   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
115 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_af640a9302803636e0b5deb110c1aee57_icgraph}
\end{center}
\end{figure}


\subsection{Variable Documentation}
\mbox{\Hypertarget{namespacelbann_add9e1dd52afa73f994d5d3a44c25a818}\label{namespacelbann_add9e1dd52afa73f994d5d3a44c25a818}} 
\index{lbann@{lbann}!comm\+\_\+type\+\_\+names@{comm\+\_\+type\+\_\+names}}
\index{comm\+\_\+type\+\_\+names@{comm\+\_\+type\+\_\+names}!lbann@{lbann}}
\subsubsection{\texorpdfstring{comm\+\_\+type\+\_\+names}{comm\_type\_names}}
{\footnotesize\ttfamily std\+::vector$<$std\+::string$>$ lbann\+::comm\+\_\+type\+\_\+names\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}
=
    \{ \textcolor{stringliteral}{"none"}, \textcolor{stringliteral}{"normal"}, \textcolor{stringliteral}{"onebit\_quantization"}, \textcolor{stringliteral}{"thresh\_quantization"}, \textcolor{stringliteral}{"adaptive\_quantization"} \}
\end{DoxyCode}


Definition at line 266 of file callback\+\_\+imcomm.\+cpp.

