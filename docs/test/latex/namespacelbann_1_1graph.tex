\hypertarget{namespacelbann_1_1graph}{}\section{lbann\+:\+:graph Namespace Reference}
\label{namespacelbann_1_1graph}\index{lbann\+::graph@{lbann\+::graph}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{namespacelbann_1_1graph_a956e9f6f1b842a2ffe5bda9015bbb906}{print} (const std\+::set$<$ int $>$ \&nodes, const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&edges, std\+::ostream \&os)
\item 
std\+::set$<$ int $>$ \hyperlink{namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c}{get\+\_\+neighbors} (int node, const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&edges)
\item 
bool \hyperlink{namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b}{is\+\_\+closure} (const std\+::set$<$ int $>$ \&nodes, const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&edges)
\item 
bool \hyperlink{namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328}{is\+\_\+topologically\+\_\+sorted} (const std\+::set$<$ int $>$ \&nodes, const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&edges)
\item 
bool \hyperlink{namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb}{is\+\_\+cyclic} (const std\+::set$<$ int $>$ \&nodes, const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&edges)
\item 
std\+::map$<$ int, std\+::set$<$ int $>$ $>$ \hyperlink{namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71}{transpose} (const std\+::set$<$ int $>$ \&nodes, const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&edges)
\item 
std\+::map$<$ int, std\+::set$<$ int $>$ $>$ \hyperlink{namespacelbann_1_1graph_a54de9f8e26046c834acfc5436a93b66b}{induce\+\_\+subgraph} (const std\+::set$<$ int $>$ \&nodes, const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&edges)
\item 
std\+::vector$<$ int $>$ \hyperlink{namespacelbann_1_1graph_a6cc9ff6e6b9707deaa1c77c3b8eb0b20}{breadth\+\_\+first\+\_\+search} (int root, const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&edges)
\item 
std\+::vector$<$ int $>$ \hyperlink{namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974}{depth\+\_\+first\+\_\+search} (int root, const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&edges)
\item 
std\+::vector$<$ int $>$ \hyperlink{namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee}{topological\+\_\+sort} (const std\+::set$<$ int $>$ \&nodes, const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&edges)
\item 
void \hyperlink{namespacelbann_1_1graph_ae06c3de1931d3786348995d870b792ca}{condensation} (const std\+::set$<$ int $>$ \&nodes, const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&edges, std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&components, std\+::set$<$ int $>$ \&condensation\+\_\+nodes, std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&condensation\+\_\+edges)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespacelbann_1_1graph_a6cc9ff6e6b9707deaa1c77c3b8eb0b20}\label{namespacelbann_1_1graph_a6cc9ff6e6b9707deaa1c77c3b8eb0b20}} 
\index{lbann\+::graph@{lbann\+::graph}!breadth\+\_\+first\+\_\+search@{breadth\+\_\+first\+\_\+search}}
\index{breadth\+\_\+first\+\_\+search@{breadth\+\_\+first\+\_\+search}!lbann\+::graph@{lbann\+::graph}}
\subsubsection{\texorpdfstring{breadth\+\_\+first\+\_\+search()}{breadth\_first\_search()}}
{\footnotesize\ttfamily std\+::vector$<$ int $>$ lbann\+::graph\+::breadth\+\_\+first\+\_\+search (\begin{DoxyParamCaption}\item[{int}]{root,  }\item[{const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&}]{edges }\end{DoxyParamCaption})}

Perform a breadth-\/first search starting from a given root node. The search order is deterministic. 

Definition at line 158 of file graph.\+cpp.


\begin{DoxyCode}
159                                                                             \{
160 
161   \textcolor{comment}{// Initialize data structures}
162   std::unordered\_map<int,bool> is\_visited;
163   std::vector<int> sorted\_nodes;
164   std::queue<int> search\_queue;
165   search\_queue.push(root);
166 
167   \textcolor{comment}{// Visit nodes until search queue is exhausted}
168   \textcolor{keywordflow}{while} (!search\_queue.empty()) \{
169     \textcolor{keyword}{const} \textcolor{keyword}{auto}& node = search\_queue.front();
170     search\_queue.pop();
171     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& neighbor : \hyperlink{namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c}{get\_neighbors}(node, edges)) \{
172       \textcolor{keywordflow}{if} (!is\_visited[neighbor]) \{
173         is\_visited[neighbor] = \textcolor{keyword}{true};
174         sorted\_nodes.push\_back(neighbor);
175         search\_queue.push(neighbor);
176       \}
177     \}
178   \}
179 
180   \textcolor{comment}{// Return list of sorted nodes}
181   \textcolor{keywordflow}{return} sorted\_nodes;
182 
183 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_a6cc9ff6e6b9707deaa1c77c3b8eb0b20_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1graph_ae06c3de1931d3786348995d870b792ca}\label{namespacelbann_1_1graph_ae06c3de1931d3786348995d870b792ca}} 
\index{lbann\+::graph@{lbann\+::graph}!condensation@{condensation}}
\index{condensation@{condensation}!lbann\+::graph@{lbann\+::graph}}
\subsubsection{\texorpdfstring{condensation()}{condensation()}}
{\footnotesize\ttfamily void lbann\+::graph\+::condensation (\begin{DoxyParamCaption}\item[{const std\+::set$<$ int $>$ \&}]{nodes,  }\item[{const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&}]{edges,  }\item[{std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&}]{components,  }\item[{std\+::set$<$ int $>$ \&}]{condensation\+\_\+nodes,  }\item[{std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&}]{condensation\+\_\+edges }\end{DoxyParamCaption})}

Construct the condensation of a graph. The condensation of a graph is constructed by determining the strongly connected components, i.\+e. sets of nodes that are reachable from all nodes in the set, and coalescing them into single nodes. The condensation is a D\+AG and will be topologically sorted. 

Definition at line 267 of file graph.\+cpp.


\begin{DoxyCode}
271                                                                \{
272 
273   \textcolor{comment}{// Initialize data structures for unsorted condensation}
274   std::unordered\_map<int,std::set<int>> unsorted\_components;
275   std::unordered\_map<int,int> unsorted\_component\_assignments;
276   std::set<int> unsorted\_condensation\_nodes;
277   std::map<int,std::set<int>> unsorted\_condensation\_edges;
278 
279   \textcolor{comment}{// Find strongly connected components with Kosaraju's algorithm}
280   \textcolor{comment}{// Note: First sort nodes by DFS post-order. Then, pick root nodes}
281   \textcolor{comment}{// in DFS post-order and perform DFS on graph transpose. The first}
282   \textcolor{comment}{// DFS that visits a node determines the strongly connected}
283   \textcolor{comment}{// component it belongs to.}
284   \textcolor{keyword}{const} \textcolor{keyword}{auto}& transpose\_edges = \hyperlink{namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71}{transpose}(nodes, edges);
285   std::stack<int> dfs\_stack;
286   std::unordered\_map<int,bool> is\_sorted, is\_condensed;
287   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& root : nodes) \{
288     \textcolor{keywordflow}{if} (!is\_sorted[root]) \{
289       \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& node : \hyperlink{namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974}{depth\_first\_search}(root, edges)) \{
290         \textcolor{keywordflow}{if} (!is\_sorted[node]) \{
291           is\_sorted[node] = \textcolor{keyword}{true};
292           dfs\_stack.push(node);
293         \}
294       \}
295     \}
296   \}
297   \textcolor{keywordflow}{while} (!dfs\_stack.empty()) \{
298     \textcolor{keyword}{const} \textcolor{keyword}{auto}& root = dfs\_stack.top();
299     dfs\_stack.pop();
300     \textcolor{keywordflow}{if} (!is\_condensed[root]) \{
301       \textcolor{keyword}{const} \textcolor{keywordtype}{int} index = unsorted\_condensation\_nodes.size();
302       unsorted\_condensation\_nodes.insert(index);
303       \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& node : \hyperlink{namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974}{depth\_first\_search}(root, transpose\_edges)) \{
304         \textcolor{keywordflow}{if} (!is\_condensed[node]) \{
305           is\_condensed[node] = \textcolor{keyword}{true};
306           unsorted\_component\_assignments[node] = index;
307           unsorted\_components[index].insert(node);
308         \}
309       \}
310     \}
311   \}
312 
313   \textcolor{comment}{// Find edges in unsorted condensation}
314   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& node : nodes) \{
315     \textcolor{keyword}{const} \textcolor{keyword}{auto}& unsorted\_component = unsorted\_component\_assignments[node];
316     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& neighbor : \hyperlink{namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c}{get\_neighbors}(node, edges)) \{
317       \textcolor{keyword}{const} \textcolor{keyword}{auto}& neighbor\_unsorted\_component = unsorted\_component\_assignments[neighbor];
318       \textcolor{keywordflow}{if} (unsorted\_component != neighbor\_unsorted\_component) \{
319         unsorted\_condensation\_edges[unsorted\_component].insert(neighbor\_unsorted\_component);
320       \}
321     \}
322   \}
323 
324   \textcolor{comment}{// Topologically sort condensation}
325   \textcolor{keyword}{const} \textcolor{keyword}{auto}& sorted\_to\_unsorted = \hyperlink{namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee}{topological\_sort}(unsorted\_condensation\_nodes,
326                                                     unsorted\_condensation\_edges);
327 
328   \textcolor{comment}{// Record sorted condensation to output}
329   components.clear();
330   condensation\_nodes.clear();
331   condensation\_edges.clear();
332   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < unsorted\_condensation\_nodes.size(); ++i) \{
333     condensation\_nodes.insert(i);
334   \}
335   std::unordered\_map<int,int> unsorted\_to\_sorted;
336   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& component : condensation\_nodes) \{
337     \textcolor{keyword}{const} \textcolor{keyword}{auto}& unsorted\_component = sorted\_to\_unsorted[component];
338     unsorted\_to\_sorted[unsorted\_component] = component;
339   \}
340   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& unsorted\_component : unsorted\_condensation\_nodes) \{
341     \textcolor{keyword}{const} \textcolor{keyword}{auto}& component = unsorted\_to\_sorted[unsorted\_component];
342     components[component] = unsorted\_components[unsorted\_component];
343     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& neighbor\_unsorted\_component : unsorted\_condensation\_edges[unsorted\_component]) \{
344       condensation\_edges[component].insert(unsorted\_to\_sorted[neighbor\_unsorted\_component]);
345     \}
346   \}
347 
348 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_ae06c3de1931d3786348995d870b792ca_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974}\label{namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974}} 
\index{lbann\+::graph@{lbann\+::graph}!depth\+\_\+first\+\_\+search@{depth\+\_\+first\+\_\+search}}
\index{depth\+\_\+first\+\_\+search@{depth\+\_\+first\+\_\+search}!lbann\+::graph@{lbann\+::graph}}
\subsubsection{\texorpdfstring{depth\+\_\+first\+\_\+search()}{depth\_first\_search()}}
{\footnotesize\ttfamily std\+::vector$<$ int $>$ lbann\+::graph\+::depth\+\_\+first\+\_\+search (\begin{DoxyParamCaption}\item[{int}]{root,  }\item[{const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&}]{edges }\end{DoxyParamCaption})}

Perform a depth-\/first search starting from a given root node. A depth-\/first search post-\/order is returned. The search order is deterministic. 

Definition at line 185 of file graph.\+cpp.


\begin{DoxyCode}
186                                                                           \{
187 
188   \textcolor{comment}{// Initialize data structures}
189   std::unordered\_map<int,bool> is\_visited, is\_sorted;
190   std::vector<int> sorted\_nodes;
191   std::stack<int> search\_stack;
192   search\_stack.push(root);
193 
194   \textcolor{comment}{// Visit nodes until search stack is exhausted}
195   \textcolor{keywordflow}{while} (!search\_stack.empty()) \{
196     \textcolor{keyword}{const} \textcolor{keyword}{auto}& node = search\_stack.top();
197     search\_stack.pop();
198     \textcolor{keywordflow}{if} (!is\_sorted[node]) \{
199       \textcolor{keywordflow}{if} (is\_visited[node]) \{
200         \textcolor{comment}{// Add node to sorted list if we have already visited}
201         is\_sorted[node] = \textcolor{keyword}{true};
202         sorted\_nodes.push\_back(node);
203       \} \textcolor{keywordflow}{else} \{
204         \textcolor{comment}{// Visit node and add neighbors to search stack}
205         is\_visited[node] = \textcolor{keyword}{true};
206         search\_stack.push(node);
207         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& neighbor : \hyperlink{namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c}{get\_neighbors}(node, edges)) \{
208           \textcolor{keywordflow}{if} (!is\_visited[neighbor] && !is\_sorted[neighbor]) \{
209             search\_stack.push(neighbor);
210           \}
211         \}
212       \}
213     \}
214   \}
215 
216   \textcolor{comment}{// Return list of sorted nodes}
217   \textcolor{keywordflow}{return} sorted\_nodes;
218 
219 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c}\label{namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c}} 
\index{lbann\+::graph@{lbann\+::graph}!get\+\_\+neighbors@{get\+\_\+neighbors}}
\index{get\+\_\+neighbors@{get\+\_\+neighbors}!lbann\+::graph@{lbann\+::graph}}
\subsubsection{\texorpdfstring{get\+\_\+neighbors()}{get\_neighbors()}}
{\footnotesize\ttfamily std\+::set$<$ int $>$ lbann\+::graph\+::get\+\_\+neighbors (\begin{DoxyParamCaption}\item[{int}]{node,  }\item[{const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&}]{edges }\end{DoxyParamCaption})}

Get nodes adjacent to a given node. 

Definition at line 49 of file graph.\+cpp.


\begin{DoxyCode}
50                                                                   \{
51   \textcolor{keywordflow}{if} (edges.count(node) > 0) \{
52     \textcolor{keywordflow}{return} edges.at(node);
53   \} \textcolor{keywordflow}{else} \{
54     \textcolor{keywordflow}{return} std::set<int>();
55   \}
56 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1graph_a54de9f8e26046c834acfc5436a93b66b}\label{namespacelbann_1_1graph_a54de9f8e26046c834acfc5436a93b66b}} 
\index{lbann\+::graph@{lbann\+::graph}!induce\+\_\+subgraph@{induce\+\_\+subgraph}}
\index{induce\+\_\+subgraph@{induce\+\_\+subgraph}!lbann\+::graph@{lbann\+::graph}}
\subsubsection{\texorpdfstring{induce\+\_\+subgraph()}{induce\_subgraph()}}
{\footnotesize\ttfamily std\+::map$<$ int, std\+::set$<$ int $>$ $>$ lbann\+::graph\+::induce\+\_\+subgraph (\begin{DoxyParamCaption}\item[{const std\+::set$<$ int $>$ \&}]{nodes,  }\item[{const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&}]{edges }\end{DoxyParamCaption})}

Construct an induced subgraph. Removes edges to nodes outside the set of nodes and returns the new set of edges. 

Definition at line 145 of file graph.\+cpp.


\begin{DoxyCode}
146                                                                                   \{
147   std::map<int,std::set<int>> induced\_edges;
148   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& node : nodes) \{
149     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& neighbor : \hyperlink{namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c}{get\_neighbors}(node, edges)) \{
150       \textcolor{keywordflow}{if} (nodes.count(neighbor) > 0) \{
151         induced\_edges[node].insert(neighbor);
152       \}
153     \}
154   \}
155   \textcolor{keywordflow}{return} induced\_edges;
156 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_a54de9f8e26046c834acfc5436a93b66b_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b}\label{namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b}} 
\index{lbann\+::graph@{lbann\+::graph}!is\+\_\+closure@{is\+\_\+closure}}
\index{is\+\_\+closure@{is\+\_\+closure}!lbann\+::graph@{lbann\+::graph}}
\subsubsection{\texorpdfstring{is\+\_\+closure()}{is\_closure()}}
{\footnotesize\ttfamily bool lbann\+::graph\+::is\+\_\+closure (\begin{DoxyParamCaption}\item[{const std\+::set$<$ int $>$ \&}]{nodes,  }\item[{const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&}]{edges }\end{DoxyParamCaption})}

Check whether a graph is a closure. A closure is a set of nodes with no edges to nodes outside the set. 

Definition at line 58 of file graph.\+cpp.


\begin{DoxyCode}
59                                                       \{
60   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& node : nodes) \{
61     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& neighbor : \hyperlink{namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c}{get\_neighbors}(node, edges)) \{
62       \textcolor{keywordflow}{if} (nodes.count(neighbor) == 0) \{
63         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
64       \}
65     \}
66   \}
67   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
68 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb}\label{namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb}} 
\index{lbann\+::graph@{lbann\+::graph}!is\+\_\+cyclic@{is\+\_\+cyclic}}
\index{is\+\_\+cyclic@{is\+\_\+cyclic}!lbann\+::graph@{lbann\+::graph}}
\subsubsection{\texorpdfstring{is\+\_\+cyclic()}{is\_cyclic()}}
{\footnotesize\ttfamily bool lbann\+::graph\+::is\+\_\+cyclic (\begin{DoxyParamCaption}\item[{const std\+::set$<$ int $>$ \&}]{nodes,  }\item[{const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&}]{edges }\end{DoxyParamCaption})}

Check whether a directed graph is cyclic. 

Definition at line 86 of file graph.\+cpp.


\begin{DoxyCode}
87                                                      \{
88 
89   \textcolor{comment}{// Check that graph is valid}
90   \textcolor{keywordflow}{if} (!\hyperlink{namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b}{is\_closure}(nodes, edges)) \{
91     std::stringstream err;
92     err << \_\_FILE\_\_ << \textcolor{stringliteral}{" "} << \_\_LINE\_\_ << \textcolor{stringliteral}{" :: "} << \textcolor{stringliteral}{"graph is not a closure"};
93     \textcolor{keywordflow}{throw} lbann\_exception(err.str());
94   \}
95 
96   \textcolor{comment}{// Topologically sorted graphs are not cyclic}
97   \textcolor{keywordflow}{if} (\hyperlink{namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328}{is\_topologically\_sorted}(nodes, edges)) \{
98     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
99   \}
100 
101   \textcolor{comment}{// Perform depth-first searches to detect cycles}
102   std::unordered\_map<int,bool> is\_visited, is\_sorted;
103   std::stack<int> search\_stack;
104   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}&& it = nodes.rbegin(); it != nodes.rend(); ++it) \{
105     search\_stack.push(*it);
106   \}
107   \textcolor{keywordflow}{while} (!search\_stack.empty()) \{
108     \textcolor{keyword}{const} \textcolor{keyword}{auto}& node = search\_stack.top();
109     search\_stack.pop();
110     \textcolor{keywordflow}{if} (!is\_sorted[node]) \{
111       \textcolor{keywordflow}{if} (is\_visited[node]) \{
112         is\_sorted[node] = \textcolor{keyword}{true};
113       \} \textcolor{keywordflow}{else} \{
114         is\_visited[node] = \textcolor{keyword}{true};
115         search\_stack.push(node);
116         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& neighbor : \hyperlink{namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c}{get\_neighbors}(node, edges)) \{
117           \textcolor{keywordflow}{if} (is\_visited[neighbor] && !is\_sorted[neighbor]) \{
118             \textcolor{keywordflow}{return} \textcolor{keyword}{true};
119           \}
120           search\_stack.push(neighbor);
121         \}
122       \}
123     \}
124   \}
125   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
126   
127 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328}\label{namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328}} 
\index{lbann\+::graph@{lbann\+::graph}!is\+\_\+topologically\+\_\+sorted@{is\+\_\+topologically\+\_\+sorted}}
\index{is\+\_\+topologically\+\_\+sorted@{is\+\_\+topologically\+\_\+sorted}!lbann\+::graph@{lbann\+::graph}}
\subsubsection{\texorpdfstring{is\+\_\+topologically\+\_\+sorted()}{is\_topologically\_sorted()}}
{\footnotesize\ttfamily bool lbann\+::graph\+::is\+\_\+topologically\+\_\+sorted (\begin{DoxyParamCaption}\item[{const std\+::set$<$ int $>$ \&}]{nodes,  }\item[{const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&}]{edges }\end{DoxyParamCaption})}

Check whether a graph is topologically sorted. A topologically sorted graph has no edges going from a node to an earlier node. The graph must be a directed acyclic graph. 

Definition at line 70 of file graph.\+cpp.


\begin{DoxyCode}
71                                                                    \{
72   \textcolor{keywordflow}{if} (!\hyperlink{namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b}{is\_closure}(nodes, edges)) \{
73     std::stringstream err;
74     err << \_\_FILE\_\_ << \textcolor{stringliteral}{" "} << \_\_LINE\_\_ << \textcolor{stringliteral}{" :: "} << \textcolor{stringliteral}{"graph is not a closure"};
75     \textcolor{keywordflow}{throw} lbann\_exception(err.str());
76   \}
77   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& node : nodes) \{
78     \textcolor{keyword}{const} \textcolor{keyword}{auto}& neighbors = \hyperlink{namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c}{get\_neighbors}(node, edges);
79     \textcolor{keywordflow}{if} (neighbors.size() > 0 && *neighbors.begin() <= node) \{
80       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
81     \}
82   \}
83   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
84 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1graph_a956e9f6f1b842a2ffe5bda9015bbb906}\label{namespacelbann_1_1graph_a956e9f6f1b842a2ffe5bda9015bbb906}} 
\index{lbann\+::graph@{lbann\+::graph}!print@{print}}
\index{print@{print}!lbann\+::graph@{lbann\+::graph}}
\subsubsection{\texorpdfstring{print()}{print()}}
{\footnotesize\ttfamily void lbann\+::graph\+::print (\begin{DoxyParamCaption}\item[{const std\+::set$<$ int $>$ \&}]{nodes,  }\item[{const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&}]{edges,  }\item[{std\+::ostream \&}]{os = {\ttfamily std\+:\+:cout} }\end{DoxyParamCaption})}

Print the nodes and edges of a graph to an output stream. 

Definition at line 37 of file graph.\+cpp.


\begin{DoxyCode}
39                            \{
40   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& node : nodes) \{
41     os << \textcolor{stringliteral}{"node "} << node << \textcolor{stringliteral}{" neighbors :"};
42     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& neighbor : \hyperlink{namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c}{get\_neighbors}(node, edges)) \{
43       os << \textcolor{stringliteral}{" "} << neighbor;
44     \}
45     os << \textcolor{stringliteral}{"\(\backslash\)n"};
46   \}
47 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_a956e9f6f1b842a2ffe5bda9015bbb906_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee}\label{namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee}} 
\index{lbann\+::graph@{lbann\+::graph}!topological\+\_\+sort@{topological\+\_\+sort}}
\index{topological\+\_\+sort@{topological\+\_\+sort}!lbann\+::graph@{lbann\+::graph}}
\subsubsection{\texorpdfstring{topological\+\_\+sort()}{topological\_sort()}}
{\footnotesize\ttfamily std\+::vector$<$ int $>$ lbann\+::graph\+::topological\+\_\+sort (\begin{DoxyParamCaption}\item[{const std\+::set$<$ int $>$ \&}]{nodes,  }\item[{const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&}]{edges }\end{DoxyParamCaption})}

Topologically sort a graph. A topologically sorted graph has no edges going from a node to an earlier node. The sort is deterministic and does not affect graphs that are already topologically sorted. 

Definition at line 222 of file graph.\+cpp.


\begin{DoxyCode}
223                                                                         \{
224 
225   \textcolor{comment}{// Check that graph is valid}
226   \textcolor{keywordflow}{if} (!\hyperlink{namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b}{is\_closure}(nodes, edges)) \{
227     std::stringstream err;
228     err << \_\_FILE\_\_ << \textcolor{stringliteral}{" "} << \_\_LINE\_\_ << \textcolor{stringliteral}{" :: "} << \textcolor{stringliteral}{"graph is not a closure"};
229     \textcolor{keywordflow}{throw} lbann\_exception(err.str());
230   \}
231   \textcolor{keywordflow}{if} (\hyperlink{namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb}{is\_cyclic}(nodes, edges)) \{
232     std::stringstream err;
233     err << \_\_FILE\_\_ << \textcolor{stringliteral}{" "} << \_\_LINE\_\_ << \textcolor{stringliteral}{" :: "} << \textcolor{stringliteral}{"graph is cyclic"};
234     \textcolor{keywordflow}{throw} lbann\_exception(err.str());
235   \}
236 
237   \textcolor{comment}{// Return original order if already sorted}
238   \textcolor{keywordflow}{if} (\hyperlink{namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328}{is\_topologically\_sorted}(nodes, edges)) \{
239     \textcolor{keywordflow}{return} std::vector<int>(nodes.begin(), nodes.end());
240   \}
241 
242   \textcolor{comment}{// Perform depth-first searches on nodes}
243   std::stack<int> sorted\_stack;
244   std::unordered\_map<int,bool> is\_sorted;
245   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& root : nodes) \{
246     \textcolor{keywordflow}{if} (!is\_sorted[root]) \{
247       \textcolor{keyword}{const} \textcolor{keyword}{auto}& dfs = \hyperlink{namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974}{depth\_first\_search}(root, edges);
248       \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& node : dfs) \{
249         \textcolor{keywordflow}{if} (!is\_sorted[node]) \{
250           is\_sorted[node] = \textcolor{keyword}{true};
251           sorted\_stack.push(node);
252         \}
253       \}
254     \}
255   \}
256 
257   \textcolor{comment}{// Reverse DFS post-order is topologically sorted}
258   std::vector<int> sorted\_nodes;
259   \textcolor{keywordflow}{while} (!sorted\_stack.empty()) \{
260     sorted\_nodes.push\_back(sorted\_stack.top());
261     sorted\_stack.pop();
262   \}
263   \textcolor{keywordflow}{return} sorted\_nodes;
264   
265 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71}\label{namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71}} 
\index{lbann\+::graph@{lbann\+::graph}!transpose@{transpose}}
\index{transpose@{transpose}!lbann\+::graph@{lbann\+::graph}}
\subsubsection{\texorpdfstring{transpose()}{transpose()}}
{\footnotesize\ttfamily std\+::map$<$ int, std\+::set$<$ int $>$ $>$ lbann\+::graph\+::transpose (\begin{DoxyParamCaption}\item[{const std\+::set$<$ int $>$ \&}]{nodes,  }\item[{const std\+::map$<$ int, std\+::set$<$ int $>$$>$ \&}]{edges }\end{DoxyParamCaption})}

Construct the transpose of a graph. Reverses the direction of edges in the graph and returns the new set of edges. 

Definition at line 129 of file graph.\+cpp.


\begin{DoxyCode}
130                                                                             \{
131   \textcolor{keywordflow}{if} (!\hyperlink{namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b}{is\_closure}(nodes, edges)) \{
132     std::stringstream err;
133     err << \_\_FILE\_\_ << \textcolor{stringliteral}{" "} << \_\_LINE\_\_ << \textcolor{stringliteral}{" :: "} << \textcolor{stringliteral}{"graph is not a closure"};
134     \textcolor{keywordflow}{throw} lbann\_exception(err.str());
135   \}
136   std::map<int,std::set<int>> transpose\_edges;
137   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& node : nodes) \{
138     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& neighbor : \hyperlink{namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c}{get\_neighbors}(node, edges)) \{
139       transpose\_edges[neighbor].insert(node);
140     \}
141   \}
142   \textcolor{keywordflow}{return} transpose\_edges;
143 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71_icgraph}
\end{center}
\end{figure}
